<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="shiron" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="shiron">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="shiron">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shiron">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> shiron </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">shiron</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/cell中的折叠效果如何实现/" itemprop="url">
                  cell中的折叠效果如何实现?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-02T14:35:46+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点开后可以查看具体的联系人-那么这种效果是如何实现的呢"><a href="#有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点开后可以查看具体的联系人-那么这种效果是如何实现的呢" class="headerlink" title="有时候我们需要实现一种点击cell的时候,展开和收起cell的内容这种效果,类似QQ的分组,点开后可以查看具体的联系人.那么这种效果是如何实现的呢?"></a>有时候我们需要实现一种点击cell的时候,展开和收起cell的内容这种效果,类似QQ的分组,点开后可以查看具体的联系人.那么这种效果是如何实现的呢?</h4><p><img src="http://ww3.sinaimg.cn/mw690/7616e2bagw1f9dr91e3pyj20kk11uabk.jpg" alt="image"></p>
<p>这里列举一种最简答的实现方法,主要核心代码是要在模型中设置一个是否展开的属性,根据这个属性来判断是否要展开cell,如果NO的时候,只要在<code>tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</code>返回中返回0即可,如果YES的时候,则需要返回一个cell中具体的行数.header只要给定一个点击事件来刷新tableView就可以了(此时要修改是否要展示的属性).</p>
<p>下面分部讲解一下设置的方法:</p>
<h3 id="1-先设置一个模型数组-里面含有一下几个属性"><a href="#1-先设置一个模型数组-里面含有一下几个属性" class="headerlink" title="1. 先设置一个模型数组,里面含有一下几个属性"></a>1. 先设置一个模型数组,里面含有一下几个属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface MyData : NSObject</div><div class="line">//名称 ABCD...</div><div class="line">@property (nonatomic ,copy ) NSString* name;</div><div class="line">//是否展示</div><div class="line">@property (nonatomic , assign ) BOOL isShow;</div><div class="line">//子数组 </div><div class="line">@property (nonatomic , strong ) NSMutableArray* array;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="2-添加视图View和数据源数据"><a href="#2-添加视图View和数据源数据" class="headerlink" title="2. 添加视图View和数据源数据"></a>2. 添加视图View和数据源数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //数据源数组,里面装的是模型数组</div><div class="line">    _dataArray = [NSMutableArray array];</div><div class="line">    </div><div class="line">    //设置数据</div><div class="line">    for (int i = &apos;A&apos;; i&lt;= &apos;Z&apos;; i++) &#123;</div><div class="line">        MyData * mydata =  [[MyData alloc] init];</div><div class="line">        NSLog(@&quot;%c&quot; , i);</div><div class="line">        mydata.name =  [NSString stringWithFormat:@&quot;%c&quot;,i];</div><div class="line">        </div><div class="line">        mydata.array =  [NSMutableArray array];</div><div class="line">        for (int j = 0;  j &lt;= 10; j++) &#123;</div><div class="line">            [mydata.array addObject:[NSString stringWithFormat:@&quot;%c-%d&quot;,i,j]];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        [_dataArray addObject:mydata];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">	//设置tableView,一定要注意,这里的样式是要选组样式</div><div class="line">    _myTableview =  [[UITableView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) style:UITableViewStyleGrouped];</div><div class="line">    _myTableview.dataSource = self;</div><div class="line">    _myTableview.delegate = self;</div><div class="line">    _myTableview.rowHeight = 30;</div><div class="line">    [self.view addSubview:_myTableview];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-设置tableView的代理内容-主要是常用的两个加上在section中要设置判断条件"><a href="#3-设置tableView的代理内容-主要是常用的两个加上在section中要设置判断条件" class="headerlink" title="3. 设置tableView的代理内容,主要是常用的两个加上在section中要设置判断条件"></a>3. 设置tableView的代理内容,主要是常用的两个加上在section中要设置判断条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//显示多少组</div><div class="line">-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123;</div><div class="line">    return self.dataArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//每一组里面显示多少个cell</div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    </div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:section];</div><div class="line">    </div><div class="line">    if (data.isShow)&#123;</div><div class="line">        return data.array.count;</div><div class="line">    &#125;else&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//设置cell的样式</div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    static NSString * cellName = @&quot;cell&quot;;</div><div class="line">    UITableViewCell* cell =  [tableView dequeueReusableCellWithIdentifier:cellName ];</div><div class="line">    </div><div class="line">    if (!cell)&#123;</div><div class="line">        </div><div class="line">        cell =  [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:cellName];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:indexPath.section];</div><div class="line">    cell.textLabel.text = [data.array objectAtIndex:indexPath.row];</div><div class="line">    return  cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-设置headerView-并且设置点击时展开和闭合cell"><a href="#4-设置headerView-并且设置点击时展开和闭合cell" class="headerlink" title="4. 设置headerView,并且设置点击时展开和闭合cell"></a>4. 设置headerView,并且设置点击时展开和闭合cell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123;</div><div class="line">    //获取数组</div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:section];</div><div class="line">    //生成btn的属性,并添加到headerView中</div><div class="line">    UIButton* btn =  [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    btn.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 30);</div><div class="line">    [btn setTitle:data.name forState:UIControlStateNormal];</div><div class="line">    btn.tag = section;</div><div class="line">    [btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    if (section%2)&#123;</div><div class="line">        </div><div class="line">        btn.backgroundColor =  [UIColor darkGrayColor];</div><div class="line">        </div><div class="line">    &#125;else&#123;</div><div class="line">        </div><div class="line">        btn.backgroundColor =  [UIColor grayColor];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return btn;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//设置headerView的高度</div><div class="line">-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;</div><div class="line">    return 30;</div><div class="line">&#125;</div><div class="line">//设置footerView的高度,这家伙如果不设置或者设置为0的是否都好像会显示和headerView一样的高度</div><div class="line">-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123;</div><div class="line">    return 0.1;</div><div class="line">&#125;</div><div class="line">//点击事件,展开和收合cell</div><div class="line">-(void)btnClick:(UIButton*) btn&#123;</div><div class="line">    MyData* data =  [self.dataArray  objectAtIndex:btn.tag];</div><div class="line">    if (data.isShow) &#123;</div><div class="line">        data.isShow = NO;</div><div class="line">    &#125;else&#123;</div><div class="line">        data.isShow = YES;</div><div class="line">    &#125;</div><div class="line">    //刷新动画样式</div><div class="line">    [_myTableview reloadSections:[NSIndexSet indexSetWithIndex:btn.tag] withRowAnimation:UITableViewRowAnimationFade];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/18/Swift-访问控制/" itemprop="url">
                  Swift-访问控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-18T17:22:13+08:00" content="2016-07-18">
              2016-07-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>和其他高级语言一样Swift中也增加了访问控制，在Swift中提供了private、internal、public三种访问级别，但是不同的是Swift中的访问级别是基于模块（module，或者target）和源文件（.swift文件）的，而不是基于类型、命名空间声明。</p>
<ul>
<li>private:只能访问当前源文件中的实体（注意Swift中的private和其他语言不太一样，它是基于源文件的，作用范围是整个源文件，如果一个源文件中有两个类，那么一个类可以访问另外一个类的私有成员）。</li>
<li>internal:可以访问当前模块中的其他任何实体，但是在模块外无法访问，这是所有实体的默认访问级别（通常在一个单目标Application中不需要自行设置访问级别）。</li>
<li>public:可以访问当前模块及其他模块中的任何实体（通常用于Framework）。</li>
</ul>
<p>下面是关于Swift关于不同成员访问级别的约定规则：</p>
<ol>
<li>如果一个类的访问级别是private那么该类的所有成员都是private（此时成员无法修改访问级别），如果一个类的访问级别是internal或者public那么它的所有成员都是internal（如果类的访问级别是public，成员默认internal，此时可以单独修改成员的访问级别），类成员的访问级别不能高于类的访问级别(注意：嵌套类型的访问级别也符合此条规则)；</li>
<li>常量、变量、属性、下标脚本访问级别低于其所声明的类型级别，并且如果不是默认访问级别（internal）要明确声明访问级别（例如一个常量是一个private类型的类类型，那么此常量必须声明为private）；</li>
<li>在不违反1、2两条规则的情况下，setter的访问级别可以低于getter的访问级别(例如一个属性访问级别是internal，那么可以添加private(set)修饰将setter权限设置为private，在当前模块中只有此源文件可以访问，对外部是只读的);</li>
<li>必要构造方法（required修饰）的访问级别必须和类访问级别相同，结构体的默认逐一构造函数的访问级别不高于其成员的访问级别（例如一个成员是private那么这个构造函数就是private，但是可以通过自定义来声明一个public的构造函数）,其他方法（包括其他构造方法和普通方法）的访问级别遵循规则1；</li>
<li>子类的访问级别不高于父类的访问级别，但是在遵循三种访问级别作用范围的前提下子类可以将父类低访问级别的成员重写成更高的访问级别（例如父类A和子类B在同一个源文件，A的访问级别是public，B的访问级别是internal，其中A有一个private方法，那么A可以覆盖其private方法并重写为internal）；</li>
<li>协议中所有必须实现的成员的访问级别和协议本身的访问级别相同，其子协议的访问级别不高于父协议；</li>
<li>如果一个类继承于另一个类的同时实现了某个协议那么这个类的访问级别为父类和协议的最低访问级别，并且此类中方法访问级别和所实现的协议中的方法相同；</li>
<li>扩展的成员访问级别遵循规则1，但是对于类、结构体、枚举的扩展可以明确声明访问级别并且可以更低（例如对于internal的类，你可以声明一个private的扩展），而协议的访问级别不可以明确声明；</li>
<li>元组的访问级别是元组中各个元素的最低访问级别，注意：元组的访问级别是自动推导的，无法直接使用以上三个关键字修饰其访问级别；<ol>
<li>函数的访问级是函数的参数、返回值的最低级别，并且如果其访问级别和默认访问级别（internal）不符需要明确声明；</li>
<li>枚举成员的访问级别等同于枚举的访问级别（无法单独设置），同时枚举的原始值、关联值的访问级别不能低于枚举的访问级别；</li>
</ol>
</li>
<li>泛型类型或泛型函数的访问级别是泛型类型、泛型函数、泛型类型参数三者中最低的一个；</li>
<li><p>类型别名的访问级别不能高于原类型的访问级别；</p>
<p>上面这些规则看上去比较繁琐，但其实很多内容理解起来也是顺理成章的（如果你是一个语言设计者相信大部分规则也会这么设计），下面通过一个例子对于规则3做一解释，这一点和其他语言有所不同但是却更加实用。在使用ObjC开发时大家通常会有这样的经验：在一个类中希望某个属性对外界是只读的，但是自己又需要在类中对属性进行写操作，此时只能直接访问属性对应的成员变量，而不能直接访问属性进行设置。但是Swift为了让语法尽可能精简，并没有成员变量的概念，此时就可以通过访问控制来实现。</p>
</li>
</ol>
<p>Person.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import Foundation</div><div class="line"> </div><div class="line">public class Person &#123;</div><div class="line">    //设置setter私有，但是getter为public</div><div class="line">    public private(set) var name:String</div><div class="line">     </div><div class="line">    public init(name:String)&#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public func showMessage()&#123;</div><div class="line">        println(&quot;name=\(name)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import Foundation</div><div class="line"> </div><div class="line">var p =  Person(name:&quot;Kenshin&quot;)</div><div class="line">//此时不能设置name属性，但是可读</div><div class="line">//p.name = &quot;Kaoru&quot;</div><div class="line">println(&quot;name=\(p.name)&quot;)</div><div class="line">p.showMessage()</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/Java异常处理抛出/" itemprop="url">
                  Java异常处理抛出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T14:34:48+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.</p>
<p>###1.所谓的异常就是在Java程序运行过程中出现的错误.</p>
<ul>
<li>Error : 直接的错误信息,网络回调错误,数据库异常等.</li>
<li>Execption : 异常信息,较为核心的是RuntimeException子类<br>######<em>注:以上两个类都是继承了Throwable的类</em></li>
</ul>
<p>###2.try…catch 的格式(方式)</p>
<ul>
<li>A:异常处理的两种方式<ul>
<li>a:try…catch…finally<br><em>注意:1.被finally控制的语句体一定会执行</em><br><em>2.用于释放资源，在IO流操作和数据库操作中会见到</em><ul>
<li>try catch</li>
<li>try catch finally</li>
<li>try finally </li>
</ul>
</li>
<li>b:throws</li>
</ul>
</li>
<li>B:try…catch处理异常的基本格式<ul>
<li>try…catch…finally</li>
</ul>
</li>
</ul>
<p>###3.那么我们如何选择异常处理的方式呢?</p>
<ul>
<li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li>
<li>区别:<ul>
<li>后续程序需要继续运行就try</li>
<li>后续程序不需要继续运行就throws</li>
</ul>
</li>
</ul>
<p>###4.自定义异常的主要原因是为了可以快速定位异常的原因</p>
<ul>
<li>一种是继承自RuntimeException,另外一种是继承Exception.</li>
</ul>
<p><em>其实对于异常的使用,还是不是特别理解,日后回来再填坑.</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/ObjectMapper/" itemprop="url">
                  ObjectMapper的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-06T17:47:47+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于ObjectMapper"><a href="#关于ObjectMapper" class="headerlink" title="关于ObjectMapper"></a>关于ObjectMapper</h3><p>关于这个第三方库,我也是最近才接触到,在转到swift的项目当中,其实很长时间都在寻找一个适合库来做网络请求回来的JSON解析,但一直都没有找到较好的,所以之前的项目一直都是手动字典转模型,最近发现了一个轻巧又实用的库–而且再多层嵌套,也可以用几句代码完成转换,简直可以媲美OC中字典转模型的第三方框架.</p>
<p>Github的地址为:<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="external">https://github.com/Hearst-DD/ObjectMapper</a></p>
<p>本文主要是翻译github的内容,大家如果英文阅读能力较好的可以自己翻看英文文档</p>
<h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><p>如果一个类或者结构体的接口实现了<strong><em>Mappable</em></strong>接口的时,便可以支持映射,然后还需要实现协议中的两个接口:</p>
<pre><code>init?(_ map: Map)mutating 
func mapping(map: Map)
</code></pre><p>ObjectMapper实用了一个操作符 “&lt;-“来定义成员变量的映射和JSON的转换.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class User: Mappable &#123;</div><div class="line">//这里要定义好需要转换的内容相对于的字段和类型,以后日后方便赋值转换</div><div class="line"> </div><div class="line">  </div><div class="line">    var username: String?</div><div class="line">    var age: Int?</div><div class="line">    var weight: Double!</div><div class="line">    var array: [AnyObject]?</div><div class="line">    var dictionary: [String : AnyObject] = [:]</div><div class="line">    var bestFriend: User?                       // Nested User object</div><div class="line">    var friends: [User]?                        // Array of Users</div><div class="line">    var birthday: NSDate?</div><div class="line">    </div><div class="line">    required init?(_ map: Map) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Mappable</div><div class="line">    func mapping(map: Map) &#123;</div><div class="line">  //根据字典中的内容用&quot;&lt;-&quot;操作符号来映射相应的内容,将其转换到定义好的成员变量中</div><div class="line">        username    &lt;- map[&quot;username&quot;]</div><div class="line">        age         &lt;- map[&quot;age&quot;]</div><div class="line">        weight      &lt;- map[&quot;weight&quot;]</div><div class="line">        array       &lt;- map[&quot;arr&quot;]</div><div class="line">        dictionary  &lt;- map[&quot;dict&quot;]</div><div class="line">        bestFriend  &lt;- map[&quot;best_friend&quot;]</div><div class="line">        friends     &lt;- map[&quot;friends&quot;]</div><div class="line">        birthday    &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> //结构体的话也是执行相应的操作</div><div class="line">struct Temperature: Mappable &#123;</div><div class="line">    var celsius: Double?</div><div class="line">    var fahrenheit: Double?</div><div class="line">    </div><div class="line">    init?(_ map: Map) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mutating func mapping(map: Map) &#123;</div><div class="line">        celsius     &lt;- map[&quot;celsius&quot;]</div><div class="line">        fahrenheit  &lt;- map[&quot;fahrenheit&quot;]</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唔,一旦你的类接口定义了Mappable,那么你这个类就可以调用简答的方法进行字典转模型的转换啦.</p>
<p>转换一个JSON成相应的类模型:</p>
<pre><code>let user = User(JSONSting:jsonString)
</code></pre><p>转换一个模型成相应的字符串:</p>
<pre><code>let jsonString = user.toJSONString(prettyPrint:true)
</code></pre><p>除了这种转换方式,Mapper.swfit类还提供了扩展的方法也可以进行同样的转换:</p>
<pre><code> // 字典转模型
let user = Mapper&lt;User&gt;().map(JSONString: JSONString)
//字典转模型
let JSONString = Mapper().toJSONString(user, prettyPrint: true)
</code></pre><p>ObjectMapper支持以下的数据类型</p>
<ul>
<li>Int</li>
<li>Bool</li>
<li>Double</li>
<li>Float</li>
<li>String</li>
<li>RawRepresentable(Enums)</li>
<li>Array<anyobject></anyobject></li>
<li>Dictionary<string, anyobject=""></string,></li>
<li>Object<t: mappable=""></t:></li>
<li>Array<t: mappable=""></t:></li>
<li>Array<array<t: mappable="">&gt;</array<t:></li>
<li>Set<t: mappable=""></t:></li>
<li>Dictionary<string, t:="" mappable=""></string,></li>
<li>Dictionary<string, array<t:="" mappable="">&gt;</string,></li>
<li>Optionals of all the above</li>
</ul>
<h3 id="Mappable-Protocol"><a href="#Mappable-Protocol" class="headerlink" title="Mappable Protocol"></a>Mappable Protocol</h3><p><strong><em>mutating func mapping(map: Map)</em></strong><br>这个函数里面定义了映射所需要指向的字符串,当解析JSON的过程中,创建好实例对象以后会去执行这个函数,当生成JSON的过程中,这个函数是唯一一个可以被叫做对象.</p>
<h3 id="init-map-Map"><a href="#init-map-Map" class="headerlink" title="init?(_ map: Map)"></a>init?(_ map: Map)</h3><p>//翻译未完成,待续…其实ObjectMapper的使用非常简单,只要字符串和相对应的Object一一对应即可…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/23/关联对象存放自定义数据/" itemprop="url">
                  关联对象存放自定义数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-23T23:23:04+08:00" content="2016-05-23">
              2016-05-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关联对象存放自定义数据"><a href="#关联对象存放自定义数据" class="headerlink" title="关联对象存放自定义数据"></a>关联对象存放自定义数据</h3><h4 id="关于objc-setAssociatedObject和objc-getAssociatedObject"><a href="#关于objc-setAssociatedObject和objc-getAssociatedObject" class="headerlink" title="关于objc_setAssociatedObject和objc_getAssociatedObject"></a>关于objc_setAssociatedObject和objc_getAssociatedObject</h4><p>最近是在52个提高IOS高质量代码中看到这个特性的.<br>在我写代码的过程中,我感觉这种方式可以提供代理中的高聚合(和RAC的函数式编程有异曲同工之妙)<br>先把代码上上来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)viewDidLoad &#123;</div><div class="line">            [super viewDidLoad];</div><div class="line"></div><div class="line">                UIAlertView* alert =  [[UIAlertView alloc] initWithTitle:@&quot;信息&quot; message:@&quot;提示&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确认&quot;, nil];</div><div class="line">    </div><div class="line">                void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;</div><div class="line">                    if (buttonIndex == 0) &#123;</div><div class="line">                        NSLog(@&quot;取消按钮&quot;);</div><div class="line">                    &#125;else if (buttonIndex == 1)&#123;</div><div class="line">                        NSLog(@&quot;确认按钮&quot;);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;;</div><div class="line">    </div><div class="line">                objc_setAssociatedObject(alert, ALERTVIEWKEY, block,             OBJC_ASSOCIATION_COPY);</div><div class="line">            //</div><div class="line">            //    NSString* str = @&quot;存储自定义数据&quot;;</div><div class="line">            //    </div><div class="line">            //    objc_setAssociatedObject(alert, ALERTVIEWKEY, str,             OBJC_ASSOCIATION_COPY);</div><div class="line">                [alert show];</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>在实现代理中,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#pragma alertDelegate</div><div class="line"> -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:   (NSInteger)buttonIndex&#123;</div><div class="line">    </div><div class="line">    void(^block)(NSInteger) = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">    block(buttonIndex);</div><div class="line">     //    NSString* str = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">     //    NSLog(@&quot;%@&quot;,str);</div><div class="line">    </div><div class="line">    NSLog(@&quot;%ld&quot;,(long)buttonIndex);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>我们所得到的效果是可以在上面viewDidload代码中直接执行了按钮的响应.<br>点击不同的按钮作出相应的动作.</p>
<h3 id="实际上-在set方法中"><a href="#实际上-在set方法中" class="headerlink" title="实际上,在set方法中:"></a>实际上,在set方法中:</h3><pre><code>objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)
</code></pre><p>方法中,我们可以在id value传入任意参数,字符串(如注释代码中str的传递),数组,字典等,当然,例子中传递匿名函数就是较为灵活的用法.</p>
<ul>
<li>第一个参数 &lt;#id object#&gt;传入对象</li>
<li>第二个参数 &lt;#const void *key#&gt;为一个key,一般格式为 <pre><code>static void * NAME = &quot;NAME&quot;;
</code></pre></li>
<li>第三个参数 需要传递的对象,如匿名函数,字符串,数组等对象.(一般考虑传递信息,自定义数据,灵活的非常大)</li>
<li>第四个参数 定义的是objc_AssociationPolicy枚举,根据第三个参数来决定这个参数的@property到底是assign,还是nonatomic,retain,还是nonatomic,copy,还是retain,或者的单纯的copy.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">                                            *   The association is made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">                                            *   The association is made atomically. */</div></pre></td></tr></table></figure>
<h4 id="而代理中调用runtime的get方法"><a href="#而代理中调用runtime的get方法" class="headerlink" title="而代理中调用runtime的get方法:"></a>而代理中调用runtime的get方法:</h4><p>objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;</p>
<ul>
<li>&lt;#id object#&gt;放入对象(代理或者通过其他方式(如属性,指针)放入存储了自定义数据的对象</li>
<li>&lt;#const void *key#&gt;为记录了当初存储该自定义数据的键值</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>其实这种方法并不推荐大家经常使用,因为滥用的话容易导致代码失控,难于调试.</p>
<ul>
<li>可以通过”关联对象”机制把两个对象连接起来</li>
<li>定义关联对象时可以指定内存管理语义,用以模仿定义属性时采用的”拥有关系”和”非拥有关系”</li>
<li>只有在其他做法不可行才应选择关联对象,因为这种做法通常会引入难于查找的bug</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/iOS-架构模式-–-简述-MVC-MVP-MVVM-和-VIPER-转/" itemprop="url">
                  iOS 架构模式 – 简述 MVC, MVP, MVVM 和 VIPER (转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T23:23:20+08:00" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用 iOS 的 MVC 时候感觉怪怪的？想要尝试下 MVVM？之前听说过 VIPER，但是又纠结是不是值得去学？</p>
<p>继续阅读，你就会知道上面问题的答案 – 如果读完了还是不知道的话，欢迎留言评论。</p>
<p>iOS 上面的架构模式你可能之前就了解过一些，接下来我们会帮你把它们进行一下梳理。我们先简要回顾一下目前比较主流的架构模式，分析比较一些他们的原理，并用一些小栗子来进行练习。如果你对其中的某一种比较感兴趣的话，我们也在文章里面给出了对应的链接。</p>
<p>对于设计模式的学习是一件容易上瘾的事情，所以先提醒你一下：在你读完这篇文章之后，可能会比读之前有更多的疑问，比如：</p>
<ul>
<li><p>(MVC）谁来负责网络请求：是 Model 还是 Controller？</p>
</li>
<li><p>(MVVM）我该怎么去把一个 Model 传递给一个新创建的 View 的 ViewModel？</p>
</li>
<li><p>(VIPER）谁来负责创建 VIPER 模块：是 Router 还是 Presenter？</p>
</li>
</ul>
<h3 id="1-为何要在意架构的选择呢？"><a href="#1-为何要在意架构的选择呢？" class="headerlink" title="1. 为何要在意架构的选择呢？"></a>1. 为何要在意架构的选择呢？</h3><p>   因为如果你不在意的话，难保一天，你就需要去调试一个巨大无比又有着各种问题的类，然后你会发现在这个类里面，你完全就找不到也修复不了任何 bug。一般来说，把这么大的一个类作为整体放在脑子里记着是一件非常困难的事情，你总是难免会忘掉一些比较重要的细节。如果你发现在你的应用里面已经开始出现这种状况了，那你很可能遇到过下面这类问题：</p>
<ul>
<li>这个类是一个 UIViewController 的子类。</li>
<li>你的数据直接保存在了 UIViewController 里面。</li>
<li>你的 UIViews 好像什么都没做。</li>
<li>你的 Model 只是一个纯粹的数据结构</li>
<li>你的单元测试什么都没有覆盖到</li>
</ul>
<p>其实即便你遵循了 Apple 的设计规范，实现了 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">Apple 的 MVC 框架</a>，也还是一样会遇到上面这些问题；所以也没什么好失落的。<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">Apple 的 MVC 框架</a> 有它自身的缺陷，不过这个我们后面再说。</p>
<p>让我们先来定义一下好的框架应该具有的特征：</p>
<ol>
<li>用严格定义的角色，平衡的将职责 划分 给不同的实体。</li>
<li>可测性 通常取决于上面说的第一点（不用太担心，如果架构何时的话，做到这点并不难）。</li>
<li>易用 并且维护成本低。</li>
</ol>
<h5 id="1-1为什么要划分？"><a href="#1-1为什么要划分？" class="headerlink" title="1.1为什么要划分？"></a>1.1为什么要划分？</h5><p>   当我们试图去理解事物的工作原理的时候，划分可以减轻我们的脑部压力。如果你觉得开发的越多，大脑就越能适应去处理复杂的工作，确实是这样。但是大脑的这种能力不是线性提高的，而且很快就会达到一个瓶颈。所以要处理复杂的事情，最好的办法还是在遵循 单一责任原则 的条件下，将它的职责划分到多个实体中去。</p>
<h5 id="1-2-为什么要可测性？"><a href="#1-2-为什么要可测性？" class="headerlink" title="1.2 为什么要可测性？"></a>1.2 为什么要可测性？</h5><p>   对于那些对单元测试心存感激的人来说，应该不会有这方面的疑问：单元测试帮助他们测试出了新功能里面的错误，或者是帮他们找出了重构的一个复杂类里面的 bug。这意味着这些单元测试帮助这些开发者们在程序运行之前就发现了问题，这些问题如果被忽视的话很可能会提交到用户的设备上去；而修复这些问题，又至少需要一周左右的时间（AppStore 审核）。</p>
<h5 id="1-3-为什么要易用"><a href="#1-3-为什么要易用" class="headerlink" title="1.3 为什么要易用"></a>1.3 为什么要易用</h5><p>   这块没什么好说的，直说一点：最好的代码是那些从未被写出来的代码。代码写的越少，问题就越少；所以开发者想少写点代码并不一定就是因为他懒。还有，当你想用一个比较 聪明 的方法的时候，全完不要忽略了它的维护成本。</p>
<h3 id="2-MV-X-的基本要素"><a href="#2-MV-X-的基本要素" class="headerlink" title="2.MV(X) 的基本要素"></a>2.MV(X) 的基本要素</h3><p>现在我们面对架构设计模式的时候有了很多选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* MCV</div><div class="line">* MVP</div><div class="line">* MVVM</div><div class="line">* VIPER</div></pre></td></tr></table></figure>
<p>首先前三种模式都是把所有的实体归类到了下面三种分类中的一种：</p>
<ul>
<li><strong>Models（模型)</strong> — 数据层，或者负责处理数据的 <a href="https://en.wikipedia.org/wiki/Data_access_layer" target="_blank" rel="external">数据接口层</a>。比如 Person 和 PersonDataProvider 类</li>
<li><strong>Views（视图）</strong> – 展示层(GUI)。对于 iOS 来说所有以 UI 开头的类基本都属于这层。</li>
<li><strong>Controller/Presenter/ViewModel（控制器/展示器/视图模型）</strong> – 它是 Model 和 View 之间的胶水或者说是中间人。一般来说，当用户对 View 有操作时它负责去修改相应 Model；当 Model 的值发生变化时它负责去更新对应 View。</li>
</ul>
<p>将实体进行分类之后我们可以：</p>
<ul>
<li>更好的理解</li>
<li>重用（主要是 View 和 Model）</li>
<li>对它们独立的进行测试</li>
</ul>
<h4 id="3-让我从-MV-X-系列开始讲起，最后讲-VIPER。"><a href="#3-让我从-MV-X-系列开始讲起，最后讲-VIPER。" class="headerlink" title="3. 让我从 MV(X) 系列开始讲起，最后讲 VIPER。"></a>3. 让我从 MV(X) 系列开始讲起，最后讲 VIPER。</h4><p>在开始讨论 Apple 的 MVC 之前，我们先来看下 传统的 MVC。</p>
<p>在这种架构下，View 是无状态的，在 Model 变化的时候它只是简单的被 Controller 重绘；就像网页一样，点击了一个新的链接，整个网页就重新加载。尽管这种架构可以在 iOS 应用里面实现，但是由于 MVC 的三种实体被紧密耦合着，每一种实体都和其他两种有着联系，所以即便是实现了也没有什么意义。这种紧耦合还戏剧性的减少了它们被重用的可能，这恐怕不是你想要在自己的应用里面看到的。<strong>综上，传统 MVC 的例子我觉得也没有必要去写了。</strong></p>
<h4 id="4-Apple-的-MVC"><a href="#4-Apple-的-MVC" class="headerlink" title="4.Apple 的 MVC"></a>4.Apple 的 MVC</h4><p><strong>4.1 理想</strong></p>
<p>View 和 Model 之间是相互独立的，它们只通过 Controller 来相互联系。有点恼人的是 Controller 是重用性最差的，因为我们一般不会把冗杂的业务逻辑放在 Model 里面，那就只能放在 Controller 里了。</p>
<p>理论上看这么做貌似挺简单的，但是你有没有觉得有点不对劲？你甚至听过有人把 MVC 叫做重控制器模式。另外 关于 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="external">ViewController 瘦身</a> 已经成为 iOS 开发者们热议的话题了。为什么 Apple 要沿用只是做了一点点改进的传统 MVC 架构呢？</p>
<p><strong>4.2.现实</strong></p>
<p>Cocoa MVC 鼓励你去写重控制器是因为 View 的整个生命周期都需要它去管理，Controller 和 View 很难做到相互独立。虽然你可以把控制器里的一些业务逻辑和数据转换的工作交给 Model，但是你再想把负担往 View 里面分摊的时候就没办法了；因为 View 的主要职责就只是讲用户的操作行为交给 Controller 去处理而已。于是 ViewController 最终就变成了所有东西的代理和数据源，甚至还负责网络请求的发起和取消，还有…剩下的你来讲。</p>
<p>像下面这种代码你应该不陌生吧：</p>
<pre><code>var userCell = tableView.dequeueReusableCellWithIdentifier(&quot;identifier&quot;) vas UserCell
userCell.configureWithUser(user)
</code></pre><p>   Cell 作为一个 View 直接用 Model 来完成了自身的配置，MVC 的原则被打破了，这种情况一直存在，而且还没人觉得有什么问题。如果你是严格遵循 MVC 的话，你应该是在 ViewController 里面去配置 Cell，而不是直接将 Model 丢给 Cell，当然这样会让你的 ViewController 更重。</p>
<p>   <strong>Cocoa MVC 被戏称为重控制器模式还是有原因的。</strong> </p>
<p>问题直到开始<a href="http://nshipster.com/unit-testing/" target="_blank" rel="external"> 单元测试</a>（希望你的项目里面已经有了）之后才开始显现出来。Controller 测试起来很困难，因为它和 View 耦合的太厉害，要测试它的话就需要频繁的去 mock View 和 View 的生命周期；而且按照这种架构去写控制器代码的话，业务逻辑的代码也会因为视图布局代码的原因而变得很散乱。  </p>
<p>综上所述，Cocoa MVC 貌似并不是一个很好的选择。但是我们还是评估一下他在各方面的表现（在文章开头有讲）：</p>
<ul>
<li><strong>划分</strong> – View 和 Model 确实是实现了分离，但是 View 和 Controller 耦合的太厉害</li>
<li><strong>可测性</strong> – 因为划分的不够清楚，所以能测的基本就只有 Model 而已</li>
<li><strong>易用</strong> – 相较于其他模式，它的代码量最少。而且基本上每个人都很熟悉它，即便是没太多经验的开发者也能维护。</li>
</ul>
<p>在这种情况下你可以选择 Cocoa MVC：你并不想在架构上花费太多的时间，而且你觉得对于你的小项目来说，花费更高的维护成本只是浪费而已。</p>
<p><strong>如果你最看重的是开发速度，那么 Cocoa MVC 就是你最好的选择。</strong></p>
<h4 id="5-MVP-–-保证了职责划分的（promises-delivered）-Cocoa-MVC"><a href="#5-MVP-–-保证了职责划分的（promises-delivered）-Cocoa-MVC" class="headerlink" title="5.MVP – 保证了职责划分的（promises delivered） Cocoa MVC"></a>5.MVP – 保证了职责划分的（promises delivered） Cocoa MVC</h4><p>看起来确实很像 Apple 的 MVC 对吧？确实蛮像，它的名字是 MVP（被动变化的 View）。稍等…这个意思是说 Apple 的 MVC 实际上是 MVP 吗？不是的，回想一下，在 MVC 里面 View 和 Controller 是耦合紧密的，但是对于 MVP 里面的 Presenter 来讲，它完全不关注 ViewController 的生命周期，而且 View 也能被简单 mock 出来，所以在 Presenter 里面基本没什么布局相关的代码，它的职责只是通过数据和状态更新 View。</p>
<p><strong>如果我跟你讲 UIViewController 在这里的角色其实是 View 你感觉如何。</strong></p>
<p>在 MVP 架构里面，UIViewController 的那些子类其实是属于 View 的，而不是 Presenter。这种区别提供了极好的可测性，但是这是用开发速度的代价换来的，因为你必须要手动的去创建数据和绑定事件，像下面这段代码中做的一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Model</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingView: class &#123;</div><div class="line">    func setGreeting(greeting: String)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewPresenter &#123;</div><div class="line">    init(view: GreetingView, person: Person)</div><div class="line">    func showGreeting()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingPresenter : GreetingViewPresenter &#123;</div><div class="line">    unowned let view: GreetingView</div><div class="line">    let person: Person</div><div class="line">    required init(view: GreetingView, person: Person) &#123;</div><div class="line">        self.view = view</div><div class="line">        self.person = person</div><div class="line">    &#125;</div><div class="line">    func showGreeting() &#123;</div><div class="line">        let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</div><div class="line">        self.view.setGreeting(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController, GreetingView &#123;</div><div class="line">    var presenter: GreetingViewPresenter!</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func didTapButton(button: UIButton) &#123;</div><div class="line">        self.presenter.showGreeting()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func setGreeting(greeting: String) &#123;</div><div class="line">        self.greetingLabel.text = greeting</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of MVP</div><div class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</div><div class="line">let view = GreetingViewController()</div><div class="line">let presenter = GreetingPresenter(view: view, person: model)</div><div class="line">view.presenter = presenter</div></pre></td></tr></table></figure>
<p><strong>5.1.关于组装方面的重要说明</strong></p>
<p>MVP 架构拥有三个真正独立的分层，所以在组装的时候会有一些问题，而 MVP 也成了第一个披露了这种问题的架构。因为我们不想让 View 知道 Model 的信息，所以在当前的 ViewController（角色其实是 View）里面去进行组装肯定是不正确的，我们应该在另外的地方完成组装。比如，我们可以创建一个应用层（app-wide）的 Router 服务，让它来负责组装和 View-to-View 的转场。这个问题不仅在 MVP 中存在，在接下来要介绍的模式里面也都有这个问题。</p>
<p>让我们来看一下 MVP 在各方面的表现：</p>
<ul>
<li><strong>划分</strong> – 我们把大部分的职责都分配到了 Presenter 和 Model 里面，而 View 基本上不需要做什么（在上面的例子里面，Model 也什么都没做）。</li>
<li><strong>可测性</strong> – 简直棒，我们可以通过 View 来测试大部分的业务逻辑。</li>
<li><strong>易用</strong> – 就我们上面那个简单的例子来讲，代码量差不多是 MVC 架构的两倍，但是 MVP 的思路还是蛮清晰的。<br><strong>MVP 架构在 iOS 中意味着极好的可测性和巨大的代码量。</strong></li>
</ul>
<h4 id="6-MVP-–-添加了数据绑定的另一个版本"><a href="#6-MVP-–-添加了数据绑定的另一个版本" class="headerlink" title="6.MVP – 添加了数据绑定的另一个版本"></a>6.MVP – 添加了数据绑定的另一个版本</h4><p>还存在着另一种的 MVP – Supervising Controller MVP。这个版本的 MVP 包括了 View 和 Model 的直接绑定，与此同时 Presenter（Supervising Controller）仍然继续处理 View 上的用户操作，控制 View 的显示变化。</p>
<p>但是我们之前讲过，模糊的职责划分是不好的事情，比如 View 和 Model 的紧耦合。这个道理在 Cocoa 桌面应用开发上面也是一样的。</p>
<p>就像传统 MVC 架构一样，我找不到有什么理由需要为这个有瑕疵的架构写一个例子</p>
<h4 id="7-MVVM-–-是-MV-X-系列架构里面最新兴的，也是最出色的"><a href="#7-MVVM-–-是-MV-X-系列架构里面最新兴的，也是最出色的" class="headerlink" title="7.MVVM – 是 MV(X) 系列架构里面最新兴的，也是最出色的"></a>7.MVVM – 是 MV(X) 系列架构里面最新兴的，也是最出色的</h4><p>MVVM 架构是 MV(X) 里面最新的一个，让我们希望它在出现的时候已经考虑到了 MV(X) 模式之前所遇到的问题吧。</p>
<p>理论上来说，Model – View – ViewModel 看起来非常棒。View 和 Model 我们已经都熟悉了，中间人的角色我们也熟悉了，但是在这里中间人的角色变成了 ViewModel。</p>
<p>它跟 MVP 很像：</p>
<ul>
<li>MVVM 架构把 ViewController 看做 View。</li>
<li>View 和 Model 之间没有紧耦合</li>
</ul>
<p>另外，它还像 Supervising 版的 MVP 那样做了数据绑定，不过这次不是绑定 View 和 Model，而是绑定 View 和 ViewModel。</p>
<p>那么，iOS 里面的 ViewModel 到底是个什么东西呢？本质上来讲，他是独立于 UIKit 的， View 和 View 的状态的一个呈现（representation）。ViewModel 能主动调用对 Model 做更改，也能在 Model 更新的时候对自身进行调整，然后通过 View 和 ViewModel 之间的绑定，对 View 也进行对应的更新。</p>
<p><strong>7.1.绑定</strong></p>
<p>我在 MVP 的部分简单的提过这个内容，在这里让我们再延伸讨论一下。绑定这个概念源于 OS X 平台的开发，但是在 iOS 平台上面，我们并没有对应的开发工具。当然，我们也有 KVO 和 通知，但是用这些方式去做绑定不太方便。</p>
<p>那么，如果我们不想自己去写他们的话，下面提供了两个选择：</p>
<ul>
<li>选一个基于 KVO 的绑定库，比如 RZDataBinding 或者 SwiftBond。</li>
<li>使用全量级的 函数式响应编程 框架,比如 ReactiveCocoa、RxSwift 或者 PromiseKit。</li>
</ul>
<p>实际上，现在提到「MVVM」你应该就会想到 ReactiveCocoa，反过来也是一样。虽然我们可以通过简单的绑定来实现 MVVM 模式，但是 ReactiveCocoa（或者同类型的框架）会让你更大限度的去理解 MVVM。</p>
<p>响应式编程框架也有一点不好的地方，能力越大责任越大嘛。用响应式编程用得不好的话，很容易会把事情搞得一团糟。或者这么说，如果有什么地方出错了，你需要花费更多的时间去调试。</p>
<p>在接下来的这个小例子中，用响应式框架（FRF）或者 KVO 都显得有点大刀小用，所以我们用另一种方式：直接的调用 ViewModel 的 showGreeting 方法去更新自己（的 greeting 属性），（在 greeting 属性的 didSet 回调里面）用 greetingDidChange 闭包函数去更新 View 的显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Model</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewModelProtocol: class &#123;</div><div class="line">    var greeting: String? &#123; get &#125;</div><div class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; // function to call when greeting did change</div><div class="line">    init(person: Person)</div><div class="line">    func showGreeting()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewModel : GreetingViewModelProtocol &#123;</div><div class="line">    let person: Person</div><div class="line">    var greeting: String? &#123;</div><div class="line">        didSet &#123;</div><div class="line">            self.greetingDidChange?(self)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</div><div class="line">    required init(person: Person) &#123;</div><div class="line">        self.person = person</div><div class="line">    &#125;</div><div class="line">    func showGreeting() &#123;</div><div class="line">        self.greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController &#123;</div><div class="line">    var viewModel: GreetingViewModelProtocol! &#123;</div><div class="line">        didSet &#123;</div><div class="line">            self.viewModel.greetingDidChange = &#123; [unowned self] viewModel in</div><div class="line">                self.greetingLabel.text = viewModel.greeting</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self.viewModel, action: &quot;showGreeting&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of MVVM</div><div class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</div><div class="line">let viewModel = GreetingViewModel(person: model)</div><div class="line">let view = GreetingViewController()</div><div class="line">view.viewModel = viewModel</div></pre></td></tr></table></figure>
<p>然后，我们再回过头来对它各方面的表现做一个评价：</p>
<ul>
<li><strong>划分</strong> – 这在我们的小栗子里面表现的不是很清楚，但是 MVVM 框架里面的 View 比 MVP 里面负责的事情要更多一些。因为前者是通过 ViewModel 的数据绑定来更新自身状态的，而后者只是把所有的事件统统交给 Presenter 去处理就完了，自己本身并不负责更新。</li>
<li><strong>可测性</strong> – 因为 ViewModel 对 View 是一无所知的，这样我们对它的测试就变得很简单。View 应该也是能够被测试的，但是可能因为它对 UIKit 的依赖，你会直接略过它。</li>
<li><strong>易用</strong> – 在我们的例子里面，它的代码量基本跟 MVP 持平，但是在实际的应用当中 MVVM 会更简洁一些。因为在 MVP 下你必须要把 View 的所有事件都交给 Presenter 去处理，而且需要手动的去更新 View 的状态；而在 MVVM 下，你只需要用绑定就可以解决。</li>
</ul>
<p><strong>MVVM 真的很有魅力，因为它不仅结合了上述几种框架的优点，还不需要你为视图的更新去写额外的代码（因为在 View 上已经做了数据绑定），另外它在可测性上的表现也依然很棒。</strong></p>
<h4 id="8-VIPER-–-把搭建乐高积木的经验应用到-iOS-应用的设计上"><a href="#8-VIPER-–-把搭建乐高积木的经验应用到-iOS-应用的设计上" class="headerlink" title="8.VIPER – 把搭建乐高积木的经验应用到 iOS 应用的设计上"></a>8.VIPER – 把搭建乐高积木的经验应用到 iOS 应用的设计上</h4><p>VIPER 是我们最后一个要介绍的框架，这个框架比较有趣的是它不属于任何一种 MV(X) 框架。</p>
<p>到目前为止，你可能觉得我们把职责划分成三层，这个颗粒度已经很不错了吧。现在 VIPER 从另一个角度对职责进行了划分，这次划分了 五层。</p>
<ul>
<li><strong>Interactor（交互器）</strong> – 包括数据（Entities）或者网络相关的业务逻辑。比如创建新的 entities 或者从服务器上获取数据；要实现这些功能，你可能会用到一些服务和管理（Services and Managers）：这些可能会被误以为成是外部依赖东西，但是它们就是 VIPER 的 Interactor 模块。</li>
<li><strong>Presenter（展示器）</strong> – 包括 UI（but UIKit independent）相关的业务逻辑，可以调用 Interactor 中的方法。</li>
<li><strong>Entities（实体）</strong> – 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。</li>
<li><strong>Router（路由）</strong> – 负责 VIPER 模块之间的转场</li>
</ul>
<p>实际上 VIPER 模块可以只是一个页面（screen），也可以是你应用里整个的用户使用流程（the whole user story）- 比如说「验证」这个功能，它可以只是一个页面，也可以是连续相关的一组页面。你的每个「乐高积木」想要有多大，都是你自己来决定的。</p>
<p>如果我们把 VIPER 和 MV(X) 系列做一个对比的话，我们会发现它们在职责划分上面有下面的一些区别：</p>
<ul>
<li>Model（数据交互）的逻辑被转移到了 Interactor 里面，Entities 只是一个什么都不用做的数据结构体。</li>
<li>Controller/Presenter/ViewModel 的职责里面，只有 UI 的展示功能被转移到了 Presenter 里面。Presenter 不具备直接更改数据的能力。</li>
<li>VIPER 是第一个把导航的职责单独划分出来的架构模式，负责导航的就是 Router 层。</li>
</ul>
<p><strong>如何正确的使用导航（doing routing）对于 iOS 应用开发来说是一个挑战，MV(X) 系列的架构完全就没有意识到（所以也不用处理）这个问题。
</strong></p>
<p>下面的这个列子并没有涉及到导航和 VIPER 模块间的转场，同样上面 MV(X) 系列架构里面也都没有涉及。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Entity (usually more complex e.g. NSManagedObject)</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">struct GreetingData &#123; // Transport data structure (not Entity)</div><div class="line">    let greeting: String</div><div class="line">    let subject: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingProvider &#123;</div><div class="line">    func provideGreetingData()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingOutput: class &#123;</div><div class="line">    func receiveGreetingData(greetingData: GreetingData)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingInteractor : GreetingProvider &#123;</div><div class="line">    weak var output: GreetingOutput!</div><div class="line"> </div><div class="line">    func provideGreetingData() &#123;</div><div class="line">        let person = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;) // usually comes from data access layer</div><div class="line">        let subject = person.firstName + &quot; &quot; + person.lastName</div><div class="line">        let greeting = GreetingData(greeting: &quot;Hello&quot;, subject: subject)</div><div class="line">        self.output.receiveGreetingData(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewEventHandler &#123;</div><div class="line">    func didTapShowGreetingButton()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingView: class &#123;</div><div class="line">    func setGreeting(greeting: String)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</div><div class="line">    weak var view: GreetingView!</div><div class="line">    var greetingProvider: GreetingProvider!</div><div class="line"> </div><div class="line">    func didTapShowGreetingButton() &#123;</div><div class="line">        self.greetingProvider.provideGreetingData()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</div><div class="line">        let greeting = greetingData.greeting + &quot; &quot; + greetingData.subject</div><div class="line">        self.view.setGreeting(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController, GreetingView &#123;</div><div class="line">    var eventHandler: GreetingViewEventHandler!</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func didTapButton(button: UIButton) &#123;</div><div class="line">        self.eventHandler.didTapShowGreetingButton()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func setGreeting(greeting: String) &#123;</div><div class="line">        self.greetingLabel.text = greeting</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of VIPER module, without Router</div><div class="line">let view = GreetingViewController()</div><div class="line">let presenter = GreetingPresenter()</div><div class="line">let interactor = GreetingInteractor()</div><div class="line">view.eventHandler = presenter</div><div class="line">presenter.view = view</div><div class="line">presenter.greetingProvider = interactor</div><div class="line">interactor.output = presenter</div></pre></td></tr></table></figure>
<p>我们再来评价下它在各方面的表现：</p>
<ul>
<li><strong>划分</strong> – 毫无疑问的，VIPER 在职责划分方面是做的最好的。</li>
<li><strong>可测性</strong> – 理所当然的，职责划分的越好，测试起来就越容易</li>
<li><strong>易用</strong> – 最后，你可能已经猜到了，上面两点好处都是用维护性的代价换来的。一个小小的任务，可能就需要你为各种类写大量的接口。</li>
</ul>
<h3 id="8-1-那么，我们到底应该给「乐高」一个怎样的评价呢？"><a href="#8-1-那么，我们到底应该给「乐高」一个怎样的评价呢？" class="headerlink" title="8.1.那么，我们到底应该给「乐高」一个怎样的评价呢？"></a>8.1.那么，我们到底应该给「乐高」一个怎样的评价呢？</h3><p>果你在使用 VIPER 框架的时候有一种在用乐高积木搭建帝国大厦的感觉，那么你可能 正在犯错误；可能对于你负责的应用来说，还没有到使用 VIPER 的时候，你应该把一些事情考虑的再简单一些。总是有一些人忽视这个问题，继续扛着大炮去打小鸟。我觉得可能是因为他们相信，虽然目前来看维护成本高的不合常理，但是至少在将来他们的应用可以从 VIPER 架构上得到回报吧。如果你也跟他们的观点一样的话，那我建议你尝试一下 Generamba – 一个可以生成 VIPER 框架的工具。虽然对于我个人来讲，这感觉就像给大炮装上了一个自动瞄准系统，然后去做一件只用弹弓就能解决的事情。</p>
<h4 id="9-结论"><a href="#9-结论" class="headerlink" title="9.结论"></a>9.结论</h4><p>我们简单了解了几种架构模式，对于那些让你困惑的问题，我希望你已经找到了答案。但是毫无疑问，你应该已经意识到了，在选择架构模式这件问题上面，不存在什么 银色子弹，你需要做的就是具体情况具体分析，权衡利弊而已。</p>
<p>因此在同一个应用里面，即便有几种混合的架构模式也是很正常的一件事情。比如：开始的时候，你用的是 MVC 架构，后来你意识到有一个特殊的页面用 MVC 做的的话维护起来会相当的麻烦；这个时候你可以只针对这一个页面用 MVVM 模式去开发，对于之前那些用 MVC 就能正常工作的页面，你完全没有必要去重构它们，因为两种架构是完全可以和睦共存的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/哪部电影曾经让你在深夜中痛哭？/" itemprop="url">
                  哪部电影曾经让你在深夜中痛哭？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-19T17:52:04+08:00" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>点击<a href="https://www.zhihu.com/question/37206525/answer/72868899" target="_blank" rel="external">《爆裂鼓手》</a>查看原文</p>
<p>   <strong>在知乎上看到这个答案非常喜欢,所以保存了下来,曾经我也以为我是很喜欢写代码的,但是看过这片文章以后才发现直接并不是那么的热爱–曾经看过一个视频问,你渴望成功?渴望的程度会想被泡在水里想要呼吸的欲望吗?</strong></p>
<p>   <strong>我问了自己很久,其实我也并没有那么热爱,起码不能说像呼吸那么热爱.说真的就是会觉得编程的世界很广阔,可以让我学习到很多不同的知识和认识很多很厉害的人.正是因为认识了他们,所以我才会明白自己的不足.</strong></p>
<p>   <strong>然后对于生活的抉择,我也在迷茫,我也不知道要往哪里走,只是希望一切能顺顺利利的.说到身在福中不知福,突然就想到小时候没有好好的享受童年,现在等到有很大工作压力的时候才来后悔啊啊,以后一定让自己的孩子好好学习,不要浪费有趣的童年.</strong></p>
<p>   <strong>我本来是有很多奇奇怪怪的话要说的,但是刚刚打了一篇文章,放在了日记里面,现在不那么想说了,一份日记承载了我所以的心情,点点滴滴.回顾起来,突然想问自己,什么才叫成功,什么才叫幸福呢?我们之所以努力,不是为了过上更好的日子吗?</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/05/iOS中模拟发送http请求以及解析xml/" itemprop="url">
                  iOS中模拟发送http请求以及解析xml
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-05T13:32:33+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AFNetWorking请求"><a href="#AFNetWorking请求" class="headerlink" title="AFNetWorking请求"></a>AFNetWorking请求</h3><p>这个不难,导入AFN框架,生成一个单例类,特别要注意的是,如果作为模拟请求http请求的话,返回的并不是json数据.</p>
<h4 id="1-单例代码如下"><a href="#1-单例代码如下" class="headerlink" title="1.单例代码如下"></a>1.单例代码如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class NetworkTools: AFHTTPSessionManager &#123;</div><div class="line"></div><div class="line">		//设置单例</div><div class="line">    static let tools: NetworkTools = &#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        let tool = NetworkTools()</div><div class="line">        </div><div class="line">        //设置类型</div><div class="line">        tool.responseSerializer.acceptableContentTypes =  NSSet(objects: &quot;application/json&quot;, &quot;text/html&quot;,&quot;text/json&quot;, &quot;text/javascript&quot;, &quot;text/plain&quot;,&quot;image/png&quot;) as? Set&lt;String&gt;</div><div class="line"></div><div class="line">        tool.responseSerializer = AFHTTPResponseSerializer()</div><div class="line">        </div><div class="line">        return tool</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    //获取单例</div><div class="line">    class func shareNetworkTools() -&gt;NetworkTools&#123;</div><div class="line">        return tools</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2.发送请求"></a>2.发送请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var param = [String:String]()</div><div class="line">      </div><div class="line"></div><div class="line">      NetworkTools.shareNetworkTools().post(&quot;https://www.baidu.com&quot;, parameters: param, progress: nil, success:&#123;(URLSessionDataTask, data)in</div><div class="line">          </div><div class="line">          let jsonStr = String.init(data: data as! Data, encoding: .utf8)!</div><div class="line">          </div><div class="line">          print(jsonStr)</div><div class="line">          </div><div class="line">      &#125;, failure:&#123;(URLSessionDataTask, error) in</div><div class="line">          </div><div class="line">          print(error)</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>好了,在这里我们已经可以获得含有dom字节的字符串吧,保佑解析不要出错吧,这里就不作网络请求了,直接加载本地数据(为了方便查看,这里直接解析html吧):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;p&gt;测试节点&lt;/p&gt;</div><div class="line">    &lt;h1&gt;nnnnnn&lt;/h1&gt;</div><div class="line">    &lt;table&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &lt;li&gt;abc1&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc2&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc3&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc4&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc5&lt;/li&gt;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    &lt;/table&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="GDataXMLNode解析XML"><a href="#GDataXMLNode解析XML" class="headerlink" title="GDataXMLNode解析XML"></a>GDataXMLNode解析XML</h3><h4 id="一-使用GDataXMLNode解析-必须导入文件和框架"><a href="#一-使用GDataXMLNode解析-必须导入文件和框架" class="headerlink" title="一.使用GDataXMLNode解析,必须导入文件和框架"></a>一.使用GDataXMLNode解析,必须导入文件和框架</h4><p>(OS_导入libxml2.2框架后,找不到<libxml tree.h="">的解决办法)</libxml></p>
<ol>
<li>从网上下载GDataXMLNode.h和GDataXMLNode.m,只有两个文件,下载完成后直接拉入项目中即可.(<strong>此时编译会报错误:找不到libxml tree.h</strong>)</li>
<li>下载完成后需要配置项目中的动态库,选中项目,像工程中添加”libxml2.tbd” (借一下图,感谢<a href="http://my.csdn.net/pilqc2009" target="_blank" rel="external">pilqc2009</a>)<br><img src="http://img.blog.csdn.net/20140822203855390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></li>
</ol>
<p><img src="../../images/1.png" alt=""></p>
<ol>
<li><p>切换到切换到Buiild Settings的tab里，通过搜索,找到“Linking”选项框，在里面的”Other Linker Flags”的debug 和 release 里面点击“+”，添加 “-lxml2”<br><img src="http://img.blog.csdn.net/20140822204223171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>跟步骤2一样，依然在Buiild Settings的tab里，通过搜索，找到 Framework Search ,添加“/usr/lib/libxml2.tbd”；</p>
</li>
<li><img src="http://img.blog.csdn.net/20140822204710075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>跟步骤3一样，依然在Buiild Settings的tab里，通过搜索，在“Header Search Paths” 和 “User Header Search Paths” 里填入$(SDKROOT)/usr/include/libxml2。<br><img src="http://img.blog.csdn.net/20140822205006387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>然后clean项目，就OK，可以使用了。</li>
</ol>
<p>二.导入框架以后,就可以愉快的使用GDataXMLNode来解析文件了,如上面的html结构的文档,使用如下方法进行解析:</p>
<pre><code>override func viewDidLoad() {

    super.viewDidLoad()
    //加载web预览
    let webView = UIWebView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: UIScreen.main.bounds.size.height))
    self.view.addSubview(webView)


    let path = Bundle.main.bundlePath
    //获得基础路径
    let baseURL = NSURL.fileURL(withPath: path)
    //获取文件
    let htmlPath = Bundle.main.path(forResource: &quot;index&quot;, ofType: &quot;html&quot;)!
    //抛出错误
    do{
        //将html文件转换为文本
        let htmlCont = try NSString(contentsOfFile: htmlPath, encoding: String.Encoding.utf8.rawValue)

        //将内容显示
        webView.loadHTMLString(htmlCont as String, baseURL: baseURL)

        print(htmlCont)


        do {
            //解析该文本    
            let doc = try GDataXMLDocument.init(xmlString: htmlCont as String!, options: 0)
            //获取节点
            let root = doc.rootElement();

            print(root!)
        } catch  {
            print(&quot;解析错误&quot;)
        }

    }
    catch{
        print(&quot;URl有误,获取失败失败&quot;)
    }        
    view.backgroundColor = UIColor.red
}
</code></pre><p>打印的结果如下解析完成,喜欢怎么取都可以啦:(或得跟节点)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GDataXMLElement 0x7ff9e3f478b0: &#123;type:1 name:html xml:&quot;&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;测试节点&lt;/p&gt;&lt;h1&gt;nnnnnn&lt;/h1&gt;&lt;table&gt;&lt;ul&gt;&lt;li&gt;abc1&lt;/li&gt;&lt;li&gt;abc2&lt;/li&gt;&lt;li&gt;abc3&lt;/li&gt;&lt;li&gt;abc4&lt;/li&gt;&lt;li&gt;abc5&lt;/li&gt;&lt;/ul&gt;&lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/22/iOS开发：正确使用const-static-extern/" itemprop="url">
                  iOS开发：正确使用const,static,extern
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T16:06:17+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、const与宏的区别-面试题"><a href="#一、const与宏的区别-面试题" class="headerlink" title="一、const与宏的区别(面试题):"></a>一、const与宏的区别(面试题):</h3><p>　　const简介:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</p>
<p>　　编译时刻:宏是预编译(编译之前处理)，const是编译阶段。</p>
<p>　　编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</p>
<p>　　宏的好处:宏能定义一些函数，方法。 const不能。</p>
<p>　　宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。</p>
<p>　　注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">　　// 常见的常量：抽成宏</div><div class="line"></div><div class="line">　　#define XMGAccount @&quot;account&quot;</div><div class="line"></div><div class="line">　　#define XMGUserDefault [NSUserDefaults standardUserDefaults]</div><div class="line"></div><div class="line">　　// 字符串常量</div><div class="line"></div><div class="line">　　static NSString * const account = @&quot;account&quot;;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// 偏好设置存储</div><div class="line"></div><div class="line">　　// 使用宏</div><div class="line"></div><div class="line">　　[XMGUserDefault setValue:@&quot;123&quot; forKey:XMGAccount];</div><div class="line"></div><div class="line">　　// 使用const常量</div><div class="line"></div><div class="line">　　[[NSUserDefaults standardUserDefaults] setValue:@&quot;123&quot; forKey:account];</div><div class="line"></div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h4 id="二、const作用：限制类型"><a href="#二、const作用：限制类型" class="headerlink" title="二、const作用：限制类型"></a>二、const作用：限制类型</h4><p>　　1.const仅仅用来修饰右边的变量(基本数据变量p，指针变量*p)</p>
<p>　　2.被const修饰的变量是只读的。</p>
<p>　　const基本使用
　　
　　
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// 定义变量</div><div class="line"></div><div class="line">　　int a = 1;</div><div class="line"></div><div class="line">　　// 允许修改值</div><div class="line"></div><div class="line">　　a = 20;</div><div class="line"></div><div class="line">　　// const两种用法</div><div class="line"></div><div class="line">　　// const:修饰基本变量p</div><div class="line"></div><div class="line">　　// 这两种写法是一样的，const只修饰右边的基本变量b</div><div class="line"></div><div class="line">　　const int b = 20; // b:只读变量</div><div class="line"></div><div class="line">　　int const b = 20; // b:只读变量</div><div class="line"></div><div class="line">　　// 不允许修改值</div><div class="line"></div><div class="line">　　b = 1;</div><div class="line"></div><div class="line">　　// const:修饰指针变量*p，带*的变量，就是指针变量.</div><div class="line"></div><div class="line">　　// 定义一个指向int类型的指针变量，指向a的地址</div><div class="line"></div><div class="line">　　int *p = &amp;a;</div><div class="line"></div><div class="line">　　int c = 10;</div><div class="line"></div><div class="line">　　p = &amp;c;</div><div class="line"></div><div class="line">　　// 允许修改p指向的地址，</div><div class="line"></div><div class="line">　　// 允许修改p访问内存空间的值</div><div class="line"></div><div class="line">　　*p = 20;</div><div class="line"></div><div class="line">　　// const修饰指针变量访问的内存空间，修饰的是右边*p1，</div><div class="line"></div><div class="line">　　// 两种方式一样</div><div class="line"></div><div class="line">　　const int *p1; // *p1：常量 p1:变量</div><div class="line"></div><div class="line">　　int const *p1; // *p1：常量 p1:变量</div><div class="line"></div><div class="line">　　// const修饰指针变量p1</div><div class="line"></div><div class="line">　　int * const p1; // *p1:变量 p1:常量</div><div class="line"></div><div class="line">　　// 第一个const修饰*p1 第二个const修饰 p1</div><div class="line"></div><div class="line">　　// 两种方式一样</div><div class="line"></div><div class="line">　　const int * const p1; // *p1：常量 p1：常量</div><div class="line"></div><div class="line">　　int const * const p1; // *p1：常量 p1：常量</div><div class="line"></div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h4 id="三、const开发中使用场景"><a href="#三、const开发中使用场景" class="headerlink" title="三、const开发中使用场景:"></a>三、const开发中使用场景:</h4><p>　　1.需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值</p>
<p>　　2.需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。
　　
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　@implementation ViewController</div><div class="line"></div><div class="line">　　// const放*前面约束参数，表示*a只读</div><div class="line"></div><div class="line">　　// 只能修改地址a,不能通过a修改访问的内存空间</div><div class="line"></div><div class="line">　　- (void)test:(const int * )a</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　// *a = 20;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　// const放*后面约束参数，表示a只读</div><div class="line"></div><div class="line">　　// 不能修改a的地址，只能修改a访问的值</div><div class="line"></div><div class="line">　　- (void)test1:(int * const)a</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　int b;</div><div class="line"></div><div class="line">　　// 会报错</div><div class="line"></div><div class="line">　　a = &amp;b;</div><div class="line"></div><div class="line">　　*a = 2;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">　　int a = 10;</div><div class="line"></div><div class="line">　　// 需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值。</div><div class="line"></div><div class="line">　　// 这时候就需要使用const，约束方法的参数只读.</div><div class="line"></div><div class="line">　　[self test:&amp;a];</div><div class="line"></div><div class="line">　　// 需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。</div><div class="line"></div><div class="line">　　[self test1:&amp;a];</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　@end</div></pre></td></tr></table></figure>
<h4 id="四、static和extern简单使用-要使用一个东西，先了解其作用"><a href="#四、static和extern简单使用-要使用一个东西，先了解其作用" class="headerlink" title="四、static和extern简单使用(要使用一个东西，先了解其作用)"></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h4><p>　　static作用:</p>
<p>　　修饰局部变量：</p>
<p>　　1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>　　2.局部变量只会生成一份内存,只会初始化一次。</p>
<p>　　3.改变局部变量的作用域。</p>
<p>　　修饰全局变量</p>
<p>　　1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<p>　　2.避免重复定义全局变量</p>
<p>　　extern作用:</p>
<p>　　只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</p>
<p>　　extern工作原理:</p>
<p>　　先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">　　// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</div><div class="line"></div><div class="line">　　int a = 20;</div><div class="line"></div><div class="line">　　// static修饰全局变量</div><div class="line"></div><div class="line">　　static int age = 20;</div><div class="line"></div><div class="line">　　- (void)test</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　// static修饰局部变量</div><div class="line"></div><div class="line">　　static int age = 0;</div><div class="line"></div><div class="line">　　age++;</div><div class="line"></div><div class="line">　　NSLog(@&quot;%d&quot;,age);</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">　　[self test];</div><div class="line"></div><div class="line">　　[self test];</div><div class="line"></div><div class="line">　　extern int age;</div><div class="line"></div><div class="line">　　NSLog(@&quot;%d&quot;,age);</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　I</div></pre></td></tr></table></figure>
<h4 id="五、static与const联合使用"><a href="#五、static与const联合使用" class="headerlink" title="五、static与const联合使用"></a>五、static与const联合使用</h4><p>　　static与const作用:声明一个只读的静态变量</p>
<p>　　开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* 开发中常用static修饰全局变量,只改变作用域</div><div class="line">为什么要改变全局变量作用域，防止重复声明全局变量。</div><div class="line">开发中声明的全局变量，有些不希望外界改动，只允许读取。</div><div class="line">比如一个基本数据类型不希望别人改动</div><div class="line">声明一个静态的全局只读常量</div><div class="line">*/</div><div class="line"></div><div class="line">　　static const int a = 20;</div><div class="line"></div><div class="line">/* staic和const联合的作用:声明一个静态的全局只读常量</div><div class="line"></div><div class="line">iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量. 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</div><div class="line">*/</div><div class="line"></div><div class="line">　　static NSString * const key = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</div><div class="line"></div><div class="line">　　static NSString const *key1 = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　六、extern与const联合使用</div><div class="line"></div><div class="line">　　开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。</div><div class="line"></div><div class="line">　　原因:</div><div class="line"></div><div class="line">　　static与const组合：在每个文件都需要定义一份静态全局变量。</div><div class="line"></div><div class="line">　　extern与const组合:只需要定义一份全局变量，多个文件共享。</div><div class="line"></div><div class="line">　　全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</div><div class="line"></div><div class="line">　　GlobeConst.h</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　extern NSString * const nameKey = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　GlobeConst.m</div><div class="line"></div><div class="line">　　#import</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　NSString * const nameKey = @&quot;name&quot;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/14/UIView动画和CoreAnimation学习/" itemprop="url">
                  UIView动画和CoreAnimation学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-14T11:34:51+08:00" content="2016-04-14">
              2016-04-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">阅读原文</a>)</strong></p>
<h5 id="以前在工作中一直都忽视了对动画方面的研究-现在看了一遍刘彦玮大神的博客-偶像啊啊-gt-lt-里面有关于对动画的一些博客-自己重新对动画的知识进行有体系的学习和研究-自己记录下来希望以后能够更好的使用-学习资料来源于iOS动画和特效专题"><a href="#以前在工作中一直都忽视了对动画方面的研究-现在看了一遍刘彦玮大神的博客-偶像啊啊-gt-lt-里面有关于对动画的一些博客-自己重新对动画的知识进行有体系的学习和研究-自己记录下来希望以后能够更好的使用-学习资料来源于iOS动画和特效专题" class="headerlink" title="以前在工作中一直都忽视了对动画方面的研究,现在看了一遍刘彦玮大神的博客(偶像啊啊!&gt;&lt;),里面有关于对动画的一些博客,自己重新对动画的知识进行有体系的学习和研究,自己记录下来希望以后能够更好的使用,学习资料来源于iOS动画和特效专题"></a>以前在工作中一直都忽视了对动画方面的研究,现在看了一遍<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">刘彦玮</a>大神的博客(偶像啊啊!&gt;&lt;),里面有关于对动画的一些博客,自己重新对动画的知识进行有体系的学习和研究,自己记录下来希望以后能够更好的使用,学习资料来源于<a href="http://liuyanwei.jumppo.com/2015/10/29/iOS-animation-0.html" target="_blank" rel="external">iOS动画和特效专题</a></h5><h3 id="一-从最简单的动画开始"><a href="#一-从最简单的动画开始" class="headerlink" title="一.从最简单的动画开始"></a>一.从最简单的动画开始</h3><p>在我们刚刚进入iOS的学习过程中,最先接触的,肯定是下面这个方式来做简答的动画吧!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//初始设定</div><div class="line">	animateView.frame = CGRect(x: 0, y: 0, width: 100, height: 100)</div><div class="line">	        animateView.backgroundColor = UIColor.redColor()</div><div class="line">	        </div><div class="line">	 view.addSubview(animateView)</div><div class="line"></div><div class="line">//最简答的动画是这样设置的:</div><div class="line">        </div><div class="line">      UIView.animateWithDuration(1.0, animations: &#123;</div><div class="line">          //动画效果</div><div class="line">          //颜色可以变</div><div class="line">          self.animateView.backgroundColor = UIColor.yellowColor()</div><div class="line">          //大小/位置可变</div><div class="line">          self.animateView.frame = CGRect(x: 200 , y: 200, width: 200, height: 200)</div><div class="line">          //透明度改变</div><div class="line">          self.animateView.alpha = 0.5</div><div class="line">          </div><div class="line">      &#125;) &#123; (isCompletion) in</div><div class="line">          print(&quot;动画结束&quot;)</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>animateWithDurationl里面有四个重载的方法,使用该方法可以实现了很多简单的功能,其中一个还有有阻尼系数和回弹系数,可以设置弹簧效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">//此方法含有阻尼系数和回弹系数</div><div class="line">        UIView.animateWithDuration(0.2, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions.CurveEaseIn, animations: &#123;</div><div class="line">            //大小/位置可变</div><div class="line">            self.animateView.frame = CGRect(x: 200 , y: 200, width: 200, height: 200)</div><div class="line">            &#125;) &#123; (isCompletion) in</div><div class="line">                print(&quot;动画结束&quot;)</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="二-Core-Animation的类图"><a href="#二-Core-Animation的类图" class="headerlink" title="二.Core Animation的类图"></a>二.Core Animation的类图</h3><p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect05.png" alt="类图"></p>
<ul>
<li><p>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>
</li>
<li><p>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</p>
</li>
<li><p>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>
</li>
<li><p>CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>
</li>
<li><p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>
</li>
<li><p>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
</li>
</ul>
<h3 id="基本动画CABasicAnimation"><a href="#基本动画CABasicAnimation" class="headerlink" title="基本动画CABasicAnimation"></a>基本动画CABasicAnimation</h3><p>然后按照老师的写法,再自己敲了一遍,在touchesBegan方法里面进行了尝试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">       let baseAnimation = CABasicAnimation(keyPath: &quot;position&quot;)</div><div class="line">        //fromValue设置起点位置,不设置的时候为当前位置</div><div class="line">//        let point  = CGPoint(x: 100, y: 100)</div><div class="line">//        baseAnimation.toValue = NSValue(CGPoint: point)</div><div class="line">        baseAnimation.byValue = NSValue(CGPoint: CGPoint(x: 100, y: 100))</div><div class="line">        </div><div class="line">        //其他动画属性</div><div class="line">        baseAnimation.duration = 0.2</div><div class="line">        baseAnimation.repeatCount = 1</div><div class="line">        </div><div class="line">        //加速运动</div><div class="line">//        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)</div><div class="line">        //自定义加速的曲线参数</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(controlPoints: 0.1, 0, 0.9, 0.7)</div><div class="line">        </div><div class="line">        </div><div class="line">        //这两个属性若不设置，动画执行后回复位</div><div class="line">        baseAnimation.removedOnCompletion = false</div><div class="line">        baseAnimation.fillMode = kCAFillModeForwards</div><div class="line">        </div><div class="line">        //可以在动画中缓存一些</div><div class="line">        //baseAnimation.setValue(NSValue(CGPoint: point), forKey: &quot;startPoint&quot;)</div><div class="line">        //开始动画</div><div class="line">        animateView.layer.addAnimation(baseAnimation, forKey: &quot;TextAnimateView&quot;)</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect01.gif" alt=""><br>老师后来提醒了说其实动画只是layer层改变了,实际上,view上的frame还是没有改变,当你再次点击屏幕的时候,view又会回到原来的地方,重新开始这个动画.解决办法是重新设置view.frame :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//        ----------------</div><div class="line">//        此处设置的代理是为了可以让view.frame同时跟着view.layer一起改变</div><div class="line">        baseAnimation.delegate = self</div><div class="line">        </div><div class="line">        baseAnimation.setValue(NSValue(CGPoint: endPoint), forKey: &quot;endPoint&quot;)</div><div class="line">        baseAnimation.setValue(self.animateView, forKey: &quot;sender&quot;)</div><div class="line">        </div><div class="line">//        ----------------</div><div class="line">//代理方法里面可以获取到view和终点的位置</div><div class="line">override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">        let endPoint = anim.valueForKey(&quot;endPoint&quot;)?.CGPointValue()</div><div class="line">        let theView = anim.valueForKey(&quot;sender&quot;) as! UIView</div><div class="line">        theView.layer.position = endPoint!</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>keyPath用于区分BasicAnimation动画类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">   可选的KeyPath</div><div class="line">   transform.scale = 比例轉換 </div><div class="line">   transform.scale.x</div><div class="line">   transform.scale.y</div><div class="line">   &#123;</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale&quot;)</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale.x&quot;)</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale.y&quot;)</div><div class="line">    //初始大小</div><div class="line">    transformAnimation.fromValue = NSNumber(float: 1.0)</div><div class="line">    //最终大小</div><div class="line">    transformAnimation.toValue = NSNumber(double: 2.0)</div><div class="line">//  以上缩放是以view的中心点为中心缩放的，如果需要自定义缩放点，可以设置卯点：</div><div class="line">//        //中心点</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(0.5, 0.5)</div><div class="line">//        //左上角</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(0, 0)</div><div class="line">//        //右下角</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(1.0, 1.0)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   transform.rotation = 旋轉</div><div class="line">   transform.rotation.x</div><div class="line">   transform.rotation.y</div><div class="line">   transform.rotation.z</div><div class="line">   </div><div class="line">   &#123;</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.x&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.y&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.z&quot;)</div><div class="line">    	 //初始角度</div><div class="line">        transformAnimation.fromValue = NSNumber(float: 0)</div><div class="line">        //旋转后角度</div><div class="line">        transformAnimation.toValue = NSNumber(float: 130)</div><div class="line">        </div><div class="line">        </div><div class="line">   &#125;</div><div class="line">   transform.translation</div><div class="line">   transform.translation.x</div><div class="line">   transform.translation.y</div><div class="line">   transform.translation.z</div><div class="line"></div><div class="line">   opacity = 透明度</div><div class="line">   margin</div><div class="line">   zPosition</div><div class="line">   backgroundColor 背景颜色</div><div class="line">   cornerRadius 圆角</div><div class="line">   borderWidth</div><div class="line">   bounds</div><div class="line">   contents</div><div class="line">   contentsRect</div><div class="line">   cornerRadius</div><div class="line">   frame</div><div class="line">   hidden</div><div class="line">   mask</div><div class="line">   masksToBounds</div><div class="line">   opacity</div><div class="line">   position</div><div class="line">   shadowColor</div><div class="line">   shadowOffset</div><div class="line">   shadowOpacity</div><div class="line">   shadowRadius</div><div class="line"></div><div class="line">   */</div></pre></td></tr></table></figure>
<h3 id="CABasicAnimation-组合动画"><a href="#CABasicAnimation-组合动画" class="headerlink" title="CABasicAnimation 组合动画"></a>CABasicAnimation 组合动画</h3><p>所有的动画都是由简单的简单的动画组合成的,所以对基础动画的学习是很重要的的,如果需要复杂的动画,当然是要发挥你的想象力啦~<br>自己按老师的代码敲了一遍,熟悉熟悉~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//组合动画</div><div class="line">      func groupAnimation(theView:UIView)&#123;</div><div class="line"></div><div class="line">      //向右平移100</div><div class="line">      let mAnimation = CABasicAnimation(keyPath: &quot;position&quot;)</div><div class="line">      //baseAnimation.fromValue 初始位置，如果不设就是当前位置</div><div class="line">      let endPoint = CGPoint(x: theView.layer.position.x+100, y: theView.layer.position.y)</div><div class="line">      mAnimation.toValue = NSValue(CGPoint:endPoint)//绝对位置</div><div class="line"></div><div class="line">      //baseAnimation.byValue = NSValue(CGPoint:CGPoint(x: 100, y: 0))//相对位置</div><div class="line"></div><div class="line">      //x轴旋转动画</div><div class="line">      let xAnimation = CABasicAnimation(keyPath: &quot;transform.rotation.x&quot;)</div><div class="line">      (xAnimation as CABasicAnimation).byValue =  NSNumber(double:M_PI*500)</div><div class="line">      xAnimation.duration = 1.5</div><div class="line"></div><div class="line">      //y轴旋转动画</div><div class="line">      let yAnimation = CABasicAnimation(keyPath: &quot;transform.rotation.y&quot;)</div><div class="line">      (yAnimation as CABasicAnimation).byValue =  NSNumber(double:M_PI*200)</div><div class="line"></div><div class="line">      //缩放动画</div><div class="line">      let sAnimation = CABasicAnimation(keyPath: &quot;transform.scale&quot;)</div><div class="line">      // 动画选项设定</div><div class="line">      sAnimation.autoreverses = true // 动画结束时执行逆动画</div><div class="line">      // 缩放倍数</div><div class="line">      sAnimation.fromValue = NSNumber(double:0.1) // 开始时的倍率</div><div class="line">      sAnimation.toValue = NSNumber(double:1.5) // 结束时的倍率</div><div class="line"></div><div class="line">      //动画组</div><div class="line">      let groupAnimation = CAAnimationGroup()</div><div class="line"></div><div class="line">      // 动画选项设定，动画组统一设置或者单独设置</div><div class="line">      groupAnimation.duration = 3.0;</div><div class="line">      groupAnimation.repeatCount = 1;</div><div class="line">      groupAnimation.animations = [xAnimation,yAnimation,sAnimation,mAnimation]</div><div class="line">      //这两个属性若不设置，动画执行后回复位</div><div class="line">      groupAnimation.removedOnCompletion = false</div><div class="line">      groupAnimation.fillMode = kCAFillModeForwards</div><div class="line">      groupAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)//加速运动</div><div class="line">      groupAnimation.delegate = self</div><div class="line">      //可以在动画中缓存一些</div><div class="line">      groupAnimation.setValue(NSValue(CGPoint: endPoint), forKey: &quot;endPoint&quot;)</div><div class="line">      groupAnimation.setValue(theView, forKey: &quot;sender&quot;)</div><div class="line">      //执行动画</div><div class="line">      theView.layer.addAnimation(groupAnimation, forKey: &quot;theViewMoveRotation90&quot;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect02.gif" alt=""></p>
<h3 id="关键帧动画-CAKeyframeAnimation"><a href="#关键帧动画-CAKeyframeAnimation" class="headerlink" title="关键帧动画 CAKeyframeAnimation"></a>关键帧动画 CAKeyframeAnimation</h3><blockquote>
<p>关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>
</blockquote>
<p>那么,Keyframe顾名思义就是关键点的frame，你可以通过设定CALayer的始点、中间关键点、终点的frame，时间，动画会沿你设定的轨迹进行移动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private func KeyframeAnimation(theView:UIView)&#123;</div><div class="line">        </div><div class="line">        //关键帧动画</div><div class="line">        let keyframeAnimation = CAKeyframeAnimation(keyPath: &quot;position&quot;)</div><div class="line">        //弧线位置移动</div><div class="line">        </div><div class="line">        </div><div class="line">        //弧线位置移动</div><div class="line">        let path = CGPathCreateMutable()</div><div class="line">        CGPathMoveToPoint(path, nil, 50, 50)</div><div class="line">        //曲线描述</div><div class="line">        CGPathAddCurveToPoint(path, nil, 50, 50, 700, 300, 30, 500)</div><div class="line">        keyframeAnimation.path = path</div><div class="line">        </div><div class="line">        keyframeAnimation.duration = 1.0 ;</div><div class="line">        keyframeAnimation.beginTime =  CACurrentMediaTime() + 2;</div><div class="line">        theView.layer.addAnimation(keyframeAnimation, forKey: &quot;1111&quot;)</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect03.gif" alt=""><br>(插图失败,为了让自己看到效果,继续借图)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">     先附带上让一些迷糊的属性解释吧,要不然大家好像有点看不懂!</div><div class="line">     （1）values属性</div><div class="line"></div><div class="line">     values属性指明整个动画过程中的关键帧点，例如上例中的A-E就是通过values指定的。需要注意的是，起点必须作为values的第一个值。</div><div class="line"></div><div class="line">     （2）path属性</div><div class="line"></div><div class="line">     作用与values属性一样，同样是用于指定整个动画所经过的路径的。需要注意的是，values与path是互斥的，当values与path同时指定时，path会覆盖values，即values属性将被忽略。例如上述pathAnimation例子</div><div class="line"></div><div class="line">     （3）keyTimes属性</div><div class="line"></div><div class="line">     该属性是一个数组，用以指定每个子路径(AB,BC,CD)的时间。如果你没有显式地对keyTimes进行设置，则系统会默认每条子路径的时间为：ti=duration/(5-1)，即每条子路径的duration相等，都为duration的1\4。当然，我们也可以传个数组让物体快慢结合。例如，你可以传入&#123;0.0, 0.1,0.6,0.7,1.0&#125;，其中首尾必须分别是0和1，因此tAB=0.1-0, tCB=0.6-0.1, tDC=0.7-0.6, tED=1-0.7.....</div><div class="line"></div><div class="line">     （4）timeFunctions属性</div><div class="line"></div><div class="line">     用过UIKit层动画的同学应该对这个属性不陌生，这个属性用以指定时间函数，类似于运动的加速度，有以下几种类型。上例子的AB段就是用了淡入淡出效果。记住，这是一个数组，你有几个子路径就应该传入几个元素</div><div class="line"></div><div class="line">     1 kCAMediaTimingFunctionLinear//线性</div><div class="line">     2 kCAMediaTimingFunctionEaseIn//淡入</div><div class="line">     3 kCAMediaTimingFunctionEaseOut//淡出</div><div class="line">     4 kCAMediaTimingFunctionEaseInEaseOut//淡入淡出</div><div class="line">     5 kCAMediaTimingFunctionDefault//默认</div><div class="line"></div><div class="line">     （5）calculationMode属性</div><div class="line"></div><div class="line">     该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似</div><div class="line"></div><div class="line">     1 const kCAAnimationLinear//线性，默认</div><div class="line">     2 const kCAAnimationDiscrete//离散，无中间过程，但keyTimes设置的时间依旧生效，物体跳跃地出现在各个关键帧上</div><div class="line">     3 const kCAAnimationPaced//平均，keyTimes跟timeFunctions失效</div><div class="line">     4 const kCAAnimationCubic//平均，同上</div><div class="line">     5 const kCAAnimationCubicPaced//平均，同上</div><div class="line"></div><div class="line">     */</div></pre></td></tr></table></figure>
<h3 id="转场效果"><a href="#转场效果" class="headerlink" title="转场效果"></a>转场效果</h3><p>转场动画的使用一般分为以下几个步骤：</p>
<ul>
<li>创建转场动画</li>
<li>设置转场类型、子类型（可选）及其他属性</li>
<li>设置转场后的新视图并添加动画到图层</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">  //步骤1：添加view底图，添加view的左右滑动手势</div><div class="line">    let bg = UIImageView(image: UIImage(named: &quot;x0&quot;))</div><div class="line">    func addBgImageView()&#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        bg.frame = CGRect(x: 0, y: 0, width: UIScreen.mainScreen().bounds.size.width, height: UIScreen.mainScreen().bounds.size.height)</div><div class="line">        view.addSubview(bg)</div><div class="line">        </div><div class="line">        let rightSwipe = UISwipeGestureRecognizer(target: self, action:#selector(ViewController.rightSwipe(_:)))</div><div class="line">        rightSwipe.direction = .Right</div><div class="line">        let leftSwipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.leftSwipe(_:)))</div><div class="line">        leftSwipe.direction = .Left</div><div class="line">        </div><div class="line">        view.addGestureRecognizer(rightSwipe)</div><div class="line">        view.addGestureRecognizer(leftSwipe)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">//    步骤2：随机获取图片和随机获取转场效果的函数</div><div class="line">    var images:[UIImage]?</div><div class="line">    func fetchImage()-&gt;UIImage&#123;</div><div class="line">        if images == nil &#123;</div><div class="line">            images = [];</div><div class="line">            </div><div class="line">            for index in 0...5 &#123;</div><div class="line">                let image = UIImage(named: &quot;x&quot; + String(index))</div><div class="line">                images!.append(image!)</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return images![Int(arc4random()%5)]</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func swipeTransition(subtype:String) -&gt; CATransition &#123;</div><div class="line">        let transfer = CATransition()</div><div class="line">        </div><div class="line">        /*</div><div class="line">         kCATransitionFade：淡入淡出，默认效果</div><div class="line">         kCATransitionMoveIn：新视图移动到就是图上方</div><div class="line">         kCATransitionPush:新视图推开旧视图</div><div class="line">         kCATransitionReveal：移走旧视图然后显示新视图</div><div class="line">         </div><div class="line">         //苹果未公开的私有转场效果</div><div class="line">         cube:立方体</div><div class="line">         suckEffect:吸走的效果</div><div class="line">         oglFlip:前后翻转效果</div><div class="line">         rippleEffect:波纹效果</div><div class="line">         pageCurl:翻页起来</div><div class="line">         pageUnCurl:翻页下来</div><div class="line">         cameraIrisHollowOpen:镜头开</div><div class="line">         cameraIrisHollowClose:镜头关</div><div class="line">         */</div><div class="line">        </div><div class="line">        let types = [kCATransitionFade,kCATransitionMoveIn,kCATransitionPush,kCATransitionReveal,&quot;cube&quot;,&quot;suckEffect&quot;,&quot;oglFlip&quot;,&quot;rippleEffect&quot;,&quot;pageCurl&quot;,&quot;pageUnCurl&quot;,&quot;cameraIrisHollowOpen&quot;,&quot;cameraIrisHollowClose&quot;]</div><div class="line">        </div><div class="line">        let type = types[Int(arc4random()%11)]</div><div class="line">        </div><div class="line">        transfer.type = type</div><div class="line">        </div><div class="line">        NSLog(&quot;%@&quot;, type)</div><div class="line">        </div><div class="line">        transfer.subtype = subtype</div><div class="line">        transfer.duration = 1</div><div class="line">        return transfer</div><div class="line">    &#125;</div><div class="line">//    步骤3：左右滑动方法，实现场景切换</div><div class="line">    </div><div class="line">    func rightSwipe(rightSwipe:UIGestureRecognizer)&#123;</div><div class="line">        </div><div class="line">        bg.image = fetchImage()</div><div class="line">        bg.layer.addAnimation(swipeTransition(kCATransitionFromRight), forKey: &quot;kCATransitionFromRight&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func leftSwipe(leftSwipe:UIGestureRecognizer)&#123;</div><div class="line">        </div><div class="line">        bg.image = fetchImage()</div><div class="line">        bg.layer.addAnimation(swipeTransition(kCATransitionFromLeft), forKey: &quot;kCATransitionFromleft&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect04.gif" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://wuzhi.me/avatar/112063.1460211687.jpg"
               alt="shiron" />
          <p class="site-author-name" itemprop="name">shiron</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shiron</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
