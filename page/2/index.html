<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="shiron" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="shiron">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="shiron">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shiron">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> shiron </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">shiron</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/swift中懒加载的then语法/" itemprop="url">
                  swift中懒加载的then语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T23:19:27+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文:<br><a href="http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;mid=2652684686&amp;idx=1&amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;chksm=f00b6f44c77ce6521a20506a99cf446792ac70b537c09d05b7ad4066aa4b8a4cfaba4bedb2af&amp;scene=0#wechat_redirect" target="_blank" rel="external">Swift：让人眼前一亮的初始化方式</a></p>
<p>###then语法</p>
<p>个人非常喜欢这种简介的懒加载模式,唔,不过有时候真的会觉得$0的时候,无法感应该类的属性真蛋疼. 以下是加载方式,供大家参考学习.</p>
<pre><code>  import Foundation

 public protocol Then {}

 extension Then where Self: Any {
         /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: inout Self -&gt; Void) -&gt; Self {
        var copy = self
        block(&amp;copy)
        return copy
    }
     }

 extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: Self -&gt; Void) -&gt; Self {
        block(self)
        return self
     }
    }

extension NSObject: Then {}


  //textFiled的常用懒加载模式
    private lazy var textFiled : UITextField={
        let textFiled = UITextField()
        textFiled.placeholder = &quot;请输入文字&quot;
        return textFiled
    }()

  //在尾随闭包中实例化了UILabel时的写法
     lazy var label : UILabel={

        $0.text = &quot;我是占位文字,textFiled改变时我也会改变&quot;
        $0.font = UIFont.systemFontOfSize(16)

        return $0
    }(UILabel())


//文章开始时给出的then代码段,使得初始化更简洁
 let label = UILabel().then {
      $0.textAlignment = .Center
      $0.textColor = .blackColor()
      $0.text = &quot;Hello, World!&quot;
    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/10/Java基础学习汇总/" itemprop="url">
                  Java基础学习汇总
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-10T23:31:12+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Java基础学习汇总</p>
<p>###多线程</p>
<ul>
<li>了解:所谓多线程,即是在一个进程中,可以同时运行的多任务.如果把现实中的每个人理解为一个进程(QQ),那每个人可以同时处理多项任务,如一边听歌一边写作业可以理解为多线程开启.一个进程占用CUP时间是有限的,通常我们感觉不到有切换是因为CUP切换的速度极快.<h3 id="多线程的实现方法有两种"><a href="#多线程的实现方法有两种" class="headerlink" title="多线程的实现方法有两种"></a>多线程的实现方法有两种</h3></li>
<li><p>1.继承Thread</p>
<ul>
<li>定义类继承Thread</li>
<li>重写run方法</li>
<li>把新线程要做的内容写在run方法中</li>
<li>创建类的对象</li>
<li>执行start方法</li>
<li>注意:匿名内部类和普通类方式非常相似</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	//1.普通定义一个新的类来创建</div><div class="line">	Person p = new Person();</div><div class="line">	p.start();</div><div class="line">	//1.普通定义一个匿名类来创建</div><div class="line">	new Thread()&#123;</div><div class="line">		public void run()&#123;</div><div class="line">			System.out.println(&quot;Thread多线程启动(匿名内	部类)&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;.start();	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Thread方式</div><div class="line">class Person extends Thread &#123;</div><div class="line">	public void run()&#123;</div><div class="line">	System.out.println(&quot;Thread多线程启动,继承方式&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.实现接口Runnable(Thread构造函数中传递了runnable的引用,通过init()方法传递target,用于判断是否执行run()方法)</p>
<ul>
<li>定义类实现Runnable</li>
<li>实现run方法</li>
<li>把操作写在run中</li>
<li>创建Thread对象,传入runnable</li>
<li>调用Runnable的start方法</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">//1.普通类实现了runnable接口来实现调用里面的run方法</div><div class="line">Student s = new Student();</div><div class="line">Thread t = new Thread(s);</div><div class="line">t.start();</div><div class="line">//2.匿名类来实现runnable接口</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;匿名内部类Runnable多线程启动方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;).start();	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class Student implements Runnable&#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;Runnable多线程启动方法,继承方式&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>###两种线程的区别</p>
<ul>
<li>继承Thread<ul>
<li>好处:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端:如果已经有父类,就不能用这种方式</li>
</ul>
</li>
<li>实现Runnable<ul>
<li>好处:可以有父类,直接只是实现接口</li>
<li>弊端:间接把对象作为构造方法的参数传递进去,较为复杂,但自由度较大</li>
</ul>
</li>
</ul>
<h3 id="线程中其他操作"><a href="#线程中其他操作" class="headerlink" title="线程中其他操作"></a>线程中其他操作</h3><ul>
<li>通过getName()可以获得当前线程的名字</li>
<li>通过setName(String)可以设置线程名字</li>
<li>Thread.currentThread()可以获得当前线程对象,获得对象后可以对其进行操作(改名,获得名字)</li>
<li>Thread.sleep(毫秒),类方法调用,可以使得当前线程休眠</li>
<li>setPriority()设置线程的优先级</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/Java异常处理抛出/" itemprop="url">
                  Java异常处理抛出
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T14:34:48+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.</p>
<p>###1.所谓的异常就是在Java程序运行过程中出现的错误.</p>
<ul>
<li>Error : 直接的错误信息,网络回调错误,数据库异常等.</li>
<li>Execption : 异常信息,较为核心的是RuntimeException子类<br>######<em>注:以上两个类都是继承了Throwable的类</em></li>
</ul>
<p>###2.try…catch 的格式(方式)</p>
<ul>
<li>A:异常处理的两种方式<ul>
<li>a:try…catch…finally<br><em>注意:1.被finally控制的语句体一定会执行</em><br><em>2.用于释放资源，在IO流操作和数据库操作中会见到</em><ul>
<li>try catch</li>
<li>try catch finally</li>
<li>try finally </li>
</ul>
</li>
<li>b:throws</li>
</ul>
</li>
<li>B:try…catch处理异常的基本格式<ul>
<li>try…catch…finally</li>
</ul>
</li>
</ul>
<p>###3.那么我们如何选择异常处理的方式呢?</p>
<ul>
<li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li>
<li>区别:<ul>
<li>后续程序需要继续运行就try</li>
<li>后续程序不需要继续运行就throws</li>
</ul>
</li>
</ul>
<p>###4.自定义异常的主要原因是为了可以快速定位异常的原因</p>
<ul>
<li>一种是继承自RuntimeException,另外一种是继承Exception.</li>
</ul>
<p><em>其实对于异常的使用,还是不是特别理解,日后回来再填坑.</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/23/关联对象存放自定义数据/" itemprop="url">
                  关联对象存放自定义数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-23T23:23:04+08:00" content="2016-05-23">
              2016-05-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关联对象存放自定义数据"><a href="#关联对象存放自定义数据" class="headerlink" title="关联对象存放自定义数据"></a>关联对象存放自定义数据</h3><h4 id="关于objc-setAssociatedObject和objc-getAssociatedObject"><a href="#关于objc-setAssociatedObject和objc-getAssociatedObject" class="headerlink" title="关于objc_setAssociatedObject和objc_getAssociatedObject"></a>关于objc_setAssociatedObject和objc_getAssociatedObject</h4><p>最近是在52个提高IOS高质量代码中看到这个特性的.<br>在我写代码的过程中,我感觉这种方式可以提供代理中的高聚合(和RAC的函数式编程有异曲同工之妙)<br>先把代码上上来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)viewDidLoad &#123;</div><div class="line">            [super viewDidLoad];</div><div class="line"></div><div class="line">                UIAlertView* alert =  [[UIAlertView alloc] initWithTitle:@&quot;信息&quot; message:@&quot;提示&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确认&quot;, nil];</div><div class="line">    </div><div class="line">                void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;</div><div class="line">                    if (buttonIndex == 0) &#123;</div><div class="line">                        NSLog(@&quot;取消按钮&quot;);</div><div class="line">                    &#125;else if (buttonIndex == 1)&#123;</div><div class="line">                        NSLog(@&quot;确认按钮&quot;);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;;</div><div class="line">    </div><div class="line">                objc_setAssociatedObject(alert, ALERTVIEWKEY, block,             OBJC_ASSOCIATION_COPY);</div><div class="line">            //</div><div class="line">            //    NSString* str = @&quot;存储自定义数据&quot;;</div><div class="line">            //    </div><div class="line">            //    objc_setAssociatedObject(alert, ALERTVIEWKEY, str,             OBJC_ASSOCIATION_COPY);</div><div class="line">                [alert show];</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>在实现代理中,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#pragma alertDelegate</div><div class="line"> -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:   (NSInteger)buttonIndex&#123;</div><div class="line">    </div><div class="line">    void(^block)(NSInteger) = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">    block(buttonIndex);</div><div class="line">     //    NSString* str = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">     //    NSLog(@&quot;%@&quot;,str);</div><div class="line">    </div><div class="line">    NSLog(@&quot;%ld&quot;,(long)buttonIndex);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>我们所得到的效果是可以在上面viewDidload代码中直接执行了按钮的响应.<br>点击不同的按钮作出相应的动作.</p>
<h3 id="实际上-在set方法中"><a href="#实际上-在set方法中" class="headerlink" title="实际上,在set方法中:"></a>实际上,在set方法中:</h3><pre><code>objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)
</code></pre><p>方法中,我们可以在id value传入任意参数,字符串(如注释代码中str的传递),数组,字典等,当然,例子中传递匿名函数就是较为灵活的用法.</p>
<ul>
<li>第一个参数 &lt;#id object#&gt;传入对象</li>
<li>第二个参数 &lt;#const void *key#&gt;为一个key,一般格式为 <pre><code>static void * NAME = &quot;NAME&quot;;
</code></pre></li>
<li>第三个参数 需要传递的对象,如匿名函数,字符串,数组等对象.(一般考虑传递信息,自定义数据,灵活的非常大)</li>
<li>第四个参数 定义的是objc_AssociationPolicy枚举,根据第三个参数来决定这个参数的@property到底是assign,还是nonatomic,retain,还是nonatomic,copy,还是retain,或者的单纯的copy.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">                                            *   The association is made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">                                            *   The association is made atomically. */</div></pre></td></tr></table></figure>
<h4 id="而代理中调用runtime的get方法"><a href="#而代理中调用runtime的get方法" class="headerlink" title="而代理中调用runtime的get方法:"></a>而代理中调用runtime的get方法:</h4><p>objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;</p>
<ul>
<li>&lt;#id object#&gt;放入对象(代理或者通过其他方式(如属性,指针)放入存储了自定义数据的对象</li>
<li>&lt;#const void *key#&gt;为记录了当初存储该自定义数据的键值</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>其实这种方法并不推荐大家经常使用,因为滥用的话容易导致代码失控,难于调试.</p>
<ul>
<li>可以通过”关联对象”机制把两个对象连接起来</li>
<li>定义关联对象时可以指定内存管理语义,用以模仿定义属性时采用的”拥有关系”和”非拥有关系”</li>
<li>只有在其他做法不可行才应选择关联对象,因为这种做法通常会引入难于查找的bug</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/28/swift中的跑马灯实现（导航栏）/" itemprop="url">
                  swift中的跑马灯实现（导航栏）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-28T03:28:57+08:00" content="2016-03-28">
              2016-03-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先是懒加载了runLabel：</p>
<pre><code> private lazy var runLabel : UILabel={
     let label = UILabel()
     label.sizeToFit()

    label.font = UIFont(name: kMyFontName, size: kFontSize14)
    label.textColor = UIColor.blackColor()
    return label
}()
</code></pre><p>然后在viewDidLoad中实现addsubView方法：</p>
<pre><code>/// 跑马灯
self.navigationItem.titleView?.addSubview(runLabel)
//设置label的原始位置
runLabel.frame.origin.x = kScreenWidth


UIView.beginAnimations(self.productName, context: nil)
UIView.setAnimationDuration(16)
UIView.setAnimationCurve(UIViewAnimationCurve.Linear)
UIView.setAnimationDelegate(self)
UIView.setAnimationRepeatCount(999999)

runLabel.frame.origin.x = -runLabel.frame.size.width
UIView .commitAnimations()
</code></pre><p>另外如果文字过长的话建议直接计算文字宽度（做个简单的分类即可）</p>
<pre><code>extension String {
  func getTitleW() -&gt; CGFloat{
     /// 计算文字宽度
     var dict:[String:AnyObject] = [:]
      dict[NSFontAttributeName] = UIFont(name: kMyFontName, size:   kFontSize14)
          return NSString(string:     self).boundingRectWithSize(CGSizeMake(999, 14), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: dict, context: nil).size.width + 24

    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/第三方HTML解析-TFHpple-的简单使用/" itemprop="url">
                  第三方HTML解析 TFHpple 的简单使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T16:42:32+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第三方HTML解析-TFHpple-的简单使用-swift版"><a href="#第三方HTML解析-TFHpple-的简单使用-swift版" class="headerlink" title="第三方HTML解析 TFHpple 的简单使用(swift版)"></a>第三方HTML解析 TFHpple 的简单使用(swift版)</h3><h3 id="一-使用TFHpple解析-必须导入文件和框架xmllib2"><a href="#一-使用TFHpple解析-必须导入文件和框架xmllib2" class="headerlink" title="一.使用TFHpple解析,必须导入文件和框架xmllib2"></a>一.使用TFHpple解析,必须导入文件和框架xmllib2</h3><p>(OS_导入libxml2.2框架后,找不到<libxml tree.h="">的解决办法)</libxml></p>
<ol>
<li><p>pod导入TFHpple第三方库(<strong>此时编译会报错误:找不到libxml tree.h</strong>)</p>
</li>
<li><p>下载完成后需要配置项目中的动态库,选中项目,像工程中添加”libxml2.tbd” (借一下图,感谢<a href="http://my.csdn.net/pilqc2009" target="_blank" rel="external">pilqc2009</a>)<br><img src="http://img.blog.csdn.net/20140822203855390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></p>
</li>
</ol>
<p><img src="../../images/1.png" alt=""></p>
<ol>
<li><p>切换到切换到Buiild Settings的tab里，通过搜索,找到“Linking”选项框，在里面的”Other Linker Flags”的debug 和 release 里面点击“+”，添加 “-lxml2”<br><img src="http://img.blog.csdn.net/20140822204223171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>跟步骤2一样，依然在Buiild Settings的tab里，通过搜索，找到 Framework Search ,添加“/usr/lib/libxml2.tbd”；<br><img src="http://img.blog.csdn.net/20140822204710075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
</ol>
<ol>
<li>跟步骤3一样，依然在Buiild Settings的tab里，通过搜索，在“Header Search Paths” 和 “User Header Search Paths” 里填入$(SDKROOT)/usr/include/libxml2。<br><img src="http://img.blog.csdn.net/20140822205006387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ol>
<ol>
<li>然后clean项目，就OK，可以使用了。</li>
</ol>
<h3 id="二-那么-导入以后又应该如何使用TFHpple呢"><a href="#二-那么-导入以后又应该如何使用TFHpple呢" class="headerlink" title="二.那么,导入以后又应该如何使用TFHpple呢?"></a>二.那么,导入以后又应该如何使用TFHpple呢?</h3><p>我们先来看看官方在oc下是如何使用的吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#import &quot;TFHpple.h&quot;</div><div class="line"></div><div class="line">//</div><div class="line">NSData  * data      = [NSData dataWithContentsOfFile:@&quot;index.html&quot;];</div><div class="line"></div><div class="line">//</div><div class="line">TFHpple * doc       = [[TFHpple alloc] initWithHTMLData:data];</div><div class="line">NSArray * elements  = [doc search:@&quot;//a[@class=&apos;sponsor&apos;]&quot;];</div><div class="line"></div><div class="line">TFHppleElement * element = [elements objectAtIndex:0];</div><div class="line">[e text];                       // The text inside the HTML element (the content of the first text node)</div><div class="line">[e tagName];                    // &quot;a&quot;</div><div class="line">[e attributes];                 // NSDictionary of href, class, id, etc.</div><div class="line">[e objectForKey:@&quot;href&quot;];       // Easy access to single attribute</div><div class="line">[e firstChildWithTagName:@&quot;b&quot;]; // The first &quot;b&quot; child node</div></pre></td></tr></table></figure>
<h4 id="2-1分析一下它是如何使用该类的"><a href="#2-1分析一下它是如何使用该类的" class="headerlink" title="2.1分析一下它是如何使用该类的:"></a>2.1分析一下它是如何使用该类的:</h4><ul>
<li>第一步先将.html转为为data文件</li>
<li>第二步是用带data参数的方法实例化TFHpple对象</li>
<li>第三步的时候,我们就可以用各种适配的方法来进行节点的获取了(<strong>下面会讲到这些条件是怎么使用的</strong>)</li>
<li>第四步,获取到某个节点的时候,如果确定只有一个用该类命名的元素时,可以直接取first第一个元素<ul>
<li>text是该元素下,dom中间的内容</li>
<li>tagName 是该元素的html标签</li>
<li>attributes 是该元素下,元素属性的值</li>
<li>objectForKey:@”href” 可以根据节点属性来取属性中属性的值,如取imageUrl</li>
<li>firstChildWithTagName:@”b”  第一个名称为b的子节点</li>
</ul>
</li>
</ul>
<p>其实掌握了以上的方法,就可以很好的运用该框架来获取html文件中的任何内容了. </p>
<h4 id="2-2这里先来解释一下-TFHpple中的类方法seacrh-quot-xxxxx-quot-是什么东西吧"><a href="#2-2这里先来解释一下-TFHpple中的类方法seacrh-quot-xxxxx-quot-是什么东西吧" class="headerlink" title="2.2这里先来解释一下 TFHpple中的类方法seacrh:&quot;xxxxx&quot;是什么东西吧!"></a>2.2这里先来解释一下 TFHpple中的类方法<code>seacrh:&quot;xxxxx&quot;</code>是什么东西吧!</h4><p><strong>其实这个就是一个选取节点的武器,让给我们来看看这部分是怎么组成的吧(有html基础的同学可能能更快反应过来)</strong></p>
<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取</p>
<p><strong>下面列出了最有用的路径表达式：</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td> /</td>
<td>从根节点选取。</td>
</tr>
<tr>
<td> //</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td> .</td>
<td>选取当前节点。</td>
</tr>
<tr>
<td> ..</td>
<td>选取当前节点的父节点。</td>
</tr>
<tr>
<td> @</td>
<td>选取属性。</td>
</tr>
</tbody>
</table>
<p>举个例子来体会一下吧,下面是xml文档格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</div><div class="line"></div><div class="line">&lt;bookstore&gt;</div><div class="line"></div><div class="line">&lt;book&gt;</div><div class="line">  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;</div><div class="line">  &lt;price&gt;29.99&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line"></div><div class="line">&lt;book&gt;</div><div class="line">  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;</div><div class="line">  &lt;price&gt;39.95&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line"></div><div class="line">&lt;/bookstore&gt;</div></pre></td></tr></table></figure>
<p><strong>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</strong></p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>bookstore</td>
<td>选取 bookstore 元素的所有子节点。</td>
</tr>
<tr>
<td>/bookstore</td>
<td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td>bookstore/book</td>
<td>选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>
<tr>
<td>//book</td>
<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td>bookstore//book</td>
<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td>//@lang</td>
<td>选取名为 lang 的所有属性。</td>
</tr>
</tbody>
</table>
<h5 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h5><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。<br>谓语被嵌在方括号中。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/book[1]</td>
<td>选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()-1]</td>
<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[position()&lt;3]</td>
<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>
<tr>
<td>//title[@lang]</td>
<td>选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>
<tr>
<td>//title[@lang=’eng’</td>
<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00</td>
<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00]/title</td>
<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
</tbody>
</table>
<h5 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h5><p>XPath 通配符可用来选取未知的 XML 元素。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点。</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点。</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何类型的节点。</td>
</tr>
</tbody>
</table>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/*</td>
<td>选取 bookstore 元素的所有子元素。</td>
</tr>
<tr>
<td>//*</td>
<td>选取文档中的所有元素。</td>
</tr>
<tr>
<td>//title[@*]</td>
<td>选取所有带有属性的 title 元素。</td>
</tr>
</tbody>
</table>
<h5 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h5><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>//book/title</td>
<td>//book/price    选取 book 元素的所有 title 和 price 元素。</td>
</tr>
<tr>
<td>//title</td>
<td>//price    选取文档中的所有 title 和 price 元素。</td>
</tr>
<tr>
<td>/bookstore/book/title</td>
<td>//price    选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>
</tr>
</tbody>
</table>
<p>(以上关于节点的内容,转载自<a href="http://blog.csdn.net/ministarler/article/details/17561641" target="_blank" rel="external">Ministarler</a>,如有侵权请告知,本人将立刻删除)</p>
<h4 id="2-3-其实这个框架的使用非常简答-你要弄清楚的就是了解下面几个到底是意思"><a href="#2-3-其实这个框架的使用非常简答-你要弄清楚的就是了解下面几个到底是意思" class="headerlink" title="2.3 其实这个框架的使用非常简答,你要弄清楚的就是了解下面几个到底是意思:"></a>2.3 其实这个框架的使用非常简答,你要弄清楚的就是了解下面几个到底是意思:</h4><ul>
<li><strong>节点</strong></li>
<li><strong>节点属性</strong></li>
<li><strong>节点属性值</strong></li>
<li><strong>节点的内容</strong></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/swift-中异常处理do-catch的简单理解/" itemprop="url">
                  swift 中异常处理do...catch的简单理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T13:19:47+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-使用枚举来设置错误值是很好的办法"><a href="#1-使用枚举来设置错误值是很好的办法" class="headerlink" title="1. 使用枚举来设置错误值是很好的办法"></a>1. 使用枚举来设置错误值是很好的办法</h4><p>使用如下办法来创建异常类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">enum NetWorkingError:Error &#123;</div><div class="line">    case NilString</div><div class="line">    case WithoutUrl</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-怎么去抛出异常"><a href="#2-怎么去抛出异常" class="headerlink" title="2. 怎么去抛出异常"></a>2. 怎么去抛出异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func getString(Str:String?) throws -&gt;String</div></pre></td></tr></table></figure>
<p>聪明的你,肯定一眼就能看明白,只想要在返回值前面写一个throws关键字就可以定义异常抛出了,其实感觉有点象以后oc中带一个error的参数.不过在swift中含有error的api几乎都改成了异常抛出了.<br>那么,如何使用呢?</p>
<p>我们只需在调用方法的时候使用do…catch就可以了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">			//如果无法处理该方法,则直接跳去catch里面</div><div class="line">         let s = try getString(Str: nil)</div><div class="line">         print(s)</div><div class="line">     &#125; catch &#123;</div><div class="line">         print(&quot;错误处理&quot;)</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>如果你觉得你已经做好了处理,肯定不会产生异常信息,可以使用<code>try!</code>,这种方法去解析,但一般不建议这样使用</p>
<pre><code>let str = try! getString(Str:&quot;abc&quot;)
</code></pre><h4 id="3-如果写入一个异常"><a href="#3-如果写入一个异常" class="headerlink" title="3. 如果写入一个异常?"></a>3. 如果写入一个异常?</h4><p>我们还没有说到异常是怎么抛出的,作为一种新的语言,swift还提供了优雅的方式来处理异常:<code>guard</code>,如果换成用语言来描述的话:条件成立的时候跳过else里面处理方式,所以有下面的写法:</p>
<pre><code>func getString(Str:String?) throws -&gt;String{

    guard let str = Str else {
        throw NetWorkingError.NilString
    }
    return &quot;........\(str)&quot;
}
</code></pre><p>这个时候就可以定义了异常的抛出了,swift也支持了 Pattern Matching 功能,是不是很像Java中的抛出?</p>
<p>所以,在代码中我们可以再作处理:</p>
<pre><code> func getString(Str:String?,Url:String?) throws -&gt;String{

    guard let str = Str else {
    //抛出一个异常
        throw NetWorkingError.NilString
    }

    guard let str = Url else {
    //抛出第二个异常
        throw NetWorkingError.WithoutUrl
    }

    return &quot;........\(str)&quot;
}
</code></pre><p>那么,我们在使用的时候就可以对异常进行二次捕抓:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try functionWillThrowError()</div><div class="line">    //</div><div class="line">  &#125; catch NetWorkingError.NilString &#123;</div><div class="line">    // deal with not exist</div><div class="line">  &#125; catch NetWorkingError.WithoutUrl &#123;</div><div class="line">    // deal with not exist</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结:"></a>4. 总结:</h4><ul>
<li>使用 ErrorType 的帮助建立你的异常类型</li>
<li>使用 throws 来声明异常，用 throw 来抛出异常</li>
<li>使用 do-catch 机制来获取和处理异常</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/13/Swift中-enum和Switch的应用/" itemprop="url">
                  Swift中 enum和Switch的应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-13T23:27:15+08:00" content="2016-02-13">
              2016-02-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###好处<br>其实在很多菜鸟中会忽视了枚举的好处,使用枚举最显而易见的好处是能让代码更加清晰,应用得最多的地方是选项在超过两项或两项以上的时候能让协同开发的小伙伴更加清晰.</p>
<p>###例子<br>我新建了一个dome,里面创建了一个计算器calculatorControl的类,而在它里面又定义了一个calculatroEnum的枚举,此时枚举让整个语义更加清晰.但让我觉得比较有兴趣的是在加减乘除以后,我还定义了一个求勾股定理斜边的powerWihtNum(Double),和其他枚举不同的是这个枚举可以接受一个开多少次方的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">enum calculatorEnum &#123;</div><div class="line">    case add</div><div class="line">    case sub</div><div class="line">    case div</div><div class="line">    case mul</div><div class="line">    case powerWihtNum(Double)</div><div class="line">    private func calculatorForResult(x:Double,y:Double)-&gt;Double?&#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .add:</div><div class="line">            return x + y;</div><div class="line">        case .sub:</div><div class="line">            return x - y;</div><div class="line">        case .div:</div><div class="line">            return x / y;</div><div class="line">        case .mul:</div><div class="line">            return x * y;</div><div class="line">        case .powerWihtNum(let i):</div><div class="line">            return pow(x, i) + pow(y, i);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CalculatorControl: NSObject &#123;</div><div class="line"></div><div class="line">    convenience  init(x:Double,y:Double,n:Double?,WihtPath path:calculatorEnum) &#123;</div><div class="line">        self.init();</div><div class="line">        </div><div class="line">        print(&quot;输出的结果是\(path.calculatorForResult(x, y: y))&quot;);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">```   </div><div class="line"></div><div class="line">如果在控制中调用该类,则能打印出相应的值.</div></pre></td></tr></table></figure>
<p>   override func viewDidLoad() {<br>        super.viewDidLoad()<br>        CalculatorControl.init(x: 3, y: 4, n: nil, WihtPath: calculatorEnum.powerWihtNum(2))<br>    }<br>//打印台输出:输出的结果是<em>**</em>Optional(25.0)</p>
<p>```</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/13/swift中动态获得类型/" itemprop="url">
                  swift中动态获得类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-13T20:29:53+08:00" content="2015-12-13">
              2015-12-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>在100个swift 的tips中无意中看到一直不懂的如何动态获得swift中类的类型。</strong><br>原来在swift中有一个关键字是可以动态获得类的类型的：dynamicType。<br>借用书上的例子就是使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let date = NSDate()</div><div class="line">let nameType: AnyClass! = object_getClass(date)</div><div class="line">print(nameType)获得</div><div class="line"></div><div class="line">let data = NSData()</div><div class="line">let nameType = data.dynamicType</div><div class="line">print(nameType)获得</div></pre></td></tr></table></figure>
<p>swift中的类型如String也一样可以使用，另外我还发现原来在swift中即使没有导入runtime的头文件，也可以直接调用runtime.h的类方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/13/NSEnumerator遍历/" itemprop="url">
                  NSEnumerator遍历
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-13T23:26:00+08:00" content="2015-08-13">
              2015-08-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在无意中看到MBProgressHUD源码解析中有这么一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)HUDForView:(UIView *)view &#123; </div><div class="line">    NSEnumerator *subviewsEnum = [view.subviews    reverseObjectEnumerator];</div><div class="line">    for (UIView *subview in subviewsEnum) &#123; </div><div class="line">    if ([subview isKindOfClass:self]) &#123; return (MBProgressHUD *)subview; &#125; &#125; </div><div class="line">    return nil;&#125;</div></pre></td></tr></table></figure>
<p>我感觉对NSEnumerator算是比较陌生吧,然后查了一下,应该算是效能较高的一种遍历NSArray的方式,直接测试了一下,由于简单测试功能,速度方面感觉无明显效果.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    NSMutableArray&lt;NSString *&gt;* arr =  [NSMutableArray array];</div><div class="line">    arr[0] = @&quot;0&quot;;</div><div class="line">    arr[1] = @&quot;1&quot;;</div><div class="line">    arr[2] = @&quot;2&quot;;</div><div class="line">    arr[3] = @&quot;3&quot;;</div><div class="line">    arr[4] = @&quot;4&quot;;</div><div class="line">    </div><div class="line">    NSEnumerator* arrEnum =  [arr objectEnumerator];</div><div class="line">    id object;</div><div class="line">    while (object = [arrEnum nextObject]) &#123;</div><div class="line">        NSLog(object);</div><div class="line">操作</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实际上,调用了objectEnumerator方法的时候,返回的是一个id类型的object,有时候在编译阶段还不知道具体是什么类的话,可以直接打印尝试一下,使用nextObject这个方法可以得到一个指针,要注意的是 使用这种方式遍历 遍历过程中不可以对数组进行增删操作 否则将会出现一些未知的错误</p>
<p>另外,我们最常用的循环方式还有</p>
<ul>
<li>使用for循环加 count 方法遍历<pre><code>int i = 0;for(i = 0; i &lt; [array count]; i++){ 
  [array objectAtIndex:i]
   操作
}
</code></pre></li>
<li>使用for in方式遍历<pre><code>for(NSString *str in array){ 
  操作
}
</code></pre></li>
</ul>
<p>另外:其实这个感觉跟Java中的类的遍历非常相似:</p>
<ul>
<li>Java中三种迭代是否能删除(由于本人正在学习Java,随便复习一下):<ul>
<li>普通for循环,可以删除,但是索引要–</li>
<li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li>
<li>增强for循环不能删除</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://wuzhi.me/avatar/112063.1460211687.jpg"
               alt="shiron" />
          <p class="site-author-name" itemprop="name">shiron</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shiron</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
