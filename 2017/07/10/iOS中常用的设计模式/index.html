<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      iOS中常用的设计模式 | shiron 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="shiron">
    
    

    <meta name="description" content="iOS设计模式前言
可能我们在很多编写代码的时候都没有留意,其实设计模式无处不在,iOS中经典的模式我们都耳熟能详,例如单例模式,工厂模式等等,设计模式可以优化框架的维护性,也可以使得程序在迭代的过程中更便于扩展,设计模式听上去距离我们很远.
但事实上却距离我们很近,在最初学习iOS的过程中,并没有什么需要扩展程序的概念,但是在后期加入工作当中的时候才明白,很多需要并不是一下子就能确定下来的,而是">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中常用的设计模式 | shiron">
<meta property="og:url" content="http://yoursite.com/2017/07/10/iOS中常用的设计模式/index.html">
<meta property="og:site_name" content="shiron">
<meta property="og:description" content="iOS设计模式前言
可能我们在很多编写代码的时候都没有留意,其实设计模式无处不在,iOS中经典的模式我们都耳熟能详,例如单例模式,工厂模式等等,设计模式可以优化框架的维护性,也可以使得程序在迭代的过程中更便于扩展,设计模式听上去距离我们很远.
但事实上却距离我们很近,在最初学习iOS的过程中,并没有什么需要扩展程序的概念,但是在后期加入工作当中的时候才明白,很多需要并不是一下子就能确定下来的,而是">
<meta property="og:updated_time" content="2017-07-10T09:16:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中常用的设计模式 | shiron">
<meta name="twitter:description" content="iOS设计模式前言
可能我们在很多编写代码的时候都没有留意,其实设计模式无处不在,iOS中经典的模式我们都耳熟能详,例如单例模式,工厂模式等等,设计模式可以优化框架的维护性,也可以使得程序在迭代的过程中更便于扩展,设计模式听上去距离我们很远.
但事实上却距离我们很近,在最初学习iOS的过程中,并没有什么需要扩展程序的概念,但是在后期加入工作当中的时候才明白,很多需要并不是一下子就能确定下来的,而是">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">shiron</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">iOS中常用的设计模式</h1>

    

    <div class="post-meta">
      <time datetime="2017-07-10" class="post-meta__date date">2017-07-10</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h1 id="iOS设计模式"><a href="#iOS设计模式" class="headerlink" title="iOS设计模式"></a>iOS设计模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>可能我们在很多编写代码的时候都没有留意,其实设计模式无处不在,iOS中经典的模式我们都耳熟能详,例如单例模式,工厂模式等等,设计模式可以优化框架的维护性,也可以使得程序在迭代的过程中更便于扩展,设计模式听上去距离我们很远.</li>
<li><p>但事实上却距离我们很近,在最初学习iOS的过程中,并没有什么需要扩展程序的概念,但是在后期加入工作当中的时候才明白,很多需要并不是一下子就能确定下来的,而是在交流和沟通的过程中不断修改的.而我们在学习编程的过程中,为了避免重复编码,复制黏贴这样的毛病,在设计界面,理念,逻辑的时候要考虑好程序的健壮性,思考才是提升能力的关键,既然能打开网络的世界,浏览不同的最新资讯,想必大家也是非常好学和乐意提高自己的编程水平的.</p>
</li>
<li><p>写下这篇文章主要是记录下自己学习过程中的一些心得吧,之前看到设计模式庞大的家族有点被震住,感觉并不是每种设计模式都要生搬硬套到自己的项目当中,判断设计模式对当前系统是否有帮助才是最重要的,每种设计模式都有自己的优点和不足之处,所以在编程的过程中还请大家更多的思考.</p>
</li>
<li><p>本人在学习的过程中主要是参考了 <strong>[大话设计模式]</strong>,虽然语言是Java写的,但是在阅读的过程中也有很多收获,Java作为一门古老而健壮的语言已经很很长历史了,所以设计模式在Java中可能更为体系,而iOS中我看过一本名为<strong>[Objective-C编程之道：IOS设计模式解析]</strong>,感觉里面的内容更为切合与贴近iOS的程序开发,感谢作者的总结和分享,我也希望大家能亲自去阅读这两本书,能够直接在里面获得更深刻的体会和认识.</p>
</li>
<li><p>我认为好书要多读几遍才能深刻理解,常翻常新,这里是本人的初读体会,但随着时间的推移,也会及时更新本人对设计模式的理解和感悟,谢谢</p>
</li>
</ul>
<h2 id="一-简单工厂模式"><a href="#一-简单工厂模式" class="headerlink" title="一. 简单工厂模式"></a>一. 简单工厂模式</h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>简单工厂模式（Simple Factory Pattern）</strong>属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>工厂模式大家都非常熟悉,也可以写出结构优良的工厂模式代码,所以这里就简单的举例说明即可.</p>
<h4 id="2-模式"><a href="#2-模式" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>假设现在有一家工厂在生产手机,但是手机的类型暂时还不确定,等到用户需求确定了,再决定扩大某条生产线来生产手机,该工厂主要有两种产品:Android和IPhone;</p>
<h5 id="SMMobilePhone-h"><a href="#SMMobilePhone-h" class="headerlink" title="SMMobilePhone.h"></a>SMMobilePhone.h</h5><ul>
<li>主要就是一个useCall方法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">//手机基类</div><div class="line">@interface SMMobilePhone : NSObject</div><div class="line">-(void)useCall;</div><div class="line">@end</div><div class="line">//苹果,继承手机基类</div><div class="line">@interface SMIPhone : SMMobilePhone</div><div class="line">@end</div><div class="line">//安卓,继承手机基类</div><div class="line">@interface SMAndroid : SMMobilePhone</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="SMMobilePhone-m"><a href="#SMMobilePhone-m" class="headerlink" title="SMMobilePhone.m"></a>SMMobilePhone.m</h5><ul>
<li>类的初始化和方法的实现,没啥好解析的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &quot;SMMobilePhone.h&quot;</div><div class="line"></div><div class="line">@implementation SMMobilePhone</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@类初始化中&quot;,self.class);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(void)useCall&#123;</div><div class="line">    NSLog(@&quot;使用%@,呼叫10086中...&quot;,self.class);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">@implementation SMIPhone</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SMAndroid</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来为了使用用户的不同需求,我们对建立了一个工厂模式,用户需要什么类型的手机,只有下单了,我们都可以直接生产成型:</p>
<h5 id="SMFactoryImpl-h"><a href="#SMFactoryImpl-h" class="headerlink" title="SMFactoryImpl.h"></a>SMFactoryImpl.h</h5><ul>
<li>提供类方法返回手机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;SMMobilePhone.h&quot;</div><div class="line">//选择生产什么手机</div><div class="line">typedef enum : NSInteger&#123;</div><div class="line">    IPhone,</div><div class="line">    Android,</div><div class="line">&#125;IPhoneType;</div><div class="line"></div><div class="line">@protocol SMFactory &lt;NSObject&gt;</div><div class="line">//提供类方法直接返回手机</div><div class="line">+(SMMobilePhone*)creatMobileWithType:(IPhoneType)type;</div><div class="line">@end</div><div class="line">@interface SMFactoryImpl : NSObject&lt;SMFactory&gt;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="SMFactoryImpl-m"><a href="#SMFactoryImpl-m" class="headerlink" title="SMFactoryImpl.m"></a>SMFactoryImpl.m</h5><ul>
<li>利用枚举判断手机类型,实例化手机类(此处可以继续添加不同种类的手机)</li>
<li>利用了类的多态形式,返回值是父类,工厂生产出来的是子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;SMFactoryImpl.h&quot;</div><div class="line">@implementation SMFactoryImpl</div><div class="line"></div><div class="line"></div><div class="line">+(SMMobilePhone *)creatMobileWithType:(IPhoneType)type&#123;</div><div class="line">    </div><div class="line">    switch (type) &#123;</div><div class="line">        case IPhone:</div><div class="line">            return [[SMIPhone alloc]init];</div><div class="line">            break;</div><div class="line">        case Android:</div><div class="line">            return [[SMAndroid alloc]init];</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Test.m</p>
<ul>
<li>代码测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    SMMobilePhone * iphone = [SMFactoryImpl creatFactoryWithType:IPhone];</div><div class="line">    SMMobilePhone * android = [SMFactoryImpl creatFactoryWithType:Android];</div><div class="line">    [iphone useCall];</div><div class="line">    [android useCall];</div><div class="line"></div><div class="line">//打印结果</div><div class="line">//Design4OC[3636:398753] SMIPhone类初始化中</div><div class="line">//Design4OC[3636:398753] SMAndroid类初始化中</div><div class="line">//Design4OC[3636:398753] 使用SMIPhone,呼叫10086中...</div><div class="line">//Design4OC[3636:398753] 使用SMAndroid,呼叫10086中...</div></pre></td></tr></table></figure>
<h4 id="3-用途"><a href="#3-用途" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><p>工厂模式的用途非常广泛,可以基于面向对象的三大特性达到不同的效果,比如复杂类的构建过程(封装),父类指针可以指向子类对象(多态),也可以减低业务之间的耦合度.</p>
<h2 id="二-策略模式"><a href="#二-策略模式" class="headerlink" title="二.策略模式"></a>二.策略模式</h2><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>策略模式(Strategy)</strong> : 它定义了算法家族,分别封装起来,让它们之间可以<strong>相互替换</strong>,此模式让算法的改变,不会影响到算法的客户端.</p>
<p>用通俗一点的话来说,就是更改算法,不需要大量改动客户端内容.</p>
<h4 id="2-模式-1"><a href="#2-模式-1" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>比如现在商场是按原价将货物售出,但是遇到周年庆,老板打算让所有商品都按9.5折出售,这个业务很简单,只需要在代码上乘以一个系数就可以了(此时已经修改了客户端源码,有不妥之处).</p>
<p>过了一段时间以后,老板大婚,决定让商场里面的所有货物都打8.0出售,此时是不是我们又要去修改代码才能改变折扣呢?</p>
<p>…为了将临近过期的货物进口售出,此时老板决定临近过期的商品3.0折出售,另外,如果客户买满300减免100元.在业务不断变化的情况下,如果要经常修改源码才能满足业务需求的话,那可能要思考一下是否要改变一下代码的构造.</p>
<p>我们引入一个更为简单的例子来引入策略模式.</p>
<p>我们熟悉的钢铁侠既能在陆地急速奔跑,也能在水中潜行,更不要说在天空自由飞翔了,那么,每次切换不同模式,我们都可以理解为有一套最优的策略(算法)来适应陆地,海水和天空.</p>
<p>我们先定义个接口类来统一方法的调用:</p>
<h5 id="IStrategy-h"><a href="#IStrategy-h" class="headerlink" title="IStrategy.h"></a>IStrategy.h</h5><ul>
<li>operate含有相关操作 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol IStrategy &lt;NSObject&gt;</div><div class="line">-(void)operate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="STContext-h"><a href="#STContext-h" class="headerlink" title="STContext.h"></a>STContext.h</h5><ul>
<li>上下文,用来对策略(算法)的引用,使用初始化方法initWithIstragty赋值id<istrategy>引用</istrategy></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STContext : NSObject&lt;IStrategy&gt;</div><div class="line">+(instancetype)initWithIstragty:(id&lt;IStrategy&gt;)iStrategy;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="STContext-m"><a href="#STContext-m" class="headerlink" title="STContext.m"></a>STContext.m</h5><ul>
<li>此处只要实现了算法接口的类都可以当做实现类id传入,内部获取到id的引用以后,直接调用同名方法operate,内部再调用id的operate方法,直到现在,STContext不需要管id的实现,主要对接口调用即可.(可以慢慢体会面向接口编程的好处.)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;STContext.h&quot;</div><div class="line">@interface STContext()</div><div class="line">@property (nonatomic , strong ) STContext *impl;</div><div class="line">@end</div><div class="line">@implementation STContext</div><div class="line"></div><div class="line">+(instancetype)initWithIstragty:(id&lt;IStrategy&gt;)iStrategy&#123;</div><div class="line">    STContext * i =  [[STContext alloc] init];</div><div class="line">    i.impl = iStrategy;</div><div class="line">    return i;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)operate&#123;</div><div class="line">    </div><div class="line">    [self.impl operate];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后有三个实现了IStrategy接口的类,分别是:<strong>STFly</strong>,<strong>STSwimming</strong>,<strong>STSwimming</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STFly : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div><div class="line">--------------------</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STSwimming : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div><div class="line">--------------------</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STRunning : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="m"><a href="#m" class="headerlink" title=".m"></a>.m</h5><ul>
<li>此处是各个.m文件对接口的实现,对号入座即可.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)operate&#123;</div><div class="line">    NSLog(@&quot;启动飞行模式&quot;);//fly</div><div class="line">    NSLog(@&quot;启动游泳模式&quot;);//swimming</div><div class="line">    NSLog(@&quot;启动奔跑模式&quot;);//running</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Test-m"><a href="#Test-m" class="headerlink" title="Test.m"></a>Test.m</h5><ul>
<li>此时你可以发现,主要简单的修改类,即可完全改变算法,切换成奔跑模式,飞行模式,潜行模式等</li>
<li>再如一开始商场的例子,虽然可能会写多一些类,但是主要给UI加上一个选择器变可以直接改变定价策略,修改价格和优惠</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//此处的STFly可以替换成Swimming或者Running</div><div class="line">   STContext * is = [STContext initWithIstragty:[[STFly alloc]init]];</div><div class="line">   NSLog(@&quot;%@&quot;,is);</div><div class="line">   [is operate];</div></pre></td></tr></table></figure>
<h4 id="3-用途-1"><a href="#3-用途-1" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><ol>
<li>策略模式可以用来定义一系列是算法,对外提供的接口是相同的,只是改变了内部的实现即产生了不同的效果,核心作用就是用于封装算法</li>
<li>原本我们可以将所有操作封装在一个类里面,每次增加策略就需要在里面增加<code>if else</code>或者<code>switch</code>语句,但是你会发现这样耦合度很高,不方便单个算法的测试–从而也引出了策略模式的另外一个好处:简单化了单元测试,每一个算法就是一个</li>
<li>个人感觉这里算是一个面向对象特性的一个思想提升–运用了协议来统一工作方式,实质上这三个类是三个独立的存在的类,并没有规定统一父类,他们都有着自己的模式和算法.但我的思想暂时还没提高到策略模式的算法层面,只能暂时理解为解决问题的一种策略模式,可能还有偏颇!</li>
</ol>
<h2 id="三-装饰模式"><a href="#三-装饰模式" class="headerlink" title="三.装饰模式"></a>三.装饰模式</h2><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>装饰模式(Decorate)</strong>,动态地给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成之类更为灵活</p>
<h4 id="2-模式-2"><a href="#2-模式-2" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>如何理解装饰呢?比如说人身上的衣服,鞋子,裤子,帽子都是人身上装饰物品,没有装饰物的人依然有着能自由活动,吃饭,睡觉的基础功能.</p>
<p>再比如我们生活中常见的汽车,我们知道有低配版和高配版之分,只要价格给上去了,很多额外的装饰物都可以给你添上比如普通大灯换为疝气灯,普通沙发换成真皮沙发等等…首先可以理解为为某个类增加功能(增加特殊功能但不改变原有的类)<br>我们举一个简单的例子来说明一下,<br>首先我们有个组装的协议<br>DEComponent.h</p>
<ul>
<li>该协议里面含有一个operation的基础操作方法,类比汽车的时候可以理解为:即使我没有真皮沙发,没有疝气大灯,依然可以执行最基础的行驶功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol DEComponent &lt;NSObject&gt;</div><div class="line">-(void)operation;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DEBaseCar-h"><a href="#DEBaseCar-h" class="headerlink" title="DEBaseCar.h"></a>DEBaseCar.h</h5><ul>
<li>然后,我们以车为例子,当然需要有一个车的实例,该类遵守了协议,里面有operation方法</li>
<li>baseCar独立存在,可以不知道有其他装饰类的存在,不影响最基础的工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;DEComponent.h&quot;</div><div class="line">@interface DEBaseCar : NSObject&lt;DEComponent&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DEBaseCar-m"><a href="#DEBaseCar-m" class="headerlink" title="DEBaseCar.m"></a>DEBaseCar.m</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &quot;DEBaseCar.h&quot;</div><div class="line"></div><div class="line">@implementation DEBaseCar</div><div class="line">-(void)operation&#123;</div><div class="line">    NSLog(@&quot;最基本的车,具备了安全行驶功能&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>以上功能,我们就具备了一辆最基础的车,但是现在这里车没有满足你的要求,你想要加装一些零部件,这个时候就有了新的需求</p>
<h5 id="DECarComponent-h"><a href="#DECarComponent-h" class="headerlink" title="DECarComponent.h"></a>DECarComponent.h</h5><ul>
<li>DECarDecorator是装饰者类,它定义了<strong>extraComponentOn:</strong>方法用来增强baseCar的功能,也对对象进行了包装,从而实现了每个装饰者类都可以有自己独特的功能(这样的结构会使得功能相互独立开来,有了很好的扩展),并在有需要的时候增强baseCar功能实现</li>
<li>DECarDecorator它可以是抽象基类,也可以是单个装饰者类</li>
<li>DESofaDecorator,DELightDecorator,DEDogDecorator作为装饰者类的子类,都有着自己独特的方法和属性</li>
<li>DESofaDecorator作为普通类,只给车辆换上沙发</li>
<li>DELightDecorator给汽车赋予了新亮度,有远光和近光的功能实现(装饰后拥有的独特方法)</li>
<li>DEDogDecorator香车洋狗和美女都是配在一起的,而狗可以有自己的名字(其他类不会有狗,狗也不会有名字)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;DEComponent.h&quot;</div><div class="line">@interface DECarDecorator : NSObject&lt;DEComponent&gt;</div><div class="line">@property (nonatomic , strong ,setter=extraComponentOn:) id&lt;DEComponent&gt; component;</div><div class="line">@end</div><div class="line"></div><div class="line">/*------------------作为装饰汽车的沙发(不含参数和方法)--------------------*/</div><div class="line">@interface DESofaDecorator : DECarDecorator</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的疝气灯(含私有方法)--------------------*/</div><div class="line">@interface DELightDecorator : DECarDecorator</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的养狗(含公有属性)--------------------*/</div><div class="line">@interface DEDogDecorator : DECarDecorator</div><div class="line">@property (nonatomic , strong ) NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DECarComponent-m"><a href="#DECarComponent-m" class="headerlink" title="DECarComponent.m"></a>DECarComponent.m</h5><ul>
<li>类的属性和方法已经在上面简要说明,可以忽略这部分不看.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;DECarDecorator.h&quot;</div><div class="line"></div><div class="line">@implementation DECarDecorator</div><div class="line"></div><div class="line">-(void)extraComponentOn:(id&lt;DEComponent&gt;)component&#123;</div><div class="line">    _component = component;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)operation&#123;</div><div class="line">    if (self.component != nil) &#123;</div><div class="line">        [self.component operation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">/*------------------作为装饰汽车的沙发(不含参数和方法)--------------------*/</div><div class="line">@implementation DESofaDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    NSLog(@&quot;高配版要的就是豪华沙发...&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的沙发(含私有方法)--------------------*/</div><div class="line">//远光近光</div><div class="line">typedef enum : NSUInteger &#123;</div><div class="line">    HighLight,</div><div class="line">    LowLitght</div><div class="line">&#125; LightType;</div><div class="line"></div><div class="line">@implementation DELightDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    NSLog(@&quot;装饰了疝气灯以后可以开启照明功能&quot;);</div><div class="line">    </div><div class="line">    [self openLight:arc4random()%2];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)openLight:(LightType)ligthType&#123;</div><div class="line">    switch (ligthType) &#123;</div><div class="line">        case HighLight:</div><div class="line">            NSLog(@&quot;开启了远光灯&quot;);</div><div class="line">            break;</div><div class="line">        case LowLitght:</div><div class="line">            NSLog(@&quot;开启了近光灯&quot;);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的养狗(含公有属性)--------------------*/</div><div class="line">@implementation DEDogDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    if (self.name ==nil) &#123;</div><div class="line">        NSLog(@&quot;刚刚捡回来的小狗没有名字&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;%@,跟大家打招呼吧!&quot;,self.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="Test-m-1"><a href="#Test-m-1" class="headerlink" title="Test.m"></a>Test.m</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;---最新出厂---&quot;);</div><div class="line">DEBaseCar * car = [[DEBaseCar alloc] init];</div><div class="line">NSLog(@&quot;---把沙发,疝气灯,狗搬到装配车间---&quot;);</div><div class="line">DESofaDecorator * sofaDecorator = [[DESofaDecorator alloc] init];</div><div class="line">DELightDecorator * lightDecorator = [[DELightDecorator alloc] init];</div><div class="line">DEDogDecorator * dogDecorator = [[DEDogDecorator alloc] init];</div><div class="line">//设置狗的名字</div><div class="line">[dogDecorator setName:@&quot;旺财&quot;];</div><div class="line">NSLog(@&quot;开始装饰,将需要的东西组装到车上&quot;);</div><div class="line">[sofaDecorator extraComponentOn:car];</div><div class="line">[lightDecorator extraComponentOn:sofaDecorator];</div><div class="line">[dogDecorator extraComponentOn:lightDecorator];</div><div class="line">NSLog(@&quot;---------------------&quot;);</div><div class="line">[dogDecorator operation];</div><div class="line">//打印结果</div><div class="line">//Design4OC[8316:763030] ---最新出厂---</div><div class="line">//Design4OC[8316:763030] ---把沙发,疝气灯,狗搬到装配车间---</div><div class="line">//Design4OC[8316:763030] 开始装饰,将需要的东西组装到车上</div><div class="line">//Design4OC[8316:763030] ---------------------</div><div class="line">//Design4OC[8316:763030] 最基本的车,具备了安全行驶功能</div><div class="line">//Design4OC[8316:763030] 高配版要的就是豪华沙发...</div><div class="line">//Design4OC[8316:763030] 装饰了疝气灯以后可以开启照明功能</div><div class="line">//Design4OC[8316:763030] 开启了近光灯</div></pre></td></tr></table></figure>
<h4 id="3-用途-2"><a href="#3-用途-2" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><ol>
<li>装饰者模式可以理解为在一个基础的类上,增强或增加某些功能的实现,大家在维护老代码的时候不一定方便直接修改源码(当增强的功能并不常用,这个时候其实不应该直接修改源码,额外的增加了这个类的职责和负担,违背了职责单一的原则)</li>
<li>把核心功能和其他功能区分开,方便拆装和管理</li>
<li>个人感觉,使用分类也能增加类的实现,在不导入分类的头文件时,其实类的功能也没有加载进来,也像是一种装饰者的特殊实现吧,以后有更多的体会再来更改现在的想法</li>
</ol>
<h2 id="四-工厂方法模式"><a href="#四-工厂方法模式" class="headerlink" title="四.工厂方法模式"></a>四.工厂方法模式</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>工厂方法模式(Factory Method)</strong>:定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使得一个类的实例化延迟到其子类.</p>
<h4 id="2-模式-3"><a href="#2-模式-3" class="headerlink" title="2. 模式"></a>2. 模式</h4><p>为何前面有说一个简单工厂模式,现在又来一个工厂方法模式?看到定义估计还比较模模糊糊,实际上工厂模式是简单工厂模式的抽象和推广.</p>
<p>简单工厂模式是在内部case判断返回什么内容给控制器,同一个工厂可以生产不同的产品,而如果需要修改产品的类型,就需要重新在内部部署生产设备,在工厂内部协调工作</p>
<p>而工厂模式是在控制器就选择好了要生成什么类型的类,不同的工厂生产不同的产品,每个工厂都有自己独特的产品,接到指令时不需要在内部协调就可以直接生产产品.先上代码:</p>
<h5 id="FMMobilePhoneFactory-h"><a href="#FMMobilePhoneFactory-h" class="headerlink" title="FMMobilePhoneFactory.h"></a>FMMobilePhoneFactory.h</h5><ul>
<li>FMFactoryProtocol: 是工厂模式的抽象接口,使子类有一个实例化方法</li>
<li>FMMobilePhoneFactory:作为工厂基类,其他的工厂类应该继承该父类</li>
<li>FMIPhoneFactory和FMAndroidFactory: 父类是FMMobilePhoneFactory,使用协议方法的时候可以实例化具体的产品</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line">@class FMMobilePhoneFactory;</div><div class="line"></div><div class="line">//</div><div class="line">@protocol FMFactoryProtocol&lt;NSObject&gt;</div><div class="line">-(FMMobilePhone*)creatFactory;</div><div class="line">@end</div><div class="line">//工厂基类</div><div class="line">@interface FMMobilePhoneFactory : NSObject&lt;FMFactoryProtocol&gt;</div><div class="line"></div><div class="line">@end</div><div class="line">//苹果工厂,继承工厂基类</div><div class="line">@interface FMIPhoneFactory : FMMobilePhoneFactory</div><div class="line">@end</div><div class="line">//安卓工厂,继承工厂基类</div><div class="line">@interface FMAndroidFactory : FMMobilePhoneFactory</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="FMMobilePhoneFactory-m"><a href="#FMMobilePhoneFactory-m" class="headerlink" title="FMMobilePhoneFactory.m"></a>FMMobilePhoneFactory.m</h5><ul>
<li>不同的工厂生产不同的产品,基类不可直接使用,这里不再做判断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &quot;FMMobilePhoneFactory.h&quot;</div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line">@implementation FMMobilePhoneFactory</div><div class="line"></div><div class="line">-(FMMobilePhone*)creatFactory&#123;</div><div class="line">    return [[FMMobilePhone alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">@implementation FMIPhoneFactory</div><div class="line">-(FMMobilePhone *)creatFactory&#123;</div><div class="line">    return [[FMIPhone alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FMAndroidFactory</div><div class="line">-(FMMobilePhone *)creatFactory&#123;</div><div class="line">    return [[FMAndroid alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="FMMobilePhone-h"><a href="#FMMobilePhone-h" class="headerlink" title="FMMobilePhone.h"></a>FMMobilePhone.h</h5><h5 id="FMMobilePhone-m"><a href="#FMMobilePhone-m" class="headerlink" title="FMMobilePhone.m"></a>FMMobilePhone.m</h5><ul>
<li>产品类在简单工厂模式的时候已经讲过了,也比较简单,自己可以看看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface FMMobilePhone : NSObject</div><div class="line">-(void)useCall;</div><div class="line">@end</div><div class="line">//苹果,继承手机基类</div><div class="line">@interface FMIPhone : FMMobilePhone</div><div class="line">@end</div><div class="line">//安卓,继承手机基类</div><div class="line">@interface FMAndroid : FMMobilePhone</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//-------------.m------------------</div><div class="line"></div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line"></div><div class="line">@implementation FMMobilePhone</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@类初始化中&quot;,self.class);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(void)useCall&#123;</div><div class="line">    NSLog(@&quot;使用%@,呼叫10086中...&quot;,self.class);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FMIPhone@end</div><div class="line"></div><div class="line">@implementation FMAndroid@end</div></pre></td></tr></table></figure>
<h5 id="Test-m-2"><a href="#Test-m-2" class="headerlink" title="Test.m"></a>Test.m</h5><ul>
<li>下面是控制器的调用,我们可以看到,其实两台代码完全相同,就只是在实例化工厂的时候选择了FMIPhoneFactory和FMAndroidFactory就可以改变产品的产品,避免了产品增多的时候要修改工厂类(实际上是违背了封闭-开放原则)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FMMobilePhoneFactory * iphoneFactory = [[FMIPhoneFactory alloc]init];</div><div class="line">  FMMobilePhone * iphone = [iphoneFactory creatFactory];</div><div class="line">  [iphone useCall];</div><div class="line">  </div><div class="line">  FMMobilePhoneFactory * andoridFactory = [[FMAndroidFactory alloc]init];</div><div class="line">  FMMobilePhone * andorid = [andoridFactory creatFactory];</div><div class="line">  [andorid useCall];</div><div class="line">  </div><div class="line">   //FMIPhone类初始化中</div><div class="line">   //使用FMIPhone,呼叫10086中...</div><div class="line">   //FMAndroid类初始化中</div><div class="line">   //使用FMAndroid,呼叫10086中...</div></pre></td></tr></table></figure>
<h4 id="3-用途-3"><a href="#3-用途-3" class="headerlink" title="3.用途"></a>3.用途</h4><ol>
<li>实际上是简单工厂模式的抽象和推广,克服了简单工厂模式违背了封闭-开放原则,又保持了封装对象的优点</li>
<li>把从工厂的内部判断移动到了控制器,产生子类的选择更加灵活</li>
<li>个人感觉,一直都习惯了在工厂类中做了条件判断来生产不同的产品类,而且每产生多一个产品就要多一个工厂类和产品类,工作量有所增加,如果能用运行时来产生不同的子类更好</li>
</ol>
<h2 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五.原型模式"></a>五.原型模式</h2><h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>原型模式(Prototype)</strong>:用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象.</p>
<h4 id="2-模式-4"><a href="#2-模式-4" class="headerlink" title="2.模式"></a>2.模式</h4><p>其实这篇文章就是要说明<strong>复制</strong>这个概念,网上也很多文章无数次分析深拷贝和浅拷贝了,这里就不在详细说明深拷贝和浅拷贝的内容了,深拷贝复制对象,浅拷贝复制引用地址.</p>
<p>现在来举例说明,我们有一个学生对象和书本对象,里面分别有如下属性:</p>
<p>PTStudent.h</p>
<ul>
<li>学生手中有一本书,直接拿在手上看的,属性为:book</li>
<li>书包里面有很多书,用<code>NSMutableArray&lt;PTBook*&gt;</code> 存储</li>
<li>学生还有名字和年龄两个属性</li>
<li>学生还有不同的老师,用字符串来表示<code>NSMutableArray&lt;NSString*&gt;</code>(也可以理解为老师只有一个,大家共享这个字符串的资源)</li>
</ul>
<h6 id="PTStudent-h"><a href="#PTStudent-h" class="headerlink" title="PTStudent.h"></a>PTStudent.h</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;PTBook.h&quot;</div><div class="line">@interface PTStudent : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic , strong ) PTBook *book;</div><div class="line">@property (nonatomic , strong ) NSString *name;</div><div class="line">@property (nonatomic , assign ) int age;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;NSString*&gt; *teachers;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;PTBook*&gt; *package;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTBook-h"><a href="#PTBook-h" class="headerlink" title="PTBook.h"></a>PTBook.h</h5><ul>
<li>书本有名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface PTBook : NSObject&lt;NSCopying&gt;</div><div class="line">@property (nonatomic , strong ) NSString *bookName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTBook-m"><a href="#PTBook-m" class="headerlink" title="PTBook.m"></a>PTBook.m</h5><ul>
<li><code>book.bookName = [NSString stringWithFormat:@&quot;%@&quot;,self.bookName];</code>这个是作为深复制存在,开辟了新的内存空间</li>
<li><code>book.bookName = [self.bookName copy];</code> 此时使用的是浅复制,共享常量字符串的内容,可以结合内存地址查看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#import &quot;PTBook.h&quot;</div><div class="line"></div><div class="line">@implementation PTBook</div><div class="line">-(id)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    </div><div class="line">     book.bookName = [NSString stringWithFormat:@&quot;%@&quot;,self.bookName];</div><div class="line">    /*</div><div class="line">     (lldb) p student.book.bookName</div><div class="line">     (__NSCFConstantString *) $0 = 0x00000001043616b0 @&quot;B&quot;</div><div class="line">     (lldb) p otherStudent.book.bookName</div><div class="line">     (NSTaggedPointerString *) $1 = 0xa000000000000421 @&quot;B&quot;</div><div class="line">     (lldb)</div><div class="line">     </div><div class="line">     </div><div class="line">     */</div><div class="line">    </div><div class="line">    </div><div class="line">//book.bookName = [self.bookName copy];</div><div class="line">    </div><div class="line">    /*</div><div class="line">     (lldb) p student.book.bookName</div><div class="line">     (__NSCFConstantString *) $0 = 0x00000001074466b0 @&quot;B&quot;</div><div class="line">     (lldb) p otherStudent.book.bookName</div><div class="line">     (__NSCFConstantString *) $1 = 0x00000001074466b0 @&quot;B&quot;</div><div class="line">     (lldb)</div><div class="line">     */</div><div class="line"></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTStudent-m"><a href="#PTStudent-m" class="headerlink" title="PTStudent.m"></a>PTStudent.m</h5><ul>
<li>常量字符串在常量区共享,也可以用字符串对象开辟新的内存空间</li>
<li>由于age是NSUInteger类型的，属于基本数据类型，则直接赋值</li>
<li>book对象遵守了NSCopying协议,里面已经处理,可以直接用copy方法深复制</li>
<li>teachers作为了常量字符串容器,里面的字符串是共享的,但是容器是作了深拷贝</li>
<li>package里面装有book对象,除了拿到新容器外,还需要把book存进容器里面,这个时候就可以使用遍历或者<code>copyItems:YES</code>这种方式(后来才找到有这个方法…)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#import &quot;PTStudent.h&quot;</div><div class="line">@interface PTStudent()</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation PTStudent</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        PTBook* book = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;新华字典&quot;;</div><div class="line">        </div><div class="line">        PTBook* bookA = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;A&quot;;</div><div class="line">        </div><div class="line">        PTBook* bookB = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;B&quot;;</div><div class="line">        </div><div class="line">        self.book = book;</div><div class="line">        self.name = @&quot;小明&quot;;</div><div class="line">        self.age = 18;</div><div class="line">        self.teachers = [NSMutableArray arrayWithObjects:@&quot;张飞&quot;,@&quot;刘备&quot;,@&quot;关羽&quot;, nil];</div><div class="line">        self.package=[NSMutableArray arrayWithObjects:bookA,bookB, nil];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(id)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    PTStudent* student = [[[self class] allocWithZone:zone]init];</div><div class="line">    student.age = self.age;</div><div class="line">    student.book = [self.book copy];</div><div class="line">    //这里会深复制,再开辟内存空间</div><div class="line">    student.name = [NSString stringWithFormat:@&quot;%@&quot;,self.name];</div><div class="line">    student.teachers = [NSMutableArray arrayWithArray:self.teachers];</div><div class="line">    //NSMutableArray&lt;PTBook*&gt; *package;</div><div class="line">    student.package = [NSMutableArray array];</div><div class="line">    </div><div class="line"> //原本是打算通过遍历的方法来深复制</div><div class="line">//    [self.package enumerateObjectsUsingBlock:^(PTBook * _Nonnull book, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">//        [student.package addObject:[book copy]];</div><div class="line">//    &#125;];</div><div class="line"></div><div class="line">    //后来发现一种不需要遍历的方法,如果你只需要数组中数组第一层的深拷贝,那么</div><div class="line">    student.package= [[NSMutableArray alloc] initWithArray:self.package copyItems:YES];</div><div class="line">    </div><div class="line">    </div><div class="line">    //这里是浅复制</div><div class="line">    //指向的是常量区</div><div class="line">    ////student.name = [self.name copy];</div><div class="line">    //此处数组可以复制,但是里面每一个元素的指针都是没有被复制的,和原来的类型指向同一内容</div><div class="line">    //student.teachers = [self.teachers mutableCopy];</div><div class="line">//    student.package = [NSMutableArray mutableCopy];</div><div class="line">    return student;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="3-用途-4"><a href="#3-用途-4" class="headerlink" title="3.用途"></a>3.用途</h4><ol>
<li>需要重复创建对象的时候可以考虑使用原型模式</li>
<li>原型模式也属于创建模式的一种,工厂模式会new一个全新的对象,使用原型模式就可以拷贝一份对象出来,工厂模式和原型模式其实效率差不多,但是如果在大量创建数据的时候,原型模式则更加节省资源,效率更高.</li>
</ol>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
