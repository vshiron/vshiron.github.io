<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiron</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-31T11:18:54.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在项目已初始化成功以后建立git仓库</title>
    <link href="http://yoursite.com/2016/10/31/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%8A%9F%E4%BB%A5%E5%90%8E%E5%BB%BA%E7%AB%8Bgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2016/10/31/如何在项目已初始化成功以后建立git仓库/</id>
    <published>2016-10-31T11:01:37.000Z</published>
    <updated>2016-10-31T11:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:<code>git@github.com:vshiron/html-css-js-dome.git</code></li>
<li>然后你就需要在本地创建一个文件,把你需要的东西先考进去吧,然后打开终端,cd进入你的目录:<code>cd /Users/vshiron/Desktop/html学习/jsdome</code></li>
<li>在该目录下使用git的初始化命令:<code>git init</code></li>
<li>以后的每一次增加目录里面的内容,都必须要用该命令来添加到本地仓库,用”.”是代表通配符,命令如下:<code>git add .</code>,成功后不会显示任何东西</li>
<li>然后就是提交代码的信息,修改了什么就顺便写上去,第一次初始化就可以写first啦:<code>git commit -m &quot;first commit&quot;</code><br>大概会显示下面内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[master (root-commit) 6ddc496] first commit</div><div class="line">2 files changed, 229 insertions(+)</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/.project&quot;</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/index.html&quot;</div></pre></td></tr></table></figure>
<ol>
<li><p>完事了以后,就要添加一个远程本地的仓库:<code>git remote add origin git@github.com:vshiron/html-css-js-dome.git</code>,完事后没有任何代码显示</p>
</li>
<li><p>接下来再输入另外一个代码,就是我们希望把代码推送到服务器上的命令:<code>git push origin master</code><br>这个时候会显示如下信息,他大概的意思是告诉你,推送代码时要养成拉代码合并的习惯~</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line"> ! [rejected]        master -&gt; master (fetch first)</div><div class="line">error: failed to push some refs to &apos;git@github.com:vshiron/html-css-js-dome.git&apos;</div><div class="line">hint: Updates were rejected because the remote contains work that you do</div><div class="line">hint: not have locally. This is usually caused by another repository pushing</div><div class="line">hint: to the same ref. You may want to first integrate the remote changes</div><div class="line">hint: (e.g., &apos;**git pull ...&apos;**) before pushing again.</div><div class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</div></pre></td></tr></table></figure>
<ol>
<li>那么,我们就先拉一下代码吧,运行命令:<code>git pull origin master</code>,拉完代码以后会显示下面信息:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">From github.com:vshiron/html-css-js-dome</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Merge made by the &apos;recursive&apos; strategy.</div><div class="line"> README.md | 2 ++</div><div class="line"> 1 file changed, 2 insertions(+)</div><div class="line"> create mode 100644 README.md</div></pre></td></tr></table></figure>
<ol>
<li>操作完成上面那一步的话,我们可以继续使用该命令:<code>git push origin master</code>,这个时候可能会让你输入相应的账号和密码,输入就是了~<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pushing to git@github.com:vshiron/html-css-js-dome.git</div><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line">   73c75b2..1907e5f  master -&gt; master</div><div class="line">updating local tracking ref &apos;refs/remotes/origin/master&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时候就已经完成项目的推送了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:&lt;code&gt;git@github.com:vshiron/html-css-js-dome.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后你就需要在本地创
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Controller间的自定义过渡效果</title>
    <link href="http://yoursite.com/2016/10/17/Controller%E9%97%B4%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2016/10/17/Controller间的自定义过渡效果/</id>
    <published>2016-10-17T10:58:48.000Z</published>
    <updated>2016-10-27T13:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">阅读原文</a>)</strong></p>
<blockquote>
<p>本篇文章主要讲的就是在学习了UIView的基础上,如何在学习UIViewController的自定义效果</p>
</blockquote>
<p>效果图如下:</p>
<ul>
<li>点击模态controller，会弹出一个新的绿色UIViewController，手指下滑可以dismiss这个controller</li>
<li>四个角的按钮可以自定义圆形切换的过渡效果切换的一个红色的UIViewController，点击返回用同样的方式切换回来</li>
</ul>
<p><a href="http://liuyanwei.jumppo.com/assets/uploads/ControllerTransitioning1.gif" target="_blank" rel="external"></a></p>
<h4 id="出场人物介绍"><a href="#出场人物介绍" class="headerlink" title="出场人物介绍"></a>出场人物介绍</h4><blockquote>
<p>介绍一下Controller过渡和交互用到的类</p>
</blockquote>
<h5 id="presention-and-presented"><a href="#presention-and-presented" class="headerlink" title="presention and presented"></a><code>presention and presented</code></h5><pre><code>A中模态显示B,那么A就是presention，b就是presented，后续内容会使用这种叫法称呼Modal下的2个controller
</code></pre><h5 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><code>UIViewControllerTransitioningDelegate</code></h5><pre><code>Controller modal过渡的presented和dismiss的动画交互协议，你需要实现协议，它会询问你：
</code></pre><ul>
<li>当PresentedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当DismissedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当PresentedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>当DismissedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
</ul>
<h5 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><code>UIViewControllerAnimatedTransitioning</code></h5><p>过渡动画效果的具体实现的接口，需要实现它的3个方法，即可完成一个controller过渡动画效果</p>
<ul>
<li><code>func animationEnded</code>：过渡动画完成后要执行的代码可以写到这个方法中</li>
<li><code>func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval</code>：给定一个过渡动画的执行时间</li>
<li><code>func animateTransition(transitionContext: UIViewControllerContextTransitioning)</code> ：具体过渡动画都在这个方法里面实现，在这个方法中可以通过transitionContext拿到一切你需要的对象，后面会有讲到</li>
</ul>
<h5 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><code>UINavigationControllerDelegate</code></h5><pre><code>Controller 非模态状态下的的过渡动画，就不能使用之前说的那个UIViewControllerTransitioningDelegate委托解决了，就需要用UINavigationControllerDelegate，接口方法比较类似，但也不完全一样
</code></pre><ul>
<li>你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>willShowViewController，didShowViewController ： 生命周期事件</li>
<li>navigationControllerSupportedInterfaceOrientations: 屏幕支持的方向</li>
</ul>
<h5 id="UIViewControllerInteractiveTransitioning"><a href="#UIViewControllerInteractiveTransitioning" class="headerlink" title="UIViewControllerInteractiveTransitioning"></a><code>UIViewControllerInteractiveTransitioning</code></h5><pre><code>这个类用于实现在转场过路效果中的交互，比如在demo中，用它实现了一个手指下滑解除modal状态的效果
</code></pre><h5 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><code>UIViewControllerContextTransitioning</code></h5><p>UIViewControllerAnimatedTransitioning协议的关键方法<code>animateTransition(transitionContext: UIViewControllerContextTransitioning)</code>里面可以得到，使用transitionContext可以获取一些重要的上下文信息，比如前后的controller，转换时的容器等，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //拿到过渡动画执行时间</div><div class="line">        transitionDuration(transitionContext)</div></pre></td></tr></table></figure>
<h4 id="Controller-modal过渡效果"><a href="#Controller-modal过渡效果" class="headerlink" title="Controller modal过渡效果"></a>Controller modal过渡效果</h4><p>我们先来实现一个简单的示例，点击一个按钮，出现一个modal controller，自定义从下往上弹出并且有些回弹效果的过渡动画。从这个例子中我们可以了解</p>
<ul>
<li>如何实现UIViewControllerTransitioningDelegate</li>
<li>如何实现UIViewControllerAnimatedTransitioning</li>
<li>如何组合在一起完成功能</li>
</ul>
<p>示例效果见demo点击后，弹出的绿色界</p>
<h5 id="步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己"><a href="#步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己" class="headerlink" title="步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己"></a><code>步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//模态视图切换效果</div><div class="line">   @IBAction func Transitioning2(sender: AnyObject) &#123;</div><div class="line">       let toVC = To2ViewController()</div><div class="line">       //设置transitioning委托为自己</div><div class="line">       toVC.transitioningDelegate = self</div><div class="line">       navigationController?.presentViewController(toVC, animated: true, completion: nil)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="步骤2：controller-实现-UIViewControllerTransitioningDelegate"><a href="#步骤2：controller-实现-UIViewControllerTransitioningDelegate" class="headerlink" title="步骤2：controller 实现 UIViewControllerTransitioningDelegate"></a>步骤2：<code>controller 实现 UIViewControllerTransitioningDelegate</code></h5><p>demo中使用了extension的方式继承UIViewControllerTransitioningDelegate，好处是代码逻辑分离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//模态视图切换效果</div><div class="line">extension ControllerTransitioningDemoViewController:UIViewControllerTransitioningDelegate&#123;</div><div class="line"></div><div class="line">    //返回Presented使用的UIViewControllerAnimatedTransitioning类</div><div class="line">    </div><div class="line">    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line">        return PresentedAnimation() // PresentedAnimation 是自定义的过渡动画效果的实现类，继承自UIViewControllerAnimatedTransitioning 步骤3中介绍它</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"><a href="#步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类" class="headerlink" title="步骤3: 实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"></a>步骤3: <code>实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类</code></h5><p>就如之前对UIViewControllerAnimatedTransitioning介绍的那样，需要继承自UIViewControllerAnimatedTransitioning，然后实现它的三个委托方法，具体实现请看代码注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">public class PresentedAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        //转场过渡动画的执行时间</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</div><div class="line">    //在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</div><div class="line">    public func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        //拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        //弹出的控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //获取屏幕宽高</div><div class="line">        let bounds = UIScreen.mainScreen().bounds</div><div class="line">        //设置弹出控制器的初始位置</div><div class="line">        toVC.view.frame = CGRectOffset(finalFrameForVC, 0, bounds.size.height)</div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //自下而上弹出toVC的动画</div><div class="line">        UIView.animateWithDuration(transitionDuration(transitionContext),</div><div class="line">                                    delay: 0.0,</div><div class="line">                                    usingSpringWithDamping: 0.7,</div><div class="line">                                    initialSpringVelocity: 0.0,</div><div class="line">                                    options: .CurveLinear,</div><div class="line">                                    animations: &#123;</div><div class="line">                                    //执行的动画</div><div class="line">                                    //原来的控制给透明度</div><div class="line">                                    fromVC.view.alpha = 0.5</div><div class="line">                                    //修改弹出控制的frame</div><div class="line">                                    toVC.view.frame = finalFrameForVC</div><div class="line">                                    &#125;, completion: &#123;</div><div class="line">                                        finished in</div><div class="line">                                        	//动画完成后执行</div><div class="line">                                        	transitionContext.completeTransition(true)</div><div class="line">                                        	</div><div class="line">                                        fromVC.view.alpha = 1.0</div><div class="line">                                    &#125;)</div><div class="line">         NSLog(&quot;animateTransition&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   &lt;!-- UIView.animateWithDuration(1.0, animations: &#123; </div><div class="line">            </div><div class="line">            toVC.view.frame = finalFrameForVC;</div><div class="line">            fromVC.view.alpha = 0.5</div><div class="line">            </div><div class="line">            &#125;) &#123; (isCompletion) in</div><div class="line">                transitionContext.completeTransition(true)</div><div class="line">                fromVC.view.alpha = 1.0</div><div class="line">        &#125;--&gt;</div><div class="line"></div><div class="line"></div><div class="line">    //执行完成后的回调</div><div class="line">    public func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">            NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>madal的转场动画分为2类，present和dismiss，刚才我们实现的是animationControllerForPresentedController，这是present类，下节我们实现dissmiss的转场过渡效果</p>
<h4 id="Controller-dismiss过渡效果"><a href="#Controller-dismiss过渡效果" class="headerlink" title="Controller dismiss过渡效果"></a><code>Controller dismiss过渡效果</code></h4><p>present的过渡效果实现和modal过渡效果类似，也是设置委托、实现委托、实现动画，就不详细说明了，大家可以参考demo。这里我们只说说和present过渡的区别</p>
<h5 id="区别1-委托入口不同"><a href="#区别1-委托入口不同" class="headerlink" title="区别1 委托入口不同"></a><code>区别1 委托入口不同</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//Presented使用的委托</div><div class="line">   func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //Dismiss使用的委托</div><div class="line">   func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</div><div class="line">       //返回一个UIViewControllerAnimatedTransitioning类型</div><div class="line">       return DismissAnimation()</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"><a href="#区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。" class="headerlink" title="区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"></a>区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。</h5><p>DismissAnimation的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class DismissAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</div><div class="line">        //当前控制器</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        print(fromVC.dynamicType)//toViewController</div><div class="line">        //后控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">         print(toVC.dynamicType)//UINavigationController</div><div class="line">        </div><div class="line">        //获得大小</div><div class="line">        let screenBounds = UIScreen.mainScreen().bounds</div><div class="line">        </div><div class="line">        //当前控制器初始化大小</div><div class="line">        let initFrame = transitionContext.initialFrameForViewController(fromVC)</div><div class="line">        </div><div class="line">        //控制器最终的位置</div><div class="line">        let finalFrame = CGRectOffset(initFrame, 0, screenBounds.size.height)</div><div class="line">        //获得视图容器</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //容器中添加后面控制的view</div><div class="line">        containerView?.addSubview(toVC.view)</div><div class="line">        //????</div><div class="line">        containerView?.sendSubviewToBack(toVC.view)</div><div class="line">        //获得切换时间</div><div class="line">        let duration: NSTimeInterval = self.transitionDuration(transitionContext)</div><div class="line">        </div><div class="line">        </div><div class="line">        UIView.animateWithDuration(duration, animations: &#123;</div><div class="line">            </div><div class="line">            fromVC.view.frame = finalFrame</div><div class="line">            </div><div class="line">            &#125;, completion: &#123;</div><div class="line">                (finished: Bool) in</div><div class="line">                </div><div class="line">                //是否完成</div><div class="line">                transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="Controller-push、pop过渡效果"><a href="#Controller-push、pop过渡效果" class="headerlink" title="Controller push、pop过渡效果"></a><code>Controller push、pop过渡效果</code></h4><p>push、pop和present、dismiss的过渡走的是两个完全不同的委托，委托里面的方法有相似之处，比如都可以分为过渡和交互两类。交互的内容后面再说，先说过渡效果的区别。</p>
<ul>
<li><p><strong>实现的委托不同</strong>: push、pop自定义过渡动画，需要实现UINavigationControllerDelegate，而present、dismiss实现的是UIViewControllerTransitioningDelegate</p>
</li>
<li><p><strong>区分类型方式不同</strong>: UIViewControllerTransitioningDelegate通过2个委托present和dismiss区分开来，而在UINavigationControllerDelegate中，对应转场过渡动画只有一个委托，通过委托中的参数operation: UINavigationControllerOperation 区分pop和push</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"><a href="#UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果" class="headerlink" title="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"></a>UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果</h4><h4 id="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"><a href="#步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托" class="headerlink" title="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"></a><code>步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//推出视图切换效果</div><div class="line">    @IBAction func Transitioning1(sender: AnyObject) &#123;</div><div class="line">        let toVC = To1ViewController()</div><div class="line">        //设置委托</div><div class="line">        navigationController?.delegate = self</div><div class="line">        //主要是动画实现圆形扩大效果，需要知道一个初始园的位置，所以把uiview传过去。这种方式传递uiview不是一个很好的方式，这里为了demo能尽量的简单，所以这么做了</div><div class="line">        transitioningSender = sender as! UIView</div><div class="line">        navigationController?.pushViewController(toVC, animated: true)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="步骤2实现UINavigationControllerDelegate"><a href="#步骤2实现UINavigationControllerDelegate" class="headerlink" title="步骤2实现UINavigationControllerDelegate"></a><code>步骤2实现UINavigationControllerDelegate</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"><a href="#步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation" class="headerlink" title="步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"></a><code>步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation</code></h4><p>这个动画效果我就简单说说实现步骤，其余的大家看看代码。下面的参考文章中，有一篇对这个效果说的比较详细，大家可以去阅读</p>
<p>实现这样一个效果，基本原理是使用遮罩层，罩住presenting，有一个小圆是初始按钮点击的圆形路径，一个大圆是大于presenting的圆形路径。大圆和小圆作为遮罩的路径。判断过渡类型是presention -》 presenting还是presenting -》 presention，分别做不同的处理</p>
<p>presention -》 presenting ： 小圆作为初始遮罩层路径，罩住presenting，使用baseAnimation动画把遮罩层的路径从小圆路径变为大圆路径，presenting即可显示出来，完成过渡效果。 小圆的位置是通过跳转点击按钮决定的，小圆位置不同会影响到大圆结束的位置，所以分了左上、左下、右上、右下四个位置分别处理。这个步骤由于偷懒在presenting -》 presention这个过程里面被省略了，每次都指定了固定的小圆位置</p>
<p>presenting -》 presention ： 使用大圆遮住presenting，使用baseAnimation动画把遮罩层的路径从大圆路径变为小圆路径，presenting慢慢变小到看不见，presention慢慢即可显示出来，完成过渡效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class ExpandAnimation: NSObject, UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    //保存上下文</div><div class="line">    var transitionContext:UIViewControllerContextTransitioning!</div><div class="line">    //Pop or push</div><div class="line">    var type:UINavigationControllerOperation!</div><div class="line">    //初始点击的uiview对象，需要他的frame作为初始位置</div><div class="line">    var sender:UIView?</div><div class="line"></div><div class="line">    convenience init(type:UINavigationControllerOperation) &#123;</div><div class="line">        self.init()</div><div class="line">        self.type = type</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        return 0.5</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        self.transitionContext = transitionContext</div><div class="line">        NSLog(&quot;animateTransition&quot;)</div><div class="line">        if(type == .Push)&#123;</div><div class="line">            PushTransition(transitionContext)</div><div class="line">        &#125;else if(type == .Pop)&#123;</div><div class="line">            PopTransition(transitionContext)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">        NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //弹出效果 在固定位置进行的动画，可以根据需要改成动态位置触发</div><div class="line">    func PopTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line">        containerView!.addSubview(fromVC.view)</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        fromVC.view.layer.mask = mask</div><div class="line"></div><div class="line">        //画出小圆</div><div class="line">        let s_center = CGPoint(x: 50, y: 50)</div><div class="line">        let s_radius:CGFloat =  sqrt(800)</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: s_center.x, y: s_center.y, width: 1, height: 1), -s_radius, -s_radius))</div><div class="line">        //        mask.path = s_maskPath.CGPath</div><div class="line"></div><div class="line">        //画出大圆</div><div class="line">        let l_center = CGPoint(x: 50, y: 50)</div><div class="line">        let l_radius = sqrt( pow(view.bounds.width - l_center.x, 2) + pow(view.bounds.height - l_center.y, 2) ) + 150</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = l_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = s_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //present 动画，根据触发点的位置开始启动动画</div><div class="line">    func PushTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let finalFrame = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //小圆路径</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:(sender?.frame)!)</div><div class="line"></div><div class="line">        //大圆路径</div><div class="line">        let l_center =  (sender?.center)!</div><div class="line"></div><div class="line">        var l_radius:CGFloat</div><div class="line">        if(sender!.frame.origin.x &gt; (toVC.view.bounds.size.width / 2))&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //右上角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //右下角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //左上角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //左下角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        l_radius += 50 //稍微增加一些位置</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        mask.path = l_maskPath.CGPath</div><div class="line">        view.layer.mask = mask</div><div class="line"></div><div class="line"></div><div class="line">        ////错误用法，animationWithDuration不能通过操作layer产生动画</div><div class="line">        //UIView.animateWithDuration(5) &#123; () -&gt; Void in</div><div class="line">        //     mask.path = b_maskPath.CGPath</div><div class="line">        //&#125;</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = s_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = l_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.completeTransition(true)</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)?.view.layer.mask = nil</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)?.view.layer.mask = nil</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处&lt;a href=&quot;http://liuyanwei.jumppo.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>新建React-Native报错解决办法</title>
    <link href="http://yoursite.com/2016/10/15/%E6%96%B0%E5%BB%BAReact-Native%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/15/新建React-Native报错解决办法/</id>
    <published>2016-10-15T07:59:44.000Z</published>
    <updated>2016-10-17T11:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新建React-Native报错解决办法"><a href="#新建React-Native报错解决办法" class="headerlink" title="新建React-Native报错解决办法"></a>新建React-Native报错解决办法</h3><p>我在新建了一个项目的时候出现了如下错误,找了很多地方都没有正常解决:看上去是在描述没有使用正确的reactNative的框架导致的,但是按它的说明修改了框架也是无法继续正常运行,错误代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[error][tid:com.facebook.react.JavaScript] Seems you&apos;re trying to access &apos;ReactNative.createClass&apos; from the &apos;react-native&apos; package. Perhaps you meant to access &apos;React.createClass&apos; from the &apos;react&apos; package instead?</div><div class="line"></div><div class="line">For example, instead of:</div><div class="line"></div><div class="line">  import React, &#123; Component, View &#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">You should now do:</div><div class="line"></div><div class="line">  import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">  import &#123; View &#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>提示的内容就是告诉我们需要把Component,React等从包 react 中引入,不能再从 react-native 中引入。</p>
<p>如果要更新引入，基本上要修改所有的文件，还好我们从 更新说明 中可以看到有工具来做这个事情。</p>
<p>提示的内容就是告诉我们需要把Component,React等从包react中引入,不能再从<code>react-native</code>中引入。<br>如果要更新引入，基本上要修改所有的文件，还好我们从更新说明中可以看到有工具来做这个事情。<br><code>codemod-RN24-to-RN25</code>是一个升级项目文件支持<code>React Native 25</code>的工具，更改文件的import，让需要引入react的文件能够正确的import。</p>
<p>使用方法:</p>
<ol>
<li>安装jscodeshift<br><br><br>npm install -g jscodeshift</li>
<li><p>clone项目<br><br>git clone git@github.com:sibeliusseraphini/codemod-RN24-to-RN25.git</p>
</li>
<li><p>copy transform.js<br><br>cd codemod-RN24-to-RN25<br><br>cp transform.js <code>YOUR_PROJECT_PATH</code></p>
</li>
<li><p>运行命令转换文件<br><br>cd <code>YOUR_PROJECT_PATH</code><br><br>jscodeshift transform.js</p>
</li>
</ol>
<p>等待运行完成之后可以看到React以及Component等都能被正确的引用到react包下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;新建React-Native报错解决办法&quot;&gt;&lt;a href=&quot;#新建React-Native报错解决办法&quot; class=&quot;headerlink&quot; title=&quot;新建React-Native报错解决办法&quot;&gt;&lt;/a&gt;新建React-Native报错解决办法&lt;/h3&gt;&lt;
    
    </summary>
    
    
      <category term="react native" scheme="http://yoursite.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>Java中abstract不能共存的关键字</title>
    <link href="http://yoursite.com/2016/10/13/Java%E4%B8%ADabstract%E4%B8%8D%E8%83%BD%E5%85%B1%E5%AD%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/10/13/Java中abstract不能共存的关键字/</id>
    <published>2016-10-13T15:34:54.000Z</published>
    <updated>2016-10-13T15:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>##abstract修饰不能和哪些关键字共存?</p>
<ul>
<li><strong>static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.</strong></li>
<li><strong>final 不能和abstract组合,由于final不允许重写方法,abstract需要直接重写方法</strong></li>
<li><strong>private 不能和abstract组合,abstract是为了让子类看到并且重写,而private是不让外界使用和了解</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##abstract修饰不能和哪些关键字共存?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final 不能和abstract组
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift泛型初探</title>
    <link href="http://yoursite.com/2016/10/08/Swift%E6%B3%9B%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2016/10/08/Swift泛型初探/</id>
    <published>2016-10-08T14:33:34.000Z</published>
    <updated>2016-10-10T14:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming language一书,重新看了一遍里面的内容–其实对于泛型,我最初的理解是来源于Java,在项目中我真的比较少用到泛型.</p>
<h4 id="泛型需求的产生"><a href="#泛型需求的产生" class="headerlink" title="泛型需求的产生"></a>泛型需求的产生</h4><p>下面是书里面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  func swapTwoInt(inout a:Int,inout b:Int)&#123;</div><div class="line">        let tempA = a;</div><div class="line">        a = b;</div><div class="line">        b = tempA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要是我有这个交换两个内容的要求,但是这紧紧单纯是对Int但种类型的配置,如果我还需要有String和Double的话,我必须要拷贝代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func swapTwoString(inout a:String,inout b:String)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">&#125;</div><div class="line"></div><div class="line">      func swapTwoDouble(inout a:Double,inout b:Double)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>于是我们产生了泛型,它可以定义一种统一的类型<t>,这个时候你可以在参数里面写入这个参数,它代表了前后一致的类型,如String,Int,Double…</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)&#123;</div><div class="line">       let tempA = a;</div><div class="line">       a = b;</div><div class="line">       b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>在我写泛型的时候,遇到的第一个问题是返回值怎么处理?<br>唔哼,这个问题让我们继续把泛型的其他定义看下去的时候再继续思考吧.</p>
<h4 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h4><p>那么,泛型的书写方法就是用一对箭括号把类型名称合并起来:如 <strong><em><t></t></em></strong>,当然,你也可以一两个其他字母表示,<strong><em><u,t></u,t></em></strong></p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p> 其中,书中里面举了一个泛型类型的例子是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct IntStack &#123;</div><div class="line">    var items = [Int]();</div><div class="line">    /*</div><div class="line">     mutating关键字:由于swift功能强大,不仅可以让class遵守,也可以让enum和struct遵守</div><div class="line">     mutating关键字在定义协议的方法的时候可以在前面加上,让其三种类型在遵守协议的时候对有关键字的方法有不同的&quot;提示&quot;:</div><div class="line">    class: 在class中实现带有mutating方法的接口时，不用mutating进行修饰。因为对于class来说，类的成员变量和方法都是透明的，所以不必使用 mutating 来进行修饰</div><div class="line">     enum:</div><div class="line">     struct:如果将struct中的mutating去掉，则会报错不能改变结构体的成员。</div><div class="line">    */</div><div class="line">    //将一个数值入栈</div><div class="line">    mutating func push(item:Int)</div><div class="line">    &#123;</div><div class="line">        items.append(item)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //和内存中的栈一样,先进后出,所以只要移除最后一个元素即可</div><div class="line">    mutating func pop() -&gt; Int&#123;</div><div class="line">        </div><div class="line">        return items.removeLast()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是只针对Int一种类型避免也显得太弱了吧,所以我们可以用泛型对其进行改良:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Stack&lt;T&gt; &#123;</div><div class="line">      var items = [T]()</div><div class="line">      mutating func push(item: T) &#123;</div><div class="line">        items.append(item)</div><div class="line">      &#125;</div><div class="line">      mutating func pop() -&gt; T &#123;</div><div class="line">        return items.removeLast()</div><div class="line">      &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候可以将该类型延伸为相应的类型,如string:</p>
<pre><code>var stringsInStack = Stack&lt;String&gt;()
stringsInStack.push(&quot;1&quot;);//1
stringsInStack.push(&quot;2&quot;);//1,2
stringsInStack.push(&quot;3&quot;);//1,2,3
stringsInStack.push(&quot;4&quot;);//1,2,3,4
stringsInStack.pop()//1,2,3
</code></pre><p>现在,有点明白了Array和Dictionary为什么可以指定类型了吧,其实无形中我们已经用了很多泛型的内容,只是我们缺少了总结和理解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     //定义了一个内容必须为字符串的数组</div><div class="line">  var arr :[String] = []</div><div class="line">     arr[0] = &quot;name&quot;;</div><div class="line">     arr[1] = &quot;age&quot;;</div><div class="line">     arr[3] = &quot;height&quot;;</div><div class="line"></div><div class="line">//定义了一个key为String,value为AnyObject的字典  </div><div class="line">   var parma : [String:AnyObject] = [:]</div><div class="line">      parma[&quot;name&quot;] = &quot;shiron&quot;</div><div class="line">      parma[&quot;age&quot;] = 22</div><div class="line">      parma[&quot;height&quot;] = 1.70</div></pre></td></tr></table></figure>
<p>这里可以延伸出后面的一个话题:类型约束.</p>
<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>输入Dictionary点进去可以看到该类的属性和方法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible&#123;</div><div class="line">各种dict的属性和方法......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现在dict对泛型进行定义的时候,key有一个特殊的限制:</p>
<p><strong><strong><key: hashable,value=""></key:></strong></strong><br>此时,我们可以看到key被强制遵守了一个hashable的协议(注意:Swift 标准库中定义的一个特定协议,所有的 Swift 基本类型(如 String , Int , Double 和 Bool )默认都是可哈希。)</p>
<p>当你对泛型的有较高的输入要求时,可以限制某种类或者协议来进行类型约束,定义方法就是在泛型字母后面添加 T:SomeProtocol或者U:someClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func someFunction&lt;T:someClass,U:someProtocol&gt;(someT:T,someU:U)&#123;</div><div class="line">    //函数主体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩展一个泛型类型"><a href="#扩展一个泛型类型" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h4><p>当然我们泛型的好用之处不仅这么一点点.</p>
<p>书中还对Stack的类型作出了一个扩展:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension Stack &#123;</div><div class="line">    var topItem: T? &#123;</div><div class="line">        return items.isEmpty ? nil : items[items.count - 1]</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> topItem 属性会返回一个 T 类型的可选值。当栈为空的时候, topItem 将会返回 nil ;当栈不为空的时候, topItem 会返回 items 数组中的最后一个元素,然而你注意到了吗?我们在扩展里面并没有使用泛型类型的定义,它是从结构体中直接带过来了,对它进行解包则可以自己使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if let topItem = stackOfStrings.topItem &#123; </div><div class="line">    print(&quot; \(topItem)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming l
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中懒加载的then语法</title>
    <link href="http://yoursite.com/2016/09/13/swift%E4%B8%AD%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84then%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/13/swift中懒加载的then语法/</id>
    <published>2016-09-13T15:19:27.000Z</published>
    <updated>2016-10-19T09:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文:<br><a href="http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;mid=2652684686&amp;idx=1&amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;chksm=f00b6f44c77ce6521a20506a99cf446792ac70b537c09d05b7ad4066aa4b8a4cfaba4bedb2af&amp;scene=0#wechat_redirect" target="_blank" rel="external">Swift：让人眼前一亮的初始化方式</a></p>
<h3 id="then语法"><a href="#then语法" class="headerlink" title="then语法"></a>then语法</h3><p>个人非常喜欢这种简介的懒加载模式,唔,不过有时候真的会觉得$0的时候,无法感应该类的属性真蛋疼. 以下是加载方式,供大家参考学习.</p>
<pre><code>  import Foundation

 public protocol Then {}

 extension Then where Self: Any {
         /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: inout Self -&gt; Void) -&gt; Self {
        var copy = self
        block(&amp;copy)
        return copy
    }
     }

 extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: Self -&gt; Void) -&gt; Self {
        block(self)
        return self
     }
    }

extension NSObject: Then {}


  //textFiled的常用懒加载模式
    private lazy var textFiled : UITextField={
        let textFiled = UITextField()
        textFiled.placeholder = &quot;请输入文字&quot;
        return textFiled
    }()

  //在尾随闭包中实例化了UILabel时的写法
     lazy var label : UILabel={

        $0.text = &quot;我是占位文字,textFiled改变时我也会改变&quot;
        $0.font = UIFont.systemFontOfSize(16)

        return $0
    }(UILabel())


//文章开始时给出的then代码段,使得初始化更简洁
 let label = UILabel().then {
      $0.textAlignment = .Center
      $0.textColor = .blackColor()
      $0.text = &quot;Hello, World!&quot;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文:&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;amp;mid=2652684686&amp;amp;idx=1&amp;amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;amp
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习汇总</title>
    <link href="http://yoursite.com/2016/09/10/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/09/10/Java基础学习汇总/</id>
    <published>2016-09-10T15:31:12.000Z</published>
    <updated>2016-10-19T09:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础学习汇总"><a href="#Java基础学习汇总" class="headerlink" title="Java基础学习汇总"></a>Java基础学习汇总</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>了解:所谓多线程,即是在一个进程中,可以同时运行的多任务.如果把现实中的每个人理解为一个进程(QQ),那每个人可以同时处理多项任务,如一边听歌一边写作业可以理解为多线程开启.一个进程占用CUP时间是有限的,通常我们感觉不到有切换是因为CUP切换的速度极快.<h3 id="多线程的实现方法有两种"><a href="#多线程的实现方法有两种" class="headerlink" title="多线程的实现方法有两种"></a>多线程的实现方法有两种</h3></li>
<li><p>1.继承Thread</p>
<ul>
<li>定义类继承Thread</li>
<li>重写run方法</li>
<li>把新线程要做的内容写在run方法中</li>
<li>创建类的对象</li>
<li>执行start方法</li>
<li>注意:匿名内部类和普通类方式非常相似</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	//1.普通定义一个新的类来创建</div><div class="line">	Person p = new Person();</div><div class="line">	p.start();</div><div class="line">	//1.普通定义一个匿名类来创建</div><div class="line">	new Thread()&#123;</div><div class="line">		public void run()&#123;</div><div class="line">			System.out.println(&quot;Thread多线程启动(匿名内	部类)&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;.start();	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Thread方式</div><div class="line">class Person extends Thread &#123;</div><div class="line">	public void run()&#123;</div><div class="line">	System.out.println(&quot;Thread多线程启动,继承方式&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.实现接口Runnable(Thread构造函数中传递了runnable的引用,通过init()方法传递target,用于判断是否执行run()方法)</p>
<ul>
<li>定义类实现Runnable</li>
<li>实现run方法</li>
<li>把操作写在run中</li>
<li>创建Thread对象,传入runnable</li>
<li>调用Runnable的start方法</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">//1.普通类实现了runnable接口来实现调用里面的run方法</div><div class="line">Student s = new Student();</div><div class="line">Thread t = new Thread(s);</div><div class="line">t.start();</div><div class="line">//2.匿名类来实现runnable接口</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;匿名内部类Runnable多线程启动方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;).start();	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class Student implements Runnable&#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;Runnable多线程启动方法,继承方式&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="两种线程的区别"><a href="#两种线程的区别" class="headerlink" title="两种线程的区别"></a>两种线程的区别</h3><ul>
<li>继承Thread<ul>
<li>好处:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端:如果已经有父类,就不能用这种方式</li>
</ul>
</li>
<li>实现Runnable<ul>
<li>好处:可以有父类,直接只是实现接口</li>
<li>弊端:间接把对象作为构造方法的参数传递进去,较为复杂,但自由度较大</li>
</ul>
</li>
</ul>
<h3 id="线程中其他操作"><a href="#线程中其他操作" class="headerlink" title="线程中其他操作"></a>线程中其他操作</h3><ul>
<li>通过getName()可以获得当前线程的名字</li>
<li>通过setName(String)可以设置线程名字</li>
<li>Thread.currentThread()可以获得当前线程对象,获得对象后可以对其进行操作(改名,获得名字)</li>
<li>Thread.sleep(毫秒),类方法调用,可以使得当前线程休眠</li>
<li>setPriority()设置线程的优先级</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java基础学习汇总&quot;&gt;&lt;a href=&quot;#Java基础学习汇总&quot; class=&quot;headerlink&quot; title=&quot;Java基础学习汇总&quot;&gt;&lt;/a&gt;Java基础学习汇总&lt;/h2&gt;&lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;header
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>swift中的extension(持续更新)</title>
    <link href="http://yoursite.com/2016/08/25/swift%E4%B8%AD%E7%9A%84extension-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/08/25/swift中的extension-持续更新/</id>
    <published>2016-08-25T04:36:39.000Z</published>
    <updated>2016-10-27T13:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用"><a href="#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用" class="headerlink" title="在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~"></a>在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~</h4><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension String&#123;</div><div class="line">    </div><div class="line">      /**</div><div class="line">     将时间戳转换成时间</div><div class="line">     </div><div class="line">     - parameter timestamp: 时间戳</div><div class="line">     - parameter formatter: 时间格式</div><div class="line">     */</div><div class="line">    static func stringFromTimestamp(timestamp: String?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let stamp = timestamp, fm = formatter else &#123; return nil &#125;</div><div class="line">        let nsStamp = NSString(string: stamp)</div><div class="line">        let date = NSDate(timeIntervalSince1970: nsStamp.doubleValue)</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(date)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将时间转换成字符串</div><div class="line">     </div><div class="line">     */</div><div class="line">    static func stringFromDate(date: NSDate?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let timeDate = date, fm = formatter else &#123; return nil &#125;</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(timeDate)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    手机号验证</div><div class="line">    </div><div class="line">    - parameter mobile: 手机号</div><div class="line">    </div><div class="line">    - returns: true/fales 符合条件,不符合条件</div><div class="line">    */</div><div class="line">    static func isValidateMobile(mobile: String?) -&gt; Bool &#123;</div><div class="line">        let phoneRegex = &quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;</div><div class="line">        let phoneTest = NSPredicate(format: &quot;SELF MATCHES %@&quot;, phoneRegex)</div><div class="line">        if mobile != nil &#123;</div><div class="line">            return phoneTest.evaluateWithObject(mobile)</div><div class="line">        &#125; else &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    四舍五入</div><div class="line">    </div><div class="line">    - parameter price:    要四舍五入的值</div><div class="line">    - parameter position: 保留多少小数位</div><div class="line">    </div><div class="line">    - returns: 返回四舍五入后的值</div><div class="line">    */</div><div class="line">    static func notRounding(price: Float, afterPoint position: Int16) -&gt; NSString? &#123;</div><div class="line">        let roundingBehavior = NSDecimalNumberHandler(roundingMode: NSRoundingMode.RoundUp, scale: position, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: false)</div><div class="line">        var ouncesDecimal: NSDecimalNumber</div><div class="line">        var roundedOunces: NSDecimalNumber</div><div class="line">        </div><div class="line">        ouncesDecimal = NSDecimalNumber(float: price)</div><div class="line">        roundedOunces = ouncesDecimal.decimalNumberByRoundingAccordingToBehavior(roundingBehavior)</div><div class="line">        </div><div class="line">        return roundedOunces.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    获取当前星期几</div><div class="line">    </div><div class="line">    - parameter date: 传入的时间</div><div class="line">    </div><div class="line">    - returns: 返回当前为星期几元祖</div><div class="line">    */</div><div class="line">    static func getCurrentWeekDay(date: NSDate) -&gt; (String, Int)? &#123;</div><div class="line">        let arrWeek = [&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;]</div><div class="line">        let date = NSDate()</div><div class="line">        let calendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)</div><div class="line">        let timeZone = NSTimeZone(name: &quot;Asia/Shanghai&quot;)</div><div class="line">        calendar!.timeZone = timeZone!</div><div class="line">        var comps = NSDateComponents()</div><div class="line">        comps = calendar!.components(NSCalendarUnit.Weekday, fromDate: date)</div><div class="line">        let week = comps.weekday</div><div class="line">        return (arrWeek[week - 1], week - 1)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     - parameter comment:   注释名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?, comment: String?) -&gt; String &#123;</div><div class="line">        </div><div class="line">        guard let commentStr = comment else &#123;</div><div class="line">            return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: commentStr)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?) -&gt; String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 对应默认的Localizable.strings</div><div class="line">    var localized: String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: nil, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    浮点数相乘</div><div class="line">    */</div><div class="line">    static func decimalNumberMutiplyWithString(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByMultiplyingBy(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相加</div><div class="line">     */</div><div class="line">    static func decimalNumberByAdding(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByAdding(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相减</div><div class="line">     */</div><div class="line">    static func decimalNumberBySubtracting(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplierNumber.decimalNumberBySubtracting(multiplicandNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     过滤空格</div><div class="line">     */</div><div class="line">    static func trimmingCharactersWhite(str: String) -&gt; String &#123;</div><div class="line">        // 去除两端空格</div><div class="line">        let temp = str.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())</div><div class="line">        // 去除其余空格</div><div class="line">        let text = temp.stringByReplacingOccurrencesOfString(&quot; &quot;, withString: &quot;&quot;)</div><div class="line">        return text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    //截取特定字符串</div><div class="line">    subscript (r: Range&lt;Int&gt;) -&gt; String &#123;</div><div class="line">        get &#123;</div><div class="line">            let startIndex = self.startIndex.advancedBy(r.startIndex)</div><div class="line">            let endIndex = self.startIndex.advancedBy(r.endIndex)</div><div class="line">            </div><div class="line">            return self[Range(start: startIndex, end: endIndex)]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将当前字符串拼接到cache目录后面</div><div class="line">     */</div><div class="line">    func cacheDir() -&gt; String&#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.cachesDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到doc目录后面</div><div class="line">     */</div><div class="line">    func docDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到tmp目录后面</div><div class="line">     */</div><div class="line">    func tmpDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSTemporaryDirectory() as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot;&gt;&lt;a href=&quot;#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift-访问控制</title>
    <link href="http://yoursite.com/2016/07/18/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2016/07/18/Swift-访问控制/</id>
    <published>2016-07-18T09:22:13.000Z</published>
    <updated>2016-10-18T09:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>和其他高级语言一样Swift中也增加了访问控制，在Swift中提供了private、internal、public三种访问级别，但是不同的是Swift中的访问级别是基于模块（module，或者target）和源文件（.swift文件）的，而不是基于类型、命名空间声明。</p>
<ul>
<li>private:只能访问当前源文件中的实体（注意Swift中的private和其他语言不太一样，它是基于源文件的，作用范围是整个源文件，如果一个源文件中有两个类，那么一个类可以访问另外一个类的私有成员）。</li>
<li>internal:可以访问当前模块中的其他任何实体，但是在模块外无法访问，这是所有实体的默认访问级别（通常在一个单目标Application中不需要自行设置访问级别）。</li>
<li>public:可以访问当前模块及其他模块中的任何实体（通常用于Framework）。</li>
</ul>
<p>下面是关于Swift关于不同成员访问级别的约定规则：</p>
<ol>
<li>如果一个类的访问级别是private那么该类的所有成员都是private（此时成员无法修改访问级别），如果一个类的访问级别是internal或者public那么它的所有成员都是internal（如果类的访问级别是public，成员默认internal，此时可以单独修改成员的访问级别），类成员的访问级别不能高于类的访问级别(注意：嵌套类型的访问级别也符合此条规则)；</li>
<li>常量、变量、属性、下标脚本访问级别低于其所声明的类型级别，并且如果不是默认访问级别（internal）要明确声明访问级别（例如一个常量是一个private类型的类类型，那么此常量必须声明为private）；</li>
<li>在不违反1、2两条规则的情况下，setter的访问级别可以低于getter的访问级别(例如一个属性访问级别是internal，那么可以添加private(set)修饰将setter权限设置为private，在当前模块中只有此源文件可以访问，对外部是只读的);</li>
<li>必要构造方法（required修饰）的访问级别必须和类访问级别相同，结构体的默认逐一构造函数的访问级别不高于其成员的访问级别（例如一个成员是private那么这个构造函数就是private，但是可以通过自定义来声明一个public的构造函数）,其他方法（包括其他构造方法和普通方法）的访问级别遵循规则1；</li>
<li>子类的访问级别不高于父类的访问级别，但是在遵循三种访问级别作用范围的前提下子类可以将父类低访问级别的成员重写成更高的访问级别（例如父类A和子类B在同一个源文件，A的访问级别是public，B的访问级别是internal，其中A有一个private方法，那么A可以覆盖其private方法并重写为internal）；</li>
<li>协议中所有必须实现的成员的访问级别和协议本身的访问级别相同，其子协议的访问级别不高于父协议；</li>
<li>如果一个类继承于另一个类的同时实现了某个协议那么这个类的访问级别为父类和协议的最低访问级别，并且此类中方法访问级别和所实现的协议中的方法相同；</li>
<li>扩展的成员访问级别遵循规则1，但是对于类、结构体、枚举的扩展可以明确声明访问级别并且可以更低（例如对于internal的类，你可以声明一个private的扩展），而协议的访问级别不可以明确声明；</li>
<li>元组的访问级别是元组中各个元素的最低访问级别，注意：元组的访问级别是自动推导的，无法直接使用以上三个关键字修饰其访问级别；<ol>
<li>函数的访问级是函数的参数、返回值的最低级别，并且如果其访问级别和默认访问级别（internal）不符需要明确声明；</li>
<li>枚举成员的访问级别等同于枚举的访问级别（无法单独设置），同时枚举的原始值、关联值的访问级别不能低于枚举的访问级别；</li>
</ol>
</li>
<li>泛型类型或泛型函数的访问级别是泛型类型、泛型函数、泛型类型参数三者中最低的一个；</li>
<li><p>类型别名的访问级别不能高于原类型的访问级别；</p>
<p>上面这些规则看上去比较繁琐，但其实很多内容理解起来也是顺理成章的（如果你是一个语言设计者相信大部分规则也会这么设计），下面通过一个例子对于规则3做一解释，这一点和其他语言有所不同但是却更加实用。在使用ObjC开发时大家通常会有这样的经验：在一个类中希望某个属性对外界是只读的，但是自己又需要在类中对属性进行写操作，此时只能直接访问属性对应的成员变量，而不能直接访问属性进行设置。但是Swift为了让语法尽可能精简，并没有成员变量的概念，此时就可以通过访问控制来实现。</p>
</li>
</ol>
<p>Person.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import Foundation</div><div class="line"> </div><div class="line">public class Person &#123;</div><div class="line">    //设置setter私有，但是getter为public</div><div class="line">    public private(set) var name:String</div><div class="line">     </div><div class="line">    public init(name:String)&#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public func showMessage()&#123;</div><div class="line">        println(&quot;name=\(name)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import Foundation</div><div class="line"> </div><div class="line">var p =  Person(name:&quot;Kenshin&quot;)</div><div class="line">//此时不能设置name属性，但是可读</div><div class="line">//p.name = &quot;Kaoru&quot;</div><div class="line">println(&quot;name=\(p.name)&quot;)</div><div class="line">p.showMessage()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问控制&quot;&gt;&lt;a href=&quot;#访问控制&quot; class=&quot;headerlink&quot; title=&quot;访问控制&quot;&gt;&lt;/a&gt;访问控制&lt;/h2&gt;&lt;p&gt;和其他高级语言一样Swift中也增加了访问控制，在Swift中提供了private、internal、public三种访问级
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理抛出</title>
    <link href="http://yoursite.com/2016/06/13/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8A%9B%E5%87%BA/"/>
    <id>http://yoursite.com/2016/06/13/Java异常处理抛出/</id>
    <published>2016-06-13T06:34:48.000Z</published>
    <updated>2016-10-13T15:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.</p>
<p>###1.所谓的异常就是在Java程序运行过程中出现的错误.</p>
<ul>
<li>Error : 直接的错误信息,网络回调错误,数据库异常等.</li>
<li>Execption : 异常信息,较为核心的是RuntimeException子类<br>######<em>注:以上两个类都是继承了Throwable的类</em></li>
</ul>
<p>###2.try…catch 的格式(方式)</p>
<ul>
<li>A:异常处理的两种方式<ul>
<li>a:try…catch…finally<br><em>注意:1.被finally控制的语句体一定会执行</em><br><em>2.用于释放资源，在IO流操作和数据库操作中会见到</em><ul>
<li>try catch</li>
<li>try catch finally</li>
<li>try finally </li>
</ul>
</li>
<li>b:throws</li>
</ul>
</li>
<li>B:try…catch处理异常的基本格式<ul>
<li>try…catch…finally</li>
</ul>
</li>
</ul>
<p>###3.那么我们如何选择异常处理的方式呢?</p>
<ul>
<li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li>
<li>区别:<ul>
<li>后续程序需要继续运行就try</li>
<li>后续程序不需要继续运行就throws</li>
</ul>
</li>
</ul>
<p>###4.自定义异常的主要原因是为了可以快速定位异常的原因</p>
<ul>
<li>一种是继承自RuntimeException,另外一种是继承Exception.</li>
</ul>
<p><em>其实对于异常的使用,还是不是特别理解,日后回来再填坑.</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.&lt;/p&gt;
&lt;p&gt;###1.所谓
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ObjectMapper的使用</title>
    <link href="http://yoursite.com/2016/06/06/ObjectMapper/"/>
    <id>http://yoursite.com/2016/06/06/ObjectMapper/</id>
    <published>2016-06-06T09:47:47.000Z</published>
    <updated>2016-10-27T13:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于ObjectMapper"><a href="#关于ObjectMapper" class="headerlink" title="关于ObjectMapper"></a>关于ObjectMapper</h3><p>关于这个第三方库,我也是最近才接触到,在转到swift的项目当中,其实很长时间都在寻找一个适合库来做网络请求回来的JSON解析,但一直都没有找到较好的,所以之前的项目一直都是手动字典转模型,最近发现了一个轻巧又实用的库–而且再多层嵌套,也可以用几句代码完成转换,简直可以媲美OC中字典转模型的第三方框架.</p>
<p>Github的地址为:<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="external">https://github.com/Hearst-DD/ObjectMapper</a></p>
<p>本文主要是翻译github的内容,大家如果英文阅读能力较好的可以自己翻看英文文档</p>
<h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><p>如果一个类或者结构体的接口实现了<strong><em>Mappable</em></strong>接口的时,便可以支持映射,然后还需要实现协议中的两个接口:</p>
<pre><code>init?(_ map: Map)mutating 
func mapping(map: Map)
</code></pre><p>ObjectMapper实用了一个操作符 “&lt;-“来定义成员变量的映射和JSON的转换.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class User: Mappable &#123;</div><div class="line">//这里要定义好需要转换的内容相对于的字段和类型,以后日后方便赋值转换</div><div class="line"> </div><div class="line">  </div><div class="line">    var username: String?</div><div class="line">    var age: Int?</div><div class="line">    var weight: Double!</div><div class="line">    var array: [AnyObject]?</div><div class="line">    var dictionary: [String : AnyObject] = [:]</div><div class="line">    var bestFriend: User?                       // Nested User object</div><div class="line">    var friends: [User]?                        // Array of Users</div><div class="line">    var birthday: NSDate?</div><div class="line">    </div><div class="line">    required init?(_ map: Map) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Mappable</div><div class="line">    func mapping(map: Map) &#123;</div><div class="line">  //根据字典中的内容用&quot;&lt;-&quot;操作符号来映射相应的内容,将其转换到定义好的成员变量中</div><div class="line">        username    &lt;- map[&quot;username&quot;]</div><div class="line">        age         &lt;- map[&quot;age&quot;]</div><div class="line">        weight      &lt;- map[&quot;weight&quot;]</div><div class="line">        array       &lt;- map[&quot;arr&quot;]</div><div class="line">        dictionary  &lt;- map[&quot;dict&quot;]</div><div class="line">        bestFriend  &lt;- map[&quot;best_friend&quot;]</div><div class="line">        friends     &lt;- map[&quot;friends&quot;]</div><div class="line">        birthday    &lt;- (map[&quot;birthday&quot;], DateTransform())</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> //结构体的话也是执行相应的操作</div><div class="line">struct Temperature: Mappable &#123;</div><div class="line">    var celsius: Double?</div><div class="line">    var fahrenheit: Double?</div><div class="line">    </div><div class="line">    init?(_ map: Map) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mutating func mapping(map: Map) &#123;</div><div class="line">        celsius     &lt;- map[&quot;celsius&quot;]</div><div class="line">        fahrenheit  &lt;- map[&quot;fahrenheit&quot;]</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唔,一旦你的类接口定义了Mappable,那么你这个类就可以调用简答的方法进行字典转模型的转换啦.</p>
<p>转换一个JSON成相应的类模型:</p>
<pre><code>let user = User(JSONSting:jsonString)
</code></pre><p>转换一个模型成相应的字符串:</p>
<pre><code>let jsonString = user.toJSONString(prettyPrint:true)
</code></pre><p>除了这种转换方式,Mapper.swfit类还提供了扩展的方法也可以进行同样的转换:</p>
<pre><code> // 字典转模型
let user = Mapper&lt;User&gt;().map(JSONString: JSONString)
//字典转模型
let JSONString = Mapper().toJSONString(user, prettyPrint: true)
</code></pre><p>ObjectMapper支持以下的数据类型</p>
<ul>
<li>Int</li>
<li>Bool</li>
<li>Double</li>
<li>Float</li>
<li>String</li>
<li>RawRepresentable(Enums)</li>
<li>Array<anyobject></anyobject></li>
<li>Dictionary<string, anyobject=""></string,></li>
<li>Object<t: mappable=""></t:></li>
<li>Array<t: mappable=""></t:></li>
<li>Array<array<t: mappable="">&gt;</array<t:></li>
<li>Set<t: mappable=""></t:></li>
<li>Dictionary<string, t:="" mappable=""></string,></li>
<li>Dictionary<string, array<t:="" mappable="">&gt;</string,></li>
<li>Optionals of all the above</li>
</ul>
<h3 id="Mappable-Protocol"><a href="#Mappable-Protocol" class="headerlink" title="Mappable Protocol"></a>Mappable Protocol</h3><p><strong><em>mutating func mapping(map: Map)</em></strong><br>这个函数里面定义了映射所需要指向的字符串,当解析JSON的过程中,创建好实例对象以后会去执行这个函数,当生成JSON的过程中,这个函数是唯一一个可以被叫做对象.</p>
<h3 id="init-map-Map"><a href="#init-map-Map" class="headerlink" title="init?(_ map: Map)"></a>init?(_ map: Map)</h3><p>//翻译未完成,待续…其实ObjectMapper的使用非常简单,只要字符串和相对应的Object一一对应即可…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于ObjectMapper&quot;&gt;&lt;a href=&quot;#关于ObjectMapper&quot; class=&quot;headerlink&quot; title=&quot;关于ObjectMapper&quot;&gt;&lt;/a&gt;关于ObjectMapper&lt;/h3&gt;&lt;p&gt;关于这个第三方库,我也是最近才接触到,在转到
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>关联对象存放自定义数据</title>
    <link href="http://yoursite.com/2016/05/23/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2016/05/23/关联对象存放自定义数据/</id>
    <published>2016-05-23T15:23:04.000Z</published>
    <updated>2016-10-17T11:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关联对象存放自定义数据"><a href="#关联对象存放自定义数据" class="headerlink" title="关联对象存放自定义数据"></a>关联对象存放自定义数据</h3><h4 id="关于objc-setAssociatedObject和objc-getAssociatedObject"><a href="#关于objc-setAssociatedObject和objc-getAssociatedObject" class="headerlink" title="关于objc_setAssociatedObject和objc_getAssociatedObject"></a>关于objc_setAssociatedObject和objc_getAssociatedObject</h4><p>最近是在52个提高IOS高质量代码中看到这个特性的.<br>在我写代码的过程中,我感觉这种方式可以提供代理中的高聚合(和RAC的函数式编程有异曲同工之妙)<br>先把代码上上来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)viewDidLoad &#123;</div><div class="line">            [super viewDidLoad];</div><div class="line"></div><div class="line">                UIAlertView* alert =  [[UIAlertView alloc] initWithTitle:@&quot;信息&quot; message:@&quot;提示&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确认&quot;, nil];</div><div class="line">    </div><div class="line">                void (^block)(NSInteger) = ^(NSInteger buttonIndex)&#123;</div><div class="line">                    if (buttonIndex == 0) &#123;</div><div class="line">                        NSLog(@&quot;取消按钮&quot;);</div><div class="line">                    &#125;else if (buttonIndex == 1)&#123;</div><div class="line">                        NSLog(@&quot;确认按钮&quot;);</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;;</div><div class="line">    </div><div class="line">                objc_setAssociatedObject(alert, ALERTVIEWKEY, block,             OBJC_ASSOCIATION_COPY);</div><div class="line">            //</div><div class="line">            //    NSString* str = @&quot;存储自定义数据&quot;;</div><div class="line">            //    </div><div class="line">            //    objc_setAssociatedObject(alert, ALERTVIEWKEY, str,             OBJC_ASSOCIATION_COPY);</div><div class="line">                [alert show];</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>在实现代理中,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#pragma alertDelegate</div><div class="line"> -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:   (NSInteger)buttonIndex&#123;</div><div class="line">    </div><div class="line">    void(^block)(NSInteger) = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">    block(buttonIndex);</div><div class="line">     //    NSString* str = objc_getAssociatedObject(alertView, ALERTVIEWKEY);</div><div class="line">     //    NSLog(@&quot;%@&quot;,str);</div><div class="line">    </div><div class="line">    NSLog(@&quot;%ld&quot;,(long)buttonIndex);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>我们所得到的效果是可以在上面viewDidload代码中直接执行了按钮的响应.<br>点击不同的按钮作出相应的动作.</p>
<h3 id="实际上-在set方法中"><a href="#实际上-在set方法中" class="headerlink" title="实际上,在set方法中:"></a>实际上,在set方法中:</h3><pre><code>objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)
</code></pre><p>方法中,我们可以在id value传入任意参数,字符串(如注释代码中str的传递),数组,字典等,当然,例子中传递匿名函数就是较为灵活的用法.</p>
<ul>
<li>第一个参数 &lt;#id object#&gt;传入对象</li>
<li>第二个参数 &lt;#const void *key#&gt;为一个key,一般格式为 <pre><code>static void * NAME = &quot;NAME&quot;;
</code></pre></li>
<li>第三个参数 需要传递的对象,如匿名函数,字符串,数组等对象.(一般考虑传递信息,自定义数据,灵活的非常大)</li>
<li>第四个参数 定义的是objc_AssociationPolicy枚举,根据第三个参数来决定这个参数的@property到底是assign,还是nonatomic,retain,还是nonatomic,copy,还是retain,或者的单纯的copy.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">      OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">                                            *   The association is made atomically. */</div><div class="line">      OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">                                            *   The association is made atomically. */</div></pre></td></tr></table></figure>
<h4 id="而代理中调用runtime的get方法"><a href="#而代理中调用runtime的get方法" class="headerlink" title="而代理中调用runtime的get方法:"></a>而代理中调用runtime的get方法:</h4><p>objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;</p>
<ul>
<li>&lt;#id object#&gt;放入对象(代理或者通过其他方式(如属性,指针)放入存储了自定义数据的对象</li>
<li>&lt;#const void *key#&gt;为记录了当初存储该自定义数据的键值</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>其实这种方法并不推荐大家经常使用,因为滥用的话容易导致代码失控,难于调试.</p>
<ul>
<li>可以通过”关联对象”机制把两个对象连接起来</li>
<li>定义关联对象时可以指定内存管理语义,用以模仿定义属性时采用的”拥有关系”和”非拥有关系”</li>
<li>只有在其他做法不可行才应选择关联对象,因为这种做法通常会引入难于查找的bug</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关联对象存放自定义数据&quot;&gt;&lt;a href=&quot;#关联对象存放自定义数据&quot; class=&quot;headerlink&quot; title=&quot;关联对象存放自定义数据&quot;&gt;&lt;/a&gt;关联对象存放自定义数据&lt;/h3&gt;&lt;h4 id=&quot;关于objc-setAssociatedObject和ob
    
    </summary>
    
    
      <category term="oc" scheme="http://yoursite.com/tags/oc/"/>
    
  </entry>
  
  <entry>
    <title>iOS 架构模式 – 简述 MVC, MVP, MVVM 和 VIPER (转)</title>
    <link href="http://yoursite.com/2016/05/19/iOS-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E2%80%93-%E7%AE%80%E8%BF%B0-MVC-MVP-MVVM-%E5%92%8C-VIPER-%E8%BD%AC/"/>
    <id>http://yoursite.com/2016/05/19/iOS-架构模式-–-简述-MVC-MVP-MVVM-和-VIPER-转/</id>
    <published>2016-05-19T15:23:20.000Z</published>
    <updated>2016-10-17T12:14:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 iOS 的 MVC 时候感觉怪怪的？想要尝试下 MVVM？之前听说过 VIPER，但是又纠结是不是值得去学？</p>
<p>继续阅读，你就会知道上面问题的答案 – 如果读完了还是不知道的话，欢迎留言评论。</p>
<p>iOS 上面的架构模式你可能之前就了解过一些，接下来我们会帮你把它们进行一下梳理。我们先简要回顾一下目前比较主流的架构模式，分析比较一些他们的原理，并用一些小栗子来进行练习。如果你对其中的某一种比较感兴趣的话，我们也在文章里面给出了对应的链接。</p>
<p>对于设计模式的学习是一件容易上瘾的事情，所以先提醒你一下：在你读完这篇文章之后，可能会比读之前有更多的疑问，比如：</p>
<ul>
<li><p>(MVC）谁来负责网络请求：是 Model 还是 Controller？</p>
</li>
<li><p>(MVVM）我该怎么去把一个 Model 传递给一个新创建的 View 的 ViewModel？</p>
</li>
<li><p>(VIPER）谁来负责创建 VIPER 模块：是 Router 还是 Presenter？</p>
</li>
</ul>
<h3 id="1-为何要在意架构的选择呢？"><a href="#1-为何要在意架构的选择呢？" class="headerlink" title="1. 为何要在意架构的选择呢？"></a>1. 为何要在意架构的选择呢？</h3><p>   因为如果你不在意的话，难保一天，你就需要去调试一个巨大无比又有着各种问题的类，然后你会发现在这个类里面，你完全就找不到也修复不了任何 bug。一般来说，把这么大的一个类作为整体放在脑子里记着是一件非常困难的事情，你总是难免会忘掉一些比较重要的细节。如果你发现在你的应用里面已经开始出现这种状况了，那你很可能遇到过下面这类问题：</p>
<ul>
<li>这个类是一个 UIViewController 的子类。</li>
<li>你的数据直接保存在了 UIViewController 里面。</li>
<li>你的 UIViews 好像什么都没做。</li>
<li>你的 Model 只是一个纯粹的数据结构</li>
<li>你的单元测试什么都没有覆盖到</li>
</ul>
<p>其实即便你遵循了 Apple 的设计规范，实现了 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">Apple 的 MVC 框架</a>，也还是一样会遇到上面这些问题；所以也没什么好失落的。<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">Apple 的 MVC 框架</a> 有它自身的缺陷，不过这个我们后面再说。</p>
<p>让我们先来定义一下好的框架应该具有的特征：</p>
<ol>
<li>用严格定义的角色，平衡的将职责 划分 给不同的实体。</li>
<li>可测性 通常取决于上面说的第一点（不用太担心，如果架构何时的话，做到这点并不难）。</li>
<li>易用 并且维护成本低。</li>
</ol>
<h5 id="1-1为什么要划分？"><a href="#1-1为什么要划分？" class="headerlink" title="1.1为什么要划分？"></a>1.1为什么要划分？</h5><p>   当我们试图去理解事物的工作原理的时候，划分可以减轻我们的脑部压力。如果你觉得开发的越多，大脑就越能适应去处理复杂的工作，确实是这样。但是大脑的这种能力不是线性提高的，而且很快就会达到一个瓶颈。所以要处理复杂的事情，最好的办法还是在遵循 单一责任原则 的条件下，将它的职责划分到多个实体中去。</p>
<h5 id="1-2-为什么要可测性？"><a href="#1-2-为什么要可测性？" class="headerlink" title="1.2 为什么要可测性？"></a>1.2 为什么要可测性？</h5><p>   对于那些对单元测试心存感激的人来说，应该不会有这方面的疑问：单元测试帮助他们测试出了新功能里面的错误，或者是帮他们找出了重构的一个复杂类里面的 bug。这意味着这些单元测试帮助这些开发者们在程序运行之前就发现了问题，这些问题如果被忽视的话很可能会提交到用户的设备上去；而修复这些问题，又至少需要一周左右的时间（AppStore 审核）。</p>
<h5 id="1-3-为什么要易用"><a href="#1-3-为什么要易用" class="headerlink" title="1.3 为什么要易用"></a>1.3 为什么要易用</h5><p>   这块没什么好说的，直说一点：最好的代码是那些从未被写出来的代码。代码写的越少，问题就越少；所以开发者想少写点代码并不一定就是因为他懒。还有，当你想用一个比较 聪明 的方法的时候，全完不要忽略了它的维护成本。</p>
<h3 id="2-MV-X-的基本要素"><a href="#2-MV-X-的基本要素" class="headerlink" title="2.MV(X) 的基本要素"></a>2.MV(X) 的基本要素</h3><p>现在我们面对架构设计模式的时候有了很多选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* MCV</div><div class="line">* MVP</div><div class="line">* MVVM</div><div class="line">* VIPER</div></pre></td></tr></table></figure>
<p>首先前三种模式都是把所有的实体归类到了下面三种分类中的一种：</p>
<ul>
<li><strong>Models（模型)</strong> — 数据层，或者负责处理数据的 <a href="https://en.wikipedia.org/wiki/Data_access_layer" target="_blank" rel="external">数据接口层</a>。比如 Person 和 PersonDataProvider 类</li>
<li><strong>Views（视图）</strong> – 展示层(GUI)。对于 iOS 来说所有以 UI 开头的类基本都属于这层。</li>
<li><strong>Controller/Presenter/ViewModel（控制器/展示器/视图模型）</strong> – 它是 Model 和 View 之间的胶水或者说是中间人。一般来说，当用户对 View 有操作时它负责去修改相应 Model；当 Model 的值发生变化时它负责去更新对应 View。</li>
</ul>
<p>将实体进行分类之后我们可以：</p>
<ul>
<li>更好的理解</li>
<li>重用（主要是 View 和 Model）</li>
<li>对它们独立的进行测试</li>
</ul>
<h4 id="3-让我从-MV-X-系列开始讲起，最后讲-VIPER。"><a href="#3-让我从-MV-X-系列开始讲起，最后讲-VIPER。" class="headerlink" title="3. 让我从 MV(X) 系列开始讲起，最后讲 VIPER。"></a>3. 让我从 MV(X) 系列开始讲起，最后讲 VIPER。</h4><p>在开始讨论 Apple 的 MVC 之前，我们先来看下 传统的 MVC。</p>
<p>在这种架构下，View 是无状态的，在 Model 变化的时候它只是简单的被 Controller 重绘；就像网页一样，点击了一个新的链接，整个网页就重新加载。尽管这种架构可以在 iOS 应用里面实现，但是由于 MVC 的三种实体被紧密耦合着，每一种实体都和其他两种有着联系，所以即便是实现了也没有什么意义。这种紧耦合还戏剧性的减少了它们被重用的可能，这恐怕不是你想要在自己的应用里面看到的。<strong>综上，传统 MVC 的例子我觉得也没有必要去写了。</strong></p>
<h4 id="4-Apple-的-MVC"><a href="#4-Apple-的-MVC" class="headerlink" title="4.Apple 的 MVC"></a>4.Apple 的 MVC</h4><p><strong>4.1 理想</strong></p>
<p>View 和 Model 之间是相互独立的，它们只通过 Controller 来相互联系。有点恼人的是 Controller 是重用性最差的，因为我们一般不会把冗杂的业务逻辑放在 Model 里面，那就只能放在 Controller 里了。</p>
<p>理论上看这么做貌似挺简单的，但是你有没有觉得有点不对劲？你甚至听过有人把 MVC 叫做重控制器模式。另外 关于 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="external">ViewController 瘦身</a> 已经成为 iOS 开发者们热议的话题了。为什么 Apple 要沿用只是做了一点点改进的传统 MVC 架构呢？</p>
<p><strong>4.2.现实</strong></p>
<p>Cocoa MVC 鼓励你去写重控制器是因为 View 的整个生命周期都需要它去管理，Controller 和 View 很难做到相互独立。虽然你可以把控制器里的一些业务逻辑和数据转换的工作交给 Model，但是你再想把负担往 View 里面分摊的时候就没办法了；因为 View 的主要职责就只是讲用户的操作行为交给 Controller 去处理而已。于是 ViewController 最终就变成了所有东西的代理和数据源，甚至还负责网络请求的发起和取消，还有…剩下的你来讲。</p>
<p>像下面这种代码你应该不陌生吧：</p>
<pre><code>var userCell = tableView.dequeueReusableCellWithIdentifier(&quot;identifier&quot;) vas UserCell
userCell.configureWithUser(user)
</code></pre><p>   Cell 作为一个 View 直接用 Model 来完成了自身的配置，MVC 的原则被打破了，这种情况一直存在，而且还没人觉得有什么问题。如果你是严格遵循 MVC 的话，你应该是在 ViewController 里面去配置 Cell，而不是直接将 Model 丢给 Cell，当然这样会让你的 ViewController 更重。</p>
<p>   <strong>Cocoa MVC 被戏称为重控制器模式还是有原因的。</strong> </p>
<p>问题直到开始<a href="http://nshipster.com/unit-testing/" target="_blank" rel="external"> 单元测试</a>（希望你的项目里面已经有了）之后才开始显现出来。Controller 测试起来很困难，因为它和 View 耦合的太厉害，要测试它的话就需要频繁的去 mock View 和 View 的生命周期；而且按照这种架构去写控制器代码的话，业务逻辑的代码也会因为视图布局代码的原因而变得很散乱。  </p>
<p>综上所述，Cocoa MVC 貌似并不是一个很好的选择。但是我们还是评估一下他在各方面的表现（在文章开头有讲）：</p>
<ul>
<li><strong>划分</strong> – View 和 Model 确实是实现了分离，但是 View 和 Controller 耦合的太厉害</li>
<li><strong>可测性</strong> – 因为划分的不够清楚，所以能测的基本就只有 Model 而已</li>
<li><strong>易用</strong> – 相较于其他模式，它的代码量最少。而且基本上每个人都很熟悉它，即便是没太多经验的开发者也能维护。</li>
</ul>
<p>在这种情况下你可以选择 Cocoa MVC：你并不想在架构上花费太多的时间，而且你觉得对于你的小项目来说，花费更高的维护成本只是浪费而已。</p>
<p><strong>如果你最看重的是开发速度，那么 Cocoa MVC 就是你最好的选择。</strong></p>
<h4 id="5-MVP-–-保证了职责划分的（promises-delivered）-Cocoa-MVC"><a href="#5-MVP-–-保证了职责划分的（promises-delivered）-Cocoa-MVC" class="headerlink" title="5.MVP – 保证了职责划分的（promises delivered） Cocoa MVC"></a>5.MVP – 保证了职责划分的（promises delivered） Cocoa MVC</h4><p>看起来确实很像 Apple 的 MVC 对吧？确实蛮像，它的名字是 MVP（被动变化的 View）。稍等…这个意思是说 Apple 的 MVC 实际上是 MVP 吗？不是的，回想一下，在 MVC 里面 View 和 Controller 是耦合紧密的，但是对于 MVP 里面的 Presenter 来讲，它完全不关注 ViewController 的生命周期，而且 View 也能被简单 mock 出来，所以在 Presenter 里面基本没什么布局相关的代码，它的职责只是通过数据和状态更新 View。</p>
<p><strong>如果我跟你讲 UIViewController 在这里的角色其实是 View 你感觉如何。</strong></p>
<p>在 MVP 架构里面，UIViewController 的那些子类其实是属于 View 的，而不是 Presenter。这种区别提供了极好的可测性，但是这是用开发速度的代价换来的，因为你必须要手动的去创建数据和绑定事件，像下面这段代码中做的一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Model</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingView: class &#123;</div><div class="line">    func setGreeting(greeting: String)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewPresenter &#123;</div><div class="line">    init(view: GreetingView, person: Person)</div><div class="line">    func showGreeting()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingPresenter : GreetingViewPresenter &#123;</div><div class="line">    unowned let view: GreetingView</div><div class="line">    let person: Person</div><div class="line">    required init(view: GreetingView, person: Person) &#123;</div><div class="line">        self.view = view</div><div class="line">        self.person = person</div><div class="line">    &#125;</div><div class="line">    func showGreeting() &#123;</div><div class="line">        let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</div><div class="line">        self.view.setGreeting(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController, GreetingView &#123;</div><div class="line">    var presenter: GreetingViewPresenter!</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func didTapButton(button: UIButton) &#123;</div><div class="line">        self.presenter.showGreeting()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func setGreeting(greeting: String) &#123;</div><div class="line">        self.greetingLabel.text = greeting</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of MVP</div><div class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</div><div class="line">let view = GreetingViewController()</div><div class="line">let presenter = GreetingPresenter(view: view, person: model)</div><div class="line">view.presenter = presenter</div></pre></td></tr></table></figure>
<p><strong>5.1.关于组装方面的重要说明</strong></p>
<p>MVP 架构拥有三个真正独立的分层，所以在组装的时候会有一些问题，而 MVP 也成了第一个披露了这种问题的架构。因为我们不想让 View 知道 Model 的信息，所以在当前的 ViewController（角色其实是 View）里面去进行组装肯定是不正确的，我们应该在另外的地方完成组装。比如，我们可以创建一个应用层（app-wide）的 Router 服务，让它来负责组装和 View-to-View 的转场。这个问题不仅在 MVP 中存在，在接下来要介绍的模式里面也都有这个问题。</p>
<p>让我们来看一下 MVP 在各方面的表现：</p>
<ul>
<li><strong>划分</strong> – 我们把大部分的职责都分配到了 Presenter 和 Model 里面，而 View 基本上不需要做什么（在上面的例子里面，Model 也什么都没做）。</li>
<li><strong>可测性</strong> – 简直棒，我们可以通过 View 来测试大部分的业务逻辑。</li>
<li><strong>易用</strong> – 就我们上面那个简单的例子来讲，代码量差不多是 MVC 架构的两倍，但是 MVP 的思路还是蛮清晰的。<br><strong>MVP 架构在 iOS 中意味着极好的可测性和巨大的代码量。</strong></li>
</ul>
<h4 id="6-MVP-–-添加了数据绑定的另一个版本"><a href="#6-MVP-–-添加了数据绑定的另一个版本" class="headerlink" title="6.MVP – 添加了数据绑定的另一个版本"></a>6.MVP – 添加了数据绑定的另一个版本</h4><p>还存在着另一种的 MVP – Supervising Controller MVP。这个版本的 MVP 包括了 View 和 Model 的直接绑定，与此同时 Presenter（Supervising Controller）仍然继续处理 View 上的用户操作，控制 View 的显示变化。</p>
<p>但是我们之前讲过，模糊的职责划分是不好的事情，比如 View 和 Model 的紧耦合。这个道理在 Cocoa 桌面应用开发上面也是一样的。</p>
<p>就像传统 MVC 架构一样，我找不到有什么理由需要为这个有瑕疵的架构写一个例子</p>
<h4 id="7-MVVM-–-是-MV-X-系列架构里面最新兴的，也是最出色的"><a href="#7-MVVM-–-是-MV-X-系列架构里面最新兴的，也是最出色的" class="headerlink" title="7.MVVM – 是 MV(X) 系列架构里面最新兴的，也是最出色的"></a>7.MVVM – 是 MV(X) 系列架构里面最新兴的，也是最出色的</h4><p>MVVM 架构是 MV(X) 里面最新的一个，让我们希望它在出现的时候已经考虑到了 MV(X) 模式之前所遇到的问题吧。</p>
<p>理论上来说，Model – View – ViewModel 看起来非常棒。View 和 Model 我们已经都熟悉了，中间人的角色我们也熟悉了，但是在这里中间人的角色变成了 ViewModel。</p>
<p>它跟 MVP 很像：</p>
<ul>
<li>MVVM 架构把 ViewController 看做 View。</li>
<li>View 和 Model 之间没有紧耦合</li>
</ul>
<p>另外，它还像 Supervising 版的 MVP 那样做了数据绑定，不过这次不是绑定 View 和 Model，而是绑定 View 和 ViewModel。</p>
<p>那么，iOS 里面的 ViewModel 到底是个什么东西呢？本质上来讲，他是独立于 UIKit 的， View 和 View 的状态的一个呈现（representation）。ViewModel 能主动调用对 Model 做更改，也能在 Model 更新的时候对自身进行调整，然后通过 View 和 ViewModel 之间的绑定，对 View 也进行对应的更新。</p>
<p><strong>7.1.绑定</strong></p>
<p>我在 MVP 的部分简单的提过这个内容，在这里让我们再延伸讨论一下。绑定这个概念源于 OS X 平台的开发，但是在 iOS 平台上面，我们并没有对应的开发工具。当然，我们也有 KVO 和 通知，但是用这些方式去做绑定不太方便。</p>
<p>那么，如果我们不想自己去写他们的话，下面提供了两个选择：</p>
<ul>
<li>选一个基于 KVO 的绑定库，比如 RZDataBinding 或者 SwiftBond。</li>
<li>使用全量级的 函数式响应编程 框架,比如 ReactiveCocoa、RxSwift 或者 PromiseKit。</li>
</ul>
<p>实际上，现在提到「MVVM」你应该就会想到 ReactiveCocoa，反过来也是一样。虽然我们可以通过简单的绑定来实现 MVVM 模式，但是 ReactiveCocoa（或者同类型的框架）会让你更大限度的去理解 MVVM。</p>
<p>响应式编程框架也有一点不好的地方，能力越大责任越大嘛。用响应式编程用得不好的话，很容易会把事情搞得一团糟。或者这么说，如果有什么地方出错了，你需要花费更多的时间去调试。</p>
<p>在接下来的这个小例子中，用响应式框架（FRF）或者 KVO 都显得有点大刀小用，所以我们用另一种方式：直接的调用 ViewModel 的 showGreeting 方法去更新自己（的 greeting 属性），（在 greeting 属性的 didSet 回调里面）用 greetingDidChange 闭包函数去更新 View 的显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Model</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewModelProtocol: class &#123;</div><div class="line">    var greeting: String? &#123; get &#125;</div><div class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; // function to call when greeting did change</div><div class="line">    init(person: Person)</div><div class="line">    func showGreeting()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewModel : GreetingViewModelProtocol &#123;</div><div class="line">    let person: Person</div><div class="line">    var greeting: String? &#123;</div><div class="line">        didSet &#123;</div><div class="line">            self.greetingDidChange?(self)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</div><div class="line">    required init(person: Person) &#123;</div><div class="line">        self.person = person</div><div class="line">    &#125;</div><div class="line">    func showGreeting() &#123;</div><div class="line">        self.greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController &#123;</div><div class="line">    var viewModel: GreetingViewModelProtocol! &#123;</div><div class="line">        didSet &#123;</div><div class="line">            self.viewModel.greetingDidChange = &#123; [unowned self] viewModel in</div><div class="line">                self.greetingLabel.text = viewModel.greeting</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self.viewModel, action: &quot;showGreeting&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of MVVM</div><div class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</div><div class="line">let viewModel = GreetingViewModel(person: model)</div><div class="line">let view = GreetingViewController()</div><div class="line">view.viewModel = viewModel</div></pre></td></tr></table></figure>
<p>然后，我们再回过头来对它各方面的表现做一个评价：</p>
<ul>
<li><strong>划分</strong> – 这在我们的小栗子里面表现的不是很清楚，但是 MVVM 框架里面的 View 比 MVP 里面负责的事情要更多一些。因为前者是通过 ViewModel 的数据绑定来更新自身状态的，而后者只是把所有的事件统统交给 Presenter 去处理就完了，自己本身并不负责更新。</li>
<li><strong>可测性</strong> – 因为 ViewModel 对 View 是一无所知的，这样我们对它的测试就变得很简单。View 应该也是能够被测试的，但是可能因为它对 UIKit 的依赖，你会直接略过它。</li>
<li><strong>易用</strong> – 在我们的例子里面，它的代码量基本跟 MVP 持平，但是在实际的应用当中 MVVM 会更简洁一些。因为在 MVP 下你必须要把 View 的所有事件都交给 Presenter 去处理，而且需要手动的去更新 View 的状态；而在 MVVM 下，你只需要用绑定就可以解决。</li>
</ul>
<p><strong>MVVM 真的很有魅力，因为它不仅结合了上述几种框架的优点，还不需要你为视图的更新去写额外的代码（因为在 View 上已经做了数据绑定），另外它在可测性上的表现也依然很棒。</strong></p>
<h4 id="8-VIPER-–-把搭建乐高积木的经验应用到-iOS-应用的设计上"><a href="#8-VIPER-–-把搭建乐高积木的经验应用到-iOS-应用的设计上" class="headerlink" title="8.VIPER – 把搭建乐高积木的经验应用到 iOS 应用的设计上"></a>8.VIPER – 把搭建乐高积木的经验应用到 iOS 应用的设计上</h4><p>VIPER 是我们最后一个要介绍的框架，这个框架比较有趣的是它不属于任何一种 MV(X) 框架。</p>
<p>到目前为止，你可能觉得我们把职责划分成三层，这个颗粒度已经很不错了吧。现在 VIPER 从另一个角度对职责进行了划分，这次划分了 五层。</p>
<ul>
<li><strong>Interactor（交互器）</strong> – 包括数据（Entities）或者网络相关的业务逻辑。比如创建新的 entities 或者从服务器上获取数据；要实现这些功能，你可能会用到一些服务和管理（Services and Managers）：这些可能会被误以为成是外部依赖东西，但是它们就是 VIPER 的 Interactor 模块。</li>
<li><strong>Presenter（展示器）</strong> – 包括 UI（but UIKit independent）相关的业务逻辑，可以调用 Interactor 中的方法。</li>
<li><strong>Entities（实体）</strong> – 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。</li>
<li><strong>Router（路由）</strong> – 负责 VIPER 模块之间的转场</li>
</ul>
<p>实际上 VIPER 模块可以只是一个页面（screen），也可以是你应用里整个的用户使用流程（the whole user story）- 比如说「验证」这个功能，它可以只是一个页面，也可以是连续相关的一组页面。你的每个「乐高积木」想要有多大，都是你自己来决定的。</p>
<p>如果我们把 VIPER 和 MV(X) 系列做一个对比的话，我们会发现它们在职责划分上面有下面的一些区别：</p>
<ul>
<li>Model（数据交互）的逻辑被转移到了 Interactor 里面，Entities 只是一个什么都不用做的数据结构体。</li>
<li>Controller/Presenter/ViewModel 的职责里面，只有 UI 的展示功能被转移到了 Presenter 里面。Presenter 不具备直接更改数据的能力。</li>
<li>VIPER 是第一个把导航的职责单独划分出来的架构模式，负责导航的就是 Router 层。</li>
</ul>
<p><strong>如何正确的使用导航（doing routing）对于 iOS 应用开发来说是一个挑战，MV(X) 系列的架构完全就没有意识到（所以也不用处理）这个问题。
</strong></p>
<p>下面的这个列子并没有涉及到导航和 VIPER 模块间的转场，同样上面 MV(X) 系列架构里面也都没有涉及。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"> </div><div class="line">struct Person &#123; // Entity (usually more complex e.g. NSManagedObject)</div><div class="line">    let firstName: String</div><div class="line">    let lastName: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">struct GreetingData &#123; // Transport data structure (not Entity)</div><div class="line">    let greeting: String</div><div class="line">    let subject: String</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingProvider &#123;</div><div class="line">    func provideGreetingData()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingOutput: class &#123;</div><div class="line">    func receiveGreetingData(greetingData: GreetingData)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingInteractor : GreetingProvider &#123;</div><div class="line">    weak var output: GreetingOutput!</div><div class="line"> </div><div class="line">    func provideGreetingData() &#123;</div><div class="line">        let person = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;) // usually comes from data access layer</div><div class="line">        let subject = person.firstName + &quot; &quot; + person.lastName</div><div class="line">        let greeting = GreetingData(greeting: &quot;Hello&quot;, subject: subject)</div><div class="line">        self.output.receiveGreetingData(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingViewEventHandler &#123;</div><div class="line">    func didTapShowGreetingButton()</div><div class="line">&#125;</div><div class="line"> </div><div class="line">protocol GreetingView: class &#123;</div><div class="line">    func setGreeting(greeting: String)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</div><div class="line">    weak var view: GreetingView!</div><div class="line">    var greetingProvider: GreetingProvider!</div><div class="line"> </div><div class="line">    func didTapShowGreetingButton() &#123;</div><div class="line">        self.greetingProvider.provideGreetingData()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</div><div class="line">        let greeting = greetingData.greeting + &quot; &quot; + greetingData.subject</div><div class="line">        self.view.setGreeting(greeting)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class GreetingViewController : UIViewController, GreetingView &#123;</div><div class="line">    var eventHandler: GreetingViewEventHandler!</div><div class="line">    let showGreetingButton = UIButton()</div><div class="line">    let greetingLabel = UILabel()</div><div class="line"> </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func didTapButton(button: UIButton) &#123;</div><div class="line">        self.eventHandler.didTapShowGreetingButton()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func setGreeting(greeting: String) &#123;</div><div class="line">        self.greetingLabel.text = greeting</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // layout code goes here</div><div class="line">&#125;</div><div class="line">// Assembling of VIPER module, without Router</div><div class="line">let view = GreetingViewController()</div><div class="line">let presenter = GreetingPresenter()</div><div class="line">let interactor = GreetingInteractor()</div><div class="line">view.eventHandler = presenter</div><div class="line">presenter.view = view</div><div class="line">presenter.greetingProvider = interactor</div><div class="line">interactor.output = presenter</div></pre></td></tr></table></figure>
<p>我们再来评价下它在各方面的表现：</p>
<ul>
<li><strong>划分</strong> – 毫无疑问的，VIPER 在职责划分方面是做的最好的。</li>
<li><strong>可测性</strong> – 理所当然的，职责划分的越好，测试起来就越容易</li>
<li><strong>易用</strong> – 最后，你可能已经猜到了，上面两点好处都是用维护性的代价换来的。一个小小的任务，可能就需要你为各种类写大量的接口。</li>
</ul>
<h3 id="8-1-那么，我们到底应该给「乐高」一个怎样的评价呢？"><a href="#8-1-那么，我们到底应该给「乐高」一个怎样的评价呢？" class="headerlink" title="8.1.那么，我们到底应该给「乐高」一个怎样的评价呢？"></a>8.1.那么，我们到底应该给「乐高」一个怎样的评价呢？</h3><p>果你在使用 VIPER 框架的时候有一种在用乐高积木搭建帝国大厦的感觉，那么你可能 正在犯错误；可能对于你负责的应用来说，还没有到使用 VIPER 的时候，你应该把一些事情考虑的再简单一些。总是有一些人忽视这个问题，继续扛着大炮去打小鸟。我觉得可能是因为他们相信，虽然目前来看维护成本高的不合常理，但是至少在将来他们的应用可以从 VIPER 架构上得到回报吧。如果你也跟他们的观点一样的话，那我建议你尝试一下 Generamba – 一个可以生成 VIPER 框架的工具。虽然对于我个人来讲，这感觉就像给大炮装上了一个自动瞄准系统，然后去做一件只用弹弓就能解决的事情。</p>
<h4 id="9-结论"><a href="#9-结论" class="headerlink" title="9.结论"></a>9.结论</h4><p>我们简单了解了几种架构模式，对于那些让你困惑的问题，我希望你已经找到了答案。但是毫无疑问，你应该已经意识到了，在选择架构模式这件问题上面，不存在什么 银色子弹，你需要做的就是具体情况具体分析，权衡利弊而已。</p>
<p>因此在同一个应用里面，即便有几种混合的架构模式也是很正常的一件事情。比如：开始的时候，你用的是 MVC 架构，后来你意识到有一个特殊的页面用 MVC 做的的话维护起来会相当的麻烦；这个时候你可以只针对这一个页面用 MVVM 模式去开发，对于之前那些用 MVC 就能正常工作的页面，你完全没有必要去重构它们，因为两种架构是完全可以和睦共存的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 iOS 的 MVC 时候感觉怪怪的？想要尝试下 MVVM？之前听说过 VIPER，但是又纠结是不是值得去学？&lt;/p&gt;
&lt;p&gt;继续阅读，你就会知道上面问题的答案 – 如果读完了还是不知道的话，欢迎留言评论。&lt;/p&gt;
&lt;p&gt;iOS 上面的架构模式你可能之前就了解过一些，
    
    </summary>
    
    
      <category term="oc" scheme="http://yoursite.com/tags/oc/"/>
    
  </entry>
  
  <entry>
    <title>哪部电影曾经让你在深夜中痛哭？</title>
    <link href="http://yoursite.com/2016/05/19/%E5%93%AA%E9%83%A8%E7%94%B5%E5%BD%B1%E6%9B%BE%E7%BB%8F%E8%AE%A9%E4%BD%A0%E5%9C%A8%E6%B7%B1%E5%A4%9C%E4%B8%AD%E7%97%9B%E5%93%AD%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/05/19/哪部电影曾经让你在深夜中痛哭？/</id>
    <published>2016-05-19T09:52:04.000Z</published>
    <updated>2016-10-19T12:39:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>点击<a href="https://www.zhihu.com/question/37206525/answer/72868899" target="_blank" rel="external">《爆裂鼓手》</a>查看原文</p>
<p>   <strong>在知乎上看到这个答案非常喜欢,所以保存了下来,曾经我也以为我是很喜欢写代码的,但是看过这片文章以后才发现直接并不是那么的热爱–曾经看过一个视频问,你渴望成功?渴望的程度会想被泡在水里想要呼吸的欲望吗?</strong></p>
<p>   <strong>我问了自己很久,其实我也并没有那么热爱,起码不能说像呼吸那么热爱.说真的就是会觉得编程的世界很广阔,可以让我学习到很多不同的知识和认识很多很厉害的人.正是因为认识了他们,所以我才会明白自己的不足.</strong></p>
<p>   <strong>然后对于生活的抉择,我也在迷茫,我也不知道要往哪里走,只是希望一切能顺顺利利的.说到身在福中不知福,突然就想到小时候没有好好的享受童年,现在等到有很大工作压力的时候才来后悔啊啊,以后一定让自己的孩子好好学习,不要浪费有趣的童年.</strong></p>
<p>   <strong>我本来是有很多奇奇怪怪的话要说的,但是刚刚打了一篇文章,放在了日记里面,现在不那么想说了,一份日记承载了我所以的心情,点点滴滴.回顾起来,突然想问自己,什么才叫成功,什么才叫幸福呢?我们之所以努力,不是为了过上更好的日子吗?</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击&lt;a href=&quot;https://www.zhihu.com/question/37206525/answer/72868899&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《爆裂鼓手》&lt;/a&gt;查看原文&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;在知乎上看
    
    </summary>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>iOS中模拟发送http请求以及解析xml</title>
    <link href="http://yoursite.com/2016/05/05/iOS%E4%B8%AD%E6%A8%A1%E6%8B%9F%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%9E%90xml/"/>
    <id>http://yoursite.com/2016/05/05/iOS中模拟发送http请求以及解析xml/</id>
    <published>2016-05-05T05:32:33.000Z</published>
    <updated>2016-10-17T12:14:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AFNetWorking请求"><a href="#AFNetWorking请求" class="headerlink" title="AFNetWorking请求"></a>AFNetWorking请求</h3><p>这个不难,导入AFN框架,生成一个单例类,特别要注意的是,如果作为模拟请求http请求的话,返回的并不是json数据.</p>
<h4 id="1-单例代码如下"><a href="#1-单例代码如下" class="headerlink" title="1.单例代码如下"></a>1.单例代码如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class NetworkTools: AFHTTPSessionManager &#123;</div><div class="line"></div><div class="line">		//设置单例</div><div class="line">    static let tools: NetworkTools = &#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        let tool = NetworkTools()</div><div class="line">        </div><div class="line">        //设置类型</div><div class="line">        tool.responseSerializer.acceptableContentTypes =  NSSet(objects: &quot;application/json&quot;, &quot;text/html&quot;,&quot;text/json&quot;, &quot;text/javascript&quot;, &quot;text/plain&quot;,&quot;image/png&quot;) as? Set&lt;String&gt;</div><div class="line"></div><div class="line">        tool.responseSerializer = AFHTTPResponseSerializer()</div><div class="line">        </div><div class="line">        return tool</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    //获取单例</div><div class="line">    class func shareNetworkTools() -&gt;NetworkTools&#123;</div><div class="line">        return tools</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2.发送请求"></a>2.发送请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var param = [String:String]()</div><div class="line">      </div><div class="line"></div><div class="line">      NetworkTools.shareNetworkTools().post(&quot;https://www.baidu.com&quot;, parameters: param, progress: nil, success:&#123;(URLSessionDataTask, data)in</div><div class="line">          </div><div class="line">          let jsonStr = String.init(data: data as! Data, encoding: .utf8)!</div><div class="line">          </div><div class="line">          print(jsonStr)</div><div class="line">          </div><div class="line">      &#125;, failure:&#123;(URLSessionDataTask, error) in</div><div class="line">          </div><div class="line">          print(error)</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>好了,在这里我们已经可以获得含有dom字节的字符串吧,保佑解析不要出错吧,这里就不作网络请求了,直接加载本地数据(为了方便查看,这里直接解析html吧):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;p&gt;测试节点&lt;/p&gt;</div><div class="line">    &lt;h1&gt;nnnnnn&lt;/h1&gt;</div><div class="line">    &lt;table&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &lt;li&gt;abc1&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc2&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc3&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc4&lt;/li&gt;</div><div class="line">        &lt;li&gt;abc5&lt;/li&gt;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    &lt;/table&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="GDataXMLNode解析XML"><a href="#GDataXMLNode解析XML" class="headerlink" title="GDataXMLNode解析XML"></a>GDataXMLNode解析XML</h3><h4 id="一-使用GDataXMLNode解析-必须导入文件和框架"><a href="#一-使用GDataXMLNode解析-必须导入文件和框架" class="headerlink" title="一.使用GDataXMLNode解析,必须导入文件和框架"></a>一.使用GDataXMLNode解析,必须导入文件和框架</h4><p>(OS_导入libxml2.2框架后,找不到<libxml tree.h="">的解决办法)</libxml></p>
<ol>
<li>从网上下载GDataXMLNode.h和GDataXMLNode.m,只有两个文件,下载完成后直接拉入项目中即可.(<strong>此时编译会报错误:找不到libxml tree.h</strong>)</li>
<li>下载完成后需要配置项目中的动态库,选中项目,像工程中添加”libxml2.tbd” (借一下图,感谢<a href="http://my.csdn.net/pilqc2009" target="_blank" rel="external">pilqc2009</a>)<br><img src="http://img.blog.csdn.net/20140822203855390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></li>
</ol>
<p><img src="../../images/1.png" alt=""></p>
<ol>
<li><p>切换到切换到Buiild Settings的tab里，通过搜索,找到“Linking”选项框，在里面的”Other Linker Flags”的debug 和 release 里面点击“+”，添加 “-lxml2”<br><img src="http://img.blog.csdn.net/20140822204223171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>跟步骤2一样，依然在Buiild Settings的tab里，通过搜索，找到 Framework Search ,添加“/usr/lib/libxml2.tbd”；</p>
</li>
<li><img src="http://img.blog.csdn.net/20140822204710075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>跟步骤3一样，依然在Buiild Settings的tab里，通过搜索，在“Header Search Paths” 和 “User Header Search Paths” 里填入$(SDKROOT)/usr/include/libxml2。<br><img src="http://img.blog.csdn.net/20140822205006387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>然后clean项目，就OK，可以使用了。</li>
</ol>
<p>二.导入框架以后,就可以愉快的使用GDataXMLNode来解析文件了,如上面的html结构的文档,使用如下方法进行解析:</p>
<pre><code>override func viewDidLoad() {

    super.viewDidLoad()
    //加载web预览
    let webView = UIWebView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: UIScreen.main.bounds.size.height))
    self.view.addSubview(webView)


    let path = Bundle.main.bundlePath
    //获得基础路径
    let baseURL = NSURL.fileURL(withPath: path)
    //获取文件
    let htmlPath = Bundle.main.path(forResource: &quot;index&quot;, ofType: &quot;html&quot;)!
    //抛出错误
    do{
        //将html文件转换为文本
        let htmlCont = try NSString(contentsOfFile: htmlPath, encoding: String.Encoding.utf8.rawValue)

        //将内容显示
        webView.loadHTMLString(htmlCont as String, baseURL: baseURL)

        print(htmlCont)


        do {
            //解析该文本    
            let doc = try GDataXMLDocument.init(xmlString: htmlCont as String!, options: 0)
            //获取节点
            let root = doc.rootElement();

            print(root!)
        } catch  {
            print(&quot;解析错误&quot;)
        }

    }
    catch{
        print(&quot;URl有误,获取失败失败&quot;)
    }        
    view.backgroundColor = UIColor.red
}
</code></pre><p>打印的结果如下解析完成,喜欢怎么取都可以啦:(或得跟节点)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GDataXMLElement 0x7ff9e3f478b0: &#123;type:1 name:html xml:&quot;&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;测试节点&lt;/p&gt;&lt;h1&gt;nnnnnn&lt;/h1&gt;&lt;table&gt;&lt;ul&gt;&lt;li&gt;abc1&lt;/li&gt;&lt;li&gt;abc2&lt;/li&gt;&lt;li&gt;abc3&lt;/li&gt;&lt;li&gt;abc4&lt;/li&gt;&lt;li&gt;abc5&lt;/li&gt;&lt;/ul&gt;&lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AFNetWorking请求&quot;&gt;&lt;a href=&quot;#AFNetWorking请求&quot; class=&quot;headerlink&quot; title=&quot;AFNetWorking请求&quot;&gt;&lt;/a&gt;AFNetWorking请求&lt;/h3&gt;&lt;p&gt;这个不难,导入AFN框架,生成一个单例类,特
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发：正确使用const,static,extern</title>
    <link href="http://yoursite.com/2016/04/22/iOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8const-static-extern/"/>
    <id>http://yoursite.com/2016/04/22/iOS开发：正确使用const-static-extern/</id>
    <published>2016-04-22T08:06:17.000Z</published>
    <updated>2016-10-26T08:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、const与宏的区别-面试题"><a href="#一、const与宏的区别-面试题" class="headerlink" title="一、const与宏的区别(面试题):"></a>一、const与宏的区别(面试题):</h3><p>　　const简介:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</p>
<p>　　编译时刻:宏是预编译(编译之前处理)，const是编译阶段。</p>
<p>　　编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</p>
<p>　　宏的好处:宏能定义一些函数，方法。 const不能。</p>
<p>　　宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。</p>
<p>　　注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">　　// 常见的常量：抽成宏</div><div class="line"></div><div class="line">　　#define XMGAccount @&quot;account&quot;</div><div class="line"></div><div class="line">　　#define XMGUserDefault [NSUserDefaults standardUserDefaults]</div><div class="line"></div><div class="line">　　// 字符串常量</div><div class="line"></div><div class="line">　　static NSString * const account = @&quot;account&quot;;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// 偏好设置存储</div><div class="line"></div><div class="line">　　// 使用宏</div><div class="line"></div><div class="line">　　[XMGUserDefault setValue:@&quot;123&quot; forKey:XMGAccount];</div><div class="line"></div><div class="line">　　// 使用const常量</div><div class="line"></div><div class="line">　　[[NSUserDefaults standardUserDefaults] setValue:@&quot;123&quot; forKey:account];</div><div class="line"></div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h4 id="二、const作用：限制类型"><a href="#二、const作用：限制类型" class="headerlink" title="二、const作用：限制类型"></a>二、const作用：限制类型</h4><p>　　1.const仅仅用来修饰右边的变量(基本数据变量p，指针变量*p)</p>
<p>　　2.被const修饰的变量是只读的。</p>
<p>　　const基本使用
　　
　　
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// 定义变量</div><div class="line"></div><div class="line">　　int a = 1;</div><div class="line"></div><div class="line">　　// 允许修改值</div><div class="line"></div><div class="line">　　a = 20;</div><div class="line"></div><div class="line">　　// const两种用法</div><div class="line"></div><div class="line">　　// const:修饰基本变量p</div><div class="line"></div><div class="line">　　// 这两种写法是一样的，const只修饰右边的基本变量b</div><div class="line"></div><div class="line">　　const int b = 20; // b:只读变量</div><div class="line"></div><div class="line">　　int const b = 20; // b:只读变量</div><div class="line"></div><div class="line">　　// 不允许修改值</div><div class="line"></div><div class="line">　　b = 1;</div><div class="line"></div><div class="line">　　// const:修饰指针变量*p，带*的变量，就是指针变量.</div><div class="line"></div><div class="line">　　// 定义一个指向int类型的指针变量，指向a的地址</div><div class="line"></div><div class="line">　　int *p = &amp;a;</div><div class="line"></div><div class="line">　　int c = 10;</div><div class="line"></div><div class="line">　　p = &amp;c;</div><div class="line"></div><div class="line">　　// 允许修改p指向的地址，</div><div class="line"></div><div class="line">　　// 允许修改p访问内存空间的值</div><div class="line"></div><div class="line">　　*p = 20;</div><div class="line"></div><div class="line">　　// const修饰指针变量访问的内存空间，修饰的是右边*p1，</div><div class="line"></div><div class="line">　　// 两种方式一样</div><div class="line"></div><div class="line">　　const int *p1; // *p1：常量 p1:变量</div><div class="line"></div><div class="line">　　int const *p1; // *p1：常量 p1:变量</div><div class="line"></div><div class="line">　　// const修饰指针变量p1</div><div class="line"></div><div class="line">　　int * const p1; // *p1:变量 p1:常量</div><div class="line"></div><div class="line">　　// 第一个const修饰*p1 第二个const修饰 p1</div><div class="line"></div><div class="line">　　// 两种方式一样</div><div class="line"></div><div class="line">　　const int * const p1; // *p1：常量 p1：常量</div><div class="line"></div><div class="line">　　int const * const p1; // *p1：常量 p1：常量</div><div class="line"></div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h4 id="三、const开发中使用场景"><a href="#三、const开发中使用场景" class="headerlink" title="三、const开发中使用场景:"></a>三、const开发中使用场景:</h4><p>　　1.需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值</p>
<p>　　2.需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。
　　
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　@implementation ViewController</div><div class="line"></div><div class="line">　　// const放*前面约束参数，表示*a只读</div><div class="line"></div><div class="line">　　// 只能修改地址a,不能通过a修改访问的内存空间</div><div class="line"></div><div class="line">　　- (void)test:(const int * )a</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　// *a = 20;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　// const放*后面约束参数，表示a只读</div><div class="line"></div><div class="line">　　// 不能修改a的地址，只能修改a访问的值</div><div class="line"></div><div class="line">　　- (void)test1:(int * const)a</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　int b;</div><div class="line"></div><div class="line">　　// 会报错</div><div class="line"></div><div class="line">　　a = &amp;b;</div><div class="line"></div><div class="line">　　*a = 2;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">　　int a = 10;</div><div class="line"></div><div class="line">　　// 需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值。</div><div class="line"></div><div class="line">　　// 这时候就需要使用const，约束方法的参数只读.</div><div class="line"></div><div class="line">　　[self test:&amp;a];</div><div class="line"></div><div class="line">　　// 需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。</div><div class="line"></div><div class="line">　　[self test1:&amp;a];</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　@end</div></pre></td></tr></table></figure>
<h4 id="四、static和extern简单使用-要使用一个东西，先了解其作用"><a href="#四、static和extern简单使用-要使用一个东西，先了解其作用" class="headerlink" title="四、static和extern简单使用(要使用一个东西，先了解其作用)"></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h4><p>　　static作用:</p>
<p>　　修饰局部变量：</p>
<p>　　1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>　　2.局部变量只会生成一份内存,只会初始化一次。</p>
<p>　　3.改变局部变量的作用域。</p>
<p>　　修饰全局变量</p>
<p>　　1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<p>　　2.避免重复定义全局变量</p>
<p>　　extern作用:</p>
<p>　　只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</p>
<p>　　extern工作原理:</p>
<p>　　先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">　　// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</div><div class="line"></div><div class="line">　　int a = 20;</div><div class="line"></div><div class="line">　　// static修饰全局变量</div><div class="line"></div><div class="line">　　static int age = 20;</div><div class="line"></div><div class="line">　　- (void)test</div><div class="line"></div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　// static修饰局部变量</div><div class="line"></div><div class="line">　　static int age = 0;</div><div class="line"></div><div class="line">　　age++;</div><div class="line"></div><div class="line">　　NSLog(@&quot;%d&quot;,age);</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　- (void)viewDidLoad &#123;</div><div class="line"></div><div class="line">　　[super viewDidLoad];</div><div class="line"></div><div class="line">　　// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">　　[self test];</div><div class="line"></div><div class="line">　　[self test];</div><div class="line"></div><div class="line">　　extern int age;</div><div class="line"></div><div class="line">　　NSLog(@&quot;%d&quot;,age);</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　I</div></pre></td></tr></table></figure>
<h4 id="五、static与const联合使用"><a href="#五、static与const联合使用" class="headerlink" title="五、static与const联合使用"></a>五、static与const联合使用</h4><p>　　static与const作用:声明一个只读的静态变量</p>
<p>　　开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* 开发中常用static修饰全局变量,只改变作用域</div><div class="line">为什么要改变全局变量作用域，防止重复声明全局变量。</div><div class="line">开发中声明的全局变量，有些不希望外界改动，只允许读取。</div><div class="line">比如一个基本数据类型不希望别人改动</div><div class="line">声明一个静态的全局只读常量</div><div class="line">*/</div><div class="line"></div><div class="line">　　static const int a = 20;</div><div class="line"></div><div class="line">/* staic和const联合的作用:声明一个静态的全局只读常量</div><div class="line"></div><div class="line">iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量. 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</div><div class="line">*/</div><div class="line"></div><div class="line">　　static NSString * const key = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</div><div class="line"></div><div class="line">　　static NSString const *key1 = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　六、extern与const联合使用</div><div class="line"></div><div class="line">　　开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。</div><div class="line"></div><div class="line">　　原因:</div><div class="line"></div><div class="line">　　static与const组合：在每个文件都需要定义一份静态全局变量。</div><div class="line"></div><div class="line">　　extern与const组合:只需要定义一份全局变量，多个文件共享。</div><div class="line"></div><div class="line">　　全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</div><div class="line"></div><div class="line">　　GlobeConst.h</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　extern NSString * const nameKey = @&quot;name&quot;;</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　GlobeConst.m</div><div class="line"></div><div class="line">　　#import</div><div class="line"></div><div class="line">　　/*******************************首页****************************/</div><div class="line"></div><div class="line">　　NSString * const nameKey = @&quot;name&quot;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、const与宏的区别-面试题&quot;&gt;&lt;a href=&quot;#一、const与宏的区别-面试题&quot; class=&quot;headerlink&quot; title=&quot;一、const与宏的区别(面试题):&quot;&gt;&lt;/a&gt;一、const与宏的区别(面试题):&lt;/h3&gt;&lt;p&gt;　　const简介:
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIView动画和CoreAnimation学习</title>
    <link href="http://yoursite.com/2016/04/14/UIView%E5%8A%A8%E7%94%BB%E5%92%8CCoreAnimation%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/04/14/UIView动画和CoreAnimation学习/</id>
    <published>2016-04-14T03:34:51.000Z</published>
    <updated>2016-10-17T12:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">阅读原文</a>)</strong></p>
<h5 id="以前在工作中一直都忽视了对动画方面的研究-现在看了一遍刘彦玮大神的博客-偶像啊啊-gt-lt-里面有关于对动画的一些博客-自己重新对动画的知识进行有体系的学习和研究-自己记录下来希望以后能够更好的使用-学习资料来源于iOS动画和特效专题"><a href="#以前在工作中一直都忽视了对动画方面的研究-现在看了一遍刘彦玮大神的博客-偶像啊啊-gt-lt-里面有关于对动画的一些博客-自己重新对动画的知识进行有体系的学习和研究-自己记录下来希望以后能够更好的使用-学习资料来源于iOS动画和特效专题" class="headerlink" title="以前在工作中一直都忽视了对动画方面的研究,现在看了一遍刘彦玮大神的博客(偶像啊啊!&gt;&lt;),里面有关于对动画的一些博客,自己重新对动画的知识进行有体系的学习和研究,自己记录下来希望以后能够更好的使用,学习资料来源于iOS动画和特效专题"></a>以前在工作中一直都忽视了对动画方面的研究,现在看了一遍<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">刘彦玮</a>大神的博客(偶像啊啊!&gt;&lt;),里面有关于对动画的一些博客,自己重新对动画的知识进行有体系的学习和研究,自己记录下来希望以后能够更好的使用,学习资料来源于<a href="http://liuyanwei.jumppo.com/2015/10/29/iOS-animation-0.html" target="_blank" rel="external">iOS动画和特效专题</a></h5><h3 id="一-从最简单的动画开始"><a href="#一-从最简单的动画开始" class="headerlink" title="一.从最简单的动画开始"></a>一.从最简单的动画开始</h3><p>在我们刚刚进入iOS的学习过程中,最先接触的,肯定是下面这个方式来做简答的动画吧!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//初始设定</div><div class="line">	animateView.frame = CGRect(x: 0, y: 0, width: 100, height: 100)</div><div class="line">	        animateView.backgroundColor = UIColor.redColor()</div><div class="line">	        </div><div class="line">	 view.addSubview(animateView)</div><div class="line"></div><div class="line">//最简答的动画是这样设置的:</div><div class="line">        </div><div class="line">      UIView.animateWithDuration(1.0, animations: &#123;</div><div class="line">          //动画效果</div><div class="line">          //颜色可以变</div><div class="line">          self.animateView.backgroundColor = UIColor.yellowColor()</div><div class="line">          //大小/位置可变</div><div class="line">          self.animateView.frame = CGRect(x: 200 , y: 200, width: 200, height: 200)</div><div class="line">          //透明度改变</div><div class="line">          self.animateView.alpha = 0.5</div><div class="line">          </div><div class="line">      &#125;) &#123; (isCompletion) in</div><div class="line">          print(&quot;动画结束&quot;)</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>animateWithDurationl里面有四个重载的方法,使用该方法可以实现了很多简单的功能,其中一个还有有阻尼系数和回弹系数,可以设置弹簧效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">//此方法含有阻尼系数和回弹系数</div><div class="line">        UIView.animateWithDuration(0.2, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions.CurveEaseIn, animations: &#123;</div><div class="line">            //大小/位置可变</div><div class="line">            self.animateView.frame = CGRect(x: 200 , y: 200, width: 200, height: 200)</div><div class="line">            &#125;) &#123; (isCompletion) in</div><div class="line">                print(&quot;动画结束&quot;)</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="二-Core-Animation的类图"><a href="#二-Core-Animation的类图" class="headerlink" title="二.Core Animation的类图"></a>二.Core Animation的类图</h3><p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect05.png" alt="类图"></p>
<ul>
<li><p>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>
</li>
<li><p>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</p>
</li>
<li><p>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>
</li>
<li><p>CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>
</li>
<li><p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>
</li>
<li><p>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
</li>
</ul>
<h3 id="基本动画CABasicAnimation"><a href="#基本动画CABasicAnimation" class="headerlink" title="基本动画CABasicAnimation"></a>基本动画CABasicAnimation</h3><p>然后按照老师的写法,再自己敲了一遍,在touchesBegan方法里面进行了尝试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">       let baseAnimation = CABasicAnimation(keyPath: &quot;position&quot;)</div><div class="line">        //fromValue设置起点位置,不设置的时候为当前位置</div><div class="line">//        let point  = CGPoint(x: 100, y: 100)</div><div class="line">//        baseAnimation.toValue = NSValue(CGPoint: point)</div><div class="line">        baseAnimation.byValue = NSValue(CGPoint: CGPoint(x: 100, y: 100))</div><div class="line">        </div><div class="line">        //其他动画属性</div><div class="line">        baseAnimation.duration = 0.2</div><div class="line">        baseAnimation.repeatCount = 1</div><div class="line">        </div><div class="line">        //加速运动</div><div class="line">//        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)</div><div class="line">        //自定义加速的曲线参数</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(controlPoints: 0.1, 0, 0.9, 0.7)</div><div class="line">        </div><div class="line">        </div><div class="line">        //这两个属性若不设置，动画执行后回复位</div><div class="line">        baseAnimation.removedOnCompletion = false</div><div class="line">        baseAnimation.fillMode = kCAFillModeForwards</div><div class="line">        </div><div class="line">        //可以在动画中缓存一些</div><div class="line">        //baseAnimation.setValue(NSValue(CGPoint: point), forKey: &quot;startPoint&quot;)</div><div class="line">        //开始动画</div><div class="line">        animateView.layer.addAnimation(baseAnimation, forKey: &quot;TextAnimateView&quot;)</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect01.gif" alt=""><br>老师后来提醒了说其实动画只是layer层改变了,实际上,view上的frame还是没有改变,当你再次点击屏幕的时候,view又会回到原来的地方,重新开始这个动画.解决办法是重新设置view.frame :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//        ----------------</div><div class="line">//        此处设置的代理是为了可以让view.frame同时跟着view.layer一起改变</div><div class="line">        baseAnimation.delegate = self</div><div class="line">        </div><div class="line">        baseAnimation.setValue(NSValue(CGPoint: endPoint), forKey: &quot;endPoint&quot;)</div><div class="line">        baseAnimation.setValue(self.animateView, forKey: &quot;sender&quot;)</div><div class="line">        </div><div class="line">//        ----------------</div><div class="line">//代理方法里面可以获取到view和终点的位置</div><div class="line">override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">        let endPoint = anim.valueForKey(&quot;endPoint&quot;)?.CGPointValue()</div><div class="line">        let theView = anim.valueForKey(&quot;sender&quot;) as! UIView</div><div class="line">        theView.layer.position = endPoint!</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>keyPath用于区分BasicAnimation动画类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">   可选的KeyPath</div><div class="line">   transform.scale = 比例轉換 </div><div class="line">   transform.scale.x</div><div class="line">   transform.scale.y</div><div class="line">   &#123;</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale&quot;)</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale.x&quot;)</div><div class="line">    //CABasicAnimation(keyPath: &quot;transform.scale.y&quot;)</div><div class="line">    //初始大小</div><div class="line">    transformAnimation.fromValue = NSNumber(float: 1.0)</div><div class="line">    //最终大小</div><div class="line">    transformAnimation.toValue = NSNumber(double: 2.0)</div><div class="line">//  以上缩放是以view的中心点为中心缩放的，如果需要自定义缩放点，可以设置卯点：</div><div class="line">//        //中心点</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(0.5, 0.5)</div><div class="line">//        //左上角</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(0, 0)</div><div class="line">//        //右下角</div><div class="line">        animateView.layer.anchorPoint = CGPointMake(1.0, 1.0)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   transform.rotation = 旋轉</div><div class="line">   transform.rotation.x</div><div class="line">   transform.rotation.y</div><div class="line">   transform.rotation.z</div><div class="line">   </div><div class="line">   &#123;</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.x&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.y&quot;)</div><div class="line">    	 CABasicAnimation(keyPath: &quot;transform.rotation.z&quot;)</div><div class="line">    	 //初始角度</div><div class="line">        transformAnimation.fromValue = NSNumber(float: 0)</div><div class="line">        //旋转后角度</div><div class="line">        transformAnimation.toValue = NSNumber(float: 130)</div><div class="line">        </div><div class="line">        </div><div class="line">   &#125;</div><div class="line">   transform.translation</div><div class="line">   transform.translation.x</div><div class="line">   transform.translation.y</div><div class="line">   transform.translation.z</div><div class="line"></div><div class="line">   opacity = 透明度</div><div class="line">   margin</div><div class="line">   zPosition</div><div class="line">   backgroundColor 背景颜色</div><div class="line">   cornerRadius 圆角</div><div class="line">   borderWidth</div><div class="line">   bounds</div><div class="line">   contents</div><div class="line">   contentsRect</div><div class="line">   cornerRadius</div><div class="line">   frame</div><div class="line">   hidden</div><div class="line">   mask</div><div class="line">   masksToBounds</div><div class="line">   opacity</div><div class="line">   position</div><div class="line">   shadowColor</div><div class="line">   shadowOffset</div><div class="line">   shadowOpacity</div><div class="line">   shadowRadius</div><div class="line"></div><div class="line">   */</div></pre></td></tr></table></figure>
<h3 id="CABasicAnimation-组合动画"><a href="#CABasicAnimation-组合动画" class="headerlink" title="CABasicAnimation 组合动画"></a>CABasicAnimation 组合动画</h3><p>所有的动画都是由简单的简单的动画组合成的,所以对基础动画的学习是很重要的的,如果需要复杂的动画,当然是要发挥你的想象力啦~<br>自己按老师的代码敲了一遍,熟悉熟悉~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//组合动画</div><div class="line">      func groupAnimation(theView:UIView)&#123;</div><div class="line"></div><div class="line">      //向右平移100</div><div class="line">      let mAnimation = CABasicAnimation(keyPath: &quot;position&quot;)</div><div class="line">      //baseAnimation.fromValue 初始位置，如果不设就是当前位置</div><div class="line">      let endPoint = CGPoint(x: theView.layer.position.x+100, y: theView.layer.position.y)</div><div class="line">      mAnimation.toValue = NSValue(CGPoint:endPoint)//绝对位置</div><div class="line"></div><div class="line">      //baseAnimation.byValue = NSValue(CGPoint:CGPoint(x: 100, y: 0))//相对位置</div><div class="line"></div><div class="line">      //x轴旋转动画</div><div class="line">      let xAnimation = CABasicAnimation(keyPath: &quot;transform.rotation.x&quot;)</div><div class="line">      (xAnimation as CABasicAnimation).byValue =  NSNumber(double:M_PI*500)</div><div class="line">      xAnimation.duration = 1.5</div><div class="line"></div><div class="line">      //y轴旋转动画</div><div class="line">      let yAnimation = CABasicAnimation(keyPath: &quot;transform.rotation.y&quot;)</div><div class="line">      (yAnimation as CABasicAnimation).byValue =  NSNumber(double:M_PI*200)</div><div class="line"></div><div class="line">      //缩放动画</div><div class="line">      let sAnimation = CABasicAnimation(keyPath: &quot;transform.scale&quot;)</div><div class="line">      // 动画选项设定</div><div class="line">      sAnimation.autoreverses = true // 动画结束时执行逆动画</div><div class="line">      // 缩放倍数</div><div class="line">      sAnimation.fromValue = NSNumber(double:0.1) // 开始时的倍率</div><div class="line">      sAnimation.toValue = NSNumber(double:1.5) // 结束时的倍率</div><div class="line"></div><div class="line">      //动画组</div><div class="line">      let groupAnimation = CAAnimationGroup()</div><div class="line"></div><div class="line">      // 动画选项设定，动画组统一设置或者单独设置</div><div class="line">      groupAnimation.duration = 3.0;</div><div class="line">      groupAnimation.repeatCount = 1;</div><div class="line">      groupAnimation.animations = [xAnimation,yAnimation,sAnimation,mAnimation]</div><div class="line">      //这两个属性若不设置，动画执行后回复位</div><div class="line">      groupAnimation.removedOnCompletion = false</div><div class="line">      groupAnimation.fillMode = kCAFillModeForwards</div><div class="line">      groupAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)//加速运动</div><div class="line">      groupAnimation.delegate = self</div><div class="line">      //可以在动画中缓存一些</div><div class="line">      groupAnimation.setValue(NSValue(CGPoint: endPoint), forKey: &quot;endPoint&quot;)</div><div class="line">      groupAnimation.setValue(theView, forKey: &quot;sender&quot;)</div><div class="line">      //执行动画</div><div class="line">      theView.layer.addAnimation(groupAnimation, forKey: &quot;theViewMoveRotation90&quot;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect02.gif" alt=""></p>
<h3 id="关键帧动画-CAKeyframeAnimation"><a href="#关键帧动画-CAKeyframeAnimation" class="headerlink" title="关键帧动画 CAKeyframeAnimation"></a>关键帧动画 CAKeyframeAnimation</h3><blockquote>
<p>关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>
</blockquote>
<p>那么,Keyframe顾名思义就是关键点的frame，你可以通过设定CALayer的始点、中间关键点、终点的frame，时间，动画会沿你设定的轨迹进行移动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private func KeyframeAnimation(theView:UIView)&#123;</div><div class="line">        </div><div class="line">        //关键帧动画</div><div class="line">        let keyframeAnimation = CAKeyframeAnimation(keyPath: &quot;position&quot;)</div><div class="line">        //弧线位置移动</div><div class="line">        </div><div class="line">        </div><div class="line">        //弧线位置移动</div><div class="line">        let path = CGPathCreateMutable()</div><div class="line">        CGPathMoveToPoint(path, nil, 50, 50)</div><div class="line">        //曲线描述</div><div class="line">        CGPathAddCurveToPoint(path, nil, 50, 50, 700, 300, 30, 500)</div><div class="line">        keyframeAnimation.path = path</div><div class="line">        </div><div class="line">        keyframeAnimation.duration = 1.0 ;</div><div class="line">        keyframeAnimation.beginTime =  CACurrentMediaTime() + 2;</div><div class="line">        theView.layer.addAnimation(keyframeAnimation, forKey: &quot;1111&quot;)</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect03.gif" alt=""><br>(插图失败,为了让自己看到效果,继续借图)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">     先附带上让一些迷糊的属性解释吧,要不然大家好像有点看不懂!</div><div class="line">     （1）values属性</div><div class="line"></div><div class="line">     values属性指明整个动画过程中的关键帧点，例如上例中的A-E就是通过values指定的。需要注意的是，起点必须作为values的第一个值。</div><div class="line"></div><div class="line">     （2）path属性</div><div class="line"></div><div class="line">     作用与values属性一样，同样是用于指定整个动画所经过的路径的。需要注意的是，values与path是互斥的，当values与path同时指定时，path会覆盖values，即values属性将被忽略。例如上述pathAnimation例子</div><div class="line"></div><div class="line">     （3）keyTimes属性</div><div class="line"></div><div class="line">     该属性是一个数组，用以指定每个子路径(AB,BC,CD)的时间。如果你没有显式地对keyTimes进行设置，则系统会默认每条子路径的时间为：ti=duration/(5-1)，即每条子路径的duration相等，都为duration的1\4。当然，我们也可以传个数组让物体快慢结合。例如，你可以传入&#123;0.0, 0.1,0.6,0.7,1.0&#125;，其中首尾必须分别是0和1，因此tAB=0.1-0, tCB=0.6-0.1, tDC=0.7-0.6, tED=1-0.7.....</div><div class="line"></div><div class="line">     （4）timeFunctions属性</div><div class="line"></div><div class="line">     用过UIKit层动画的同学应该对这个属性不陌生，这个属性用以指定时间函数，类似于运动的加速度，有以下几种类型。上例子的AB段就是用了淡入淡出效果。记住，这是一个数组，你有几个子路径就应该传入几个元素</div><div class="line"></div><div class="line">     1 kCAMediaTimingFunctionLinear//线性</div><div class="line">     2 kCAMediaTimingFunctionEaseIn//淡入</div><div class="line">     3 kCAMediaTimingFunctionEaseOut//淡出</div><div class="line">     4 kCAMediaTimingFunctionEaseInEaseOut//淡入淡出</div><div class="line">     5 kCAMediaTimingFunctionDefault//默认</div><div class="line"></div><div class="line">     （5）calculationMode属性</div><div class="line"></div><div class="line">     该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似</div><div class="line"></div><div class="line">     1 const kCAAnimationLinear//线性，默认</div><div class="line">     2 const kCAAnimationDiscrete//离散，无中间过程，但keyTimes设置的时间依旧生效，物体跳跃地出现在各个关键帧上</div><div class="line">     3 const kCAAnimationPaced//平均，keyTimes跟timeFunctions失效</div><div class="line">     4 const kCAAnimationCubic//平均，同上</div><div class="line">     5 const kCAAnimationCubicPaced//平均，同上</div><div class="line"></div><div class="line">     */</div></pre></td></tr></table></figure>
<h3 id="转场效果"><a href="#转场效果" class="headerlink" title="转场效果"></a>转场效果</h3><p>转场动画的使用一般分为以下几个步骤：</p>
<ul>
<li>创建转场动画</li>
<li>设置转场类型、子类型（可选）及其他属性</li>
<li>设置转场后的新视图并添加动画到图层</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">  //步骤1：添加view底图，添加view的左右滑动手势</div><div class="line">    let bg = UIImageView(image: UIImage(named: &quot;x0&quot;))</div><div class="line">    func addBgImageView()&#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        bg.frame = CGRect(x: 0, y: 0, width: UIScreen.mainScreen().bounds.size.width, height: UIScreen.mainScreen().bounds.size.height)</div><div class="line">        view.addSubview(bg)</div><div class="line">        </div><div class="line">        let rightSwipe = UISwipeGestureRecognizer(target: self, action:#selector(ViewController.rightSwipe(_:)))</div><div class="line">        rightSwipe.direction = .Right</div><div class="line">        let leftSwipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.leftSwipe(_:)))</div><div class="line">        leftSwipe.direction = .Left</div><div class="line">        </div><div class="line">        view.addGestureRecognizer(rightSwipe)</div><div class="line">        view.addGestureRecognizer(leftSwipe)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">//    步骤2：随机获取图片和随机获取转场效果的函数</div><div class="line">    var images:[UIImage]?</div><div class="line">    func fetchImage()-&gt;UIImage&#123;</div><div class="line">        if images == nil &#123;</div><div class="line">            images = [];</div><div class="line">            </div><div class="line">            for index in 0...5 &#123;</div><div class="line">                let image = UIImage(named: &quot;x&quot; + String(index))</div><div class="line">                images!.append(image!)</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        return images![Int(arc4random()%5)]</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func swipeTransition(subtype:String) -&gt; CATransition &#123;</div><div class="line">        let transfer = CATransition()</div><div class="line">        </div><div class="line">        /*</div><div class="line">         kCATransitionFade：淡入淡出，默认效果</div><div class="line">         kCATransitionMoveIn：新视图移动到就是图上方</div><div class="line">         kCATransitionPush:新视图推开旧视图</div><div class="line">         kCATransitionReveal：移走旧视图然后显示新视图</div><div class="line">         </div><div class="line">         //苹果未公开的私有转场效果</div><div class="line">         cube:立方体</div><div class="line">         suckEffect:吸走的效果</div><div class="line">         oglFlip:前后翻转效果</div><div class="line">         rippleEffect:波纹效果</div><div class="line">         pageCurl:翻页起来</div><div class="line">         pageUnCurl:翻页下来</div><div class="line">         cameraIrisHollowOpen:镜头开</div><div class="line">         cameraIrisHollowClose:镜头关</div><div class="line">         */</div><div class="line">        </div><div class="line">        let types = [kCATransitionFade,kCATransitionMoveIn,kCATransitionPush,kCATransitionReveal,&quot;cube&quot;,&quot;suckEffect&quot;,&quot;oglFlip&quot;,&quot;rippleEffect&quot;,&quot;pageCurl&quot;,&quot;pageUnCurl&quot;,&quot;cameraIrisHollowOpen&quot;,&quot;cameraIrisHollowClose&quot;]</div><div class="line">        </div><div class="line">        let type = types[Int(arc4random()%11)]</div><div class="line">        </div><div class="line">        transfer.type = type</div><div class="line">        </div><div class="line">        NSLog(&quot;%@&quot;, type)</div><div class="line">        </div><div class="line">        transfer.subtype = subtype</div><div class="line">        transfer.duration = 1</div><div class="line">        return transfer</div><div class="line">    &#125;</div><div class="line">//    步骤3：左右滑动方法，实现场景切换</div><div class="line">    </div><div class="line">    func rightSwipe(rightSwipe:UIGestureRecognizer)&#123;</div><div class="line">        </div><div class="line">        bg.image = fetchImage()</div><div class="line">        bg.layer.addAnimation(swipeTransition(kCATransitionFromRight), forKey: &quot;kCATransitionFromRight&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func leftSwipe(leftSwipe:UIGestureRecognizer)&#123;</div><div class="line">        </div><div class="line">        bg.image = fetchImage()</div><div class="line">        bg.layer.addAnimation(swipeTransition(kCATransitionFromLeft), forKey: &quot;kCATransitionFromleft&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="http://liuyanwei.jumppo.com/assets/uploads/animationAndEffect04.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处&lt;a href=&quot;http://liuyanwei.jumppo.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中的跑马灯实现（导航栏）</title>
    <link href="http://yoursite.com/2016/03/28/swift%E4%B8%AD%E7%9A%84%E8%B7%91%E9%A9%AC%E7%81%AF%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AF%BC%E8%88%AA%E6%A0%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/28/swift中的跑马灯实现（导航栏）/</id>
    <published>2016-03-27T19:28:57.000Z</published>
    <updated>2016-10-17T11:55:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先是懒加载了runLabel：</p>
<pre><code> private lazy var runLabel : UILabel={
     let label = UILabel()
     label.sizeToFit()

    label.font = UIFont(name: kMyFontName, size: kFontSize14)
    label.textColor = UIColor.blackColor()
    return label
}()
</code></pre><p>然后在viewDidLoad中实现addsubView方法：</p>
<pre><code>/// 跑马灯
self.navigationItem.titleView?.addSubview(runLabel)
//设置label的原始位置
runLabel.frame.origin.x = kScreenWidth


UIView.beginAnimations(self.productName, context: nil)
UIView.setAnimationDuration(16)
UIView.setAnimationCurve(UIViewAnimationCurve.Linear)
UIView.setAnimationDelegate(self)
UIView.setAnimationRepeatCount(999999)

runLabel.frame.origin.x = -runLabel.frame.size.width
UIView .commitAnimations()
</code></pre><p>另外如果文字过长的话建议直接计算文字宽度（做个简单的分类即可）</p>
<pre><code>extension String {
  func getTitleW() -&gt; CGFloat{
     /// 计算文字宽度
     var dict:[String:AnyObject] = [:]
      dict[NSFontAttributeName] = UIFont(name: kMyFontName, size:   kFontSize14)
          return NSString(string:     self).boundingRectWithSize(CGSizeMake(999, 14), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: dict, context: nil).size.width + 24

    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先是懒加载了runLabel：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; private lazy var runLabel : UILabel={
     let label = UILabel()
     label.sizeToFit()

    label.font 
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>第三方HTML解析 TFHpple 的简单使用</title>
    <link href="http://yoursite.com/2016/03/12/%E7%AC%AC%E4%B8%89%E6%96%B9HTML%E8%A7%A3%E6%9E%90-TFHpple-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/12/第三方HTML解析-TFHpple-的简单使用/</id>
    <published>2016-03-12T08:42:32.000Z</published>
    <updated>2016-10-17T11:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第三方HTML解析-TFHpple-的简单使用-swift版"><a href="#第三方HTML解析-TFHpple-的简单使用-swift版" class="headerlink" title="第三方HTML解析 TFHpple 的简单使用(swift版)"></a>第三方HTML解析 TFHpple 的简单使用(swift版)</h3><h3 id="一-使用TFHpple解析-必须导入文件和框架xmllib2"><a href="#一-使用TFHpple解析-必须导入文件和框架xmllib2" class="headerlink" title="一.使用TFHpple解析,必须导入文件和框架xmllib2"></a>一.使用TFHpple解析,必须导入文件和框架xmllib2</h3><p>(OS_导入libxml2.2框架后,找不到<libxml tree.h="">的解决办法)</libxml></p>
<ol>
<li><p>pod导入TFHpple第三方库(<strong>此时编译会报错误:找不到libxml tree.h</strong>)</p>
</li>
<li><p>下载完成后需要配置项目中的动态库,选中项目,像工程中添加”libxml2.tbd” (借一下图,感谢<a href="http://my.csdn.net/pilqc2009" target="_blank" rel="external">pilqc2009</a>)<br><img src="http://img.blog.csdn.net/20140822203855390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></p>
</li>
</ol>
<p><img src="../../images/1.png" alt=""></p>
<ol>
<li><p>切换到切换到Buiild Settings的tab里，通过搜索,找到“Linking”选项框，在里面的”Other Linker Flags”的debug 和 release 里面点击“+”，添加 “-lxml2”<br><img src="http://img.blog.csdn.net/20140822204223171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>跟步骤2一样，依然在Buiild Settings的tab里，通过搜索，找到 Framework Search ,添加“/usr/lib/libxml2.tbd”；<br><img src="http://img.blog.csdn.net/20140822204710075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
</ol>
<ol>
<li>跟步骤3一样，依然在Buiild Settings的tab里，通过搜索，在“Header Search Paths” 和 “User Header Search Paths” 里填入$(SDKROOT)/usr/include/libxml2。<br><img src="http://img.blog.csdn.net/20140822205006387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlX2VtaW5lbnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
</ol>
<ol>
<li>然后clean项目，就OK，可以使用了。</li>
</ol>
<h3 id="二-那么-导入以后又应该如何使用TFHpple呢"><a href="#二-那么-导入以后又应该如何使用TFHpple呢" class="headerlink" title="二.那么,导入以后又应该如何使用TFHpple呢?"></a>二.那么,导入以后又应该如何使用TFHpple呢?</h3><p>我们先来看看官方在oc下是如何使用的吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#import &quot;TFHpple.h&quot;</div><div class="line"></div><div class="line">//</div><div class="line">NSData  * data      = [NSData dataWithContentsOfFile:@&quot;index.html&quot;];</div><div class="line"></div><div class="line">//</div><div class="line">TFHpple * doc       = [[TFHpple alloc] initWithHTMLData:data];</div><div class="line">NSArray * elements  = [doc search:@&quot;//a[@class=&apos;sponsor&apos;]&quot;];</div><div class="line"></div><div class="line">TFHppleElement * element = [elements objectAtIndex:0];</div><div class="line">[e text];                       // The text inside the HTML element (the content of the first text node)</div><div class="line">[e tagName];                    // &quot;a&quot;</div><div class="line">[e attributes];                 // NSDictionary of href, class, id, etc.</div><div class="line">[e objectForKey:@&quot;href&quot;];       // Easy access to single attribute</div><div class="line">[e firstChildWithTagName:@&quot;b&quot;]; // The first &quot;b&quot; child node</div></pre></td></tr></table></figure>
<h4 id="2-1分析一下它是如何使用该类的"><a href="#2-1分析一下它是如何使用该类的" class="headerlink" title="2.1分析一下它是如何使用该类的:"></a>2.1分析一下它是如何使用该类的:</h4><ul>
<li>第一步先将.html转为为data文件</li>
<li>第二步是用带data参数的方法实例化TFHpple对象</li>
<li>第三步的时候,我们就可以用各种适配的方法来进行节点的获取了(<strong>下面会讲到这些条件是怎么使用的</strong>)</li>
<li>第四步,获取到某个节点的时候,如果确定只有一个用该类命名的元素时,可以直接取first第一个元素<ul>
<li>text是该元素下,dom中间的内容</li>
<li>tagName 是该元素的html标签</li>
<li>attributes 是该元素下,元素属性的值</li>
<li>objectForKey:@”href” 可以根据节点属性来取属性中属性的值,如取imageUrl</li>
<li>firstChildWithTagName:@”b”  第一个名称为b的子节点</li>
</ul>
</li>
</ul>
<p>其实掌握了以上的方法,就可以很好的运用该框架来获取html文件中的任何内容了. </p>
<h4 id="2-2这里先来解释一下-TFHpple中的类方法seacrh-quot-xxxxx-quot-是什么东西吧"><a href="#2-2这里先来解释一下-TFHpple中的类方法seacrh-quot-xxxxx-quot-是什么东西吧" class="headerlink" title="2.2这里先来解释一下 TFHpple中的类方法seacrh:&quot;xxxxx&quot;是什么东西吧!"></a>2.2这里先来解释一下 TFHpple中的类方法<code>seacrh:&quot;xxxxx&quot;</code>是什么东西吧!</h4><p><strong>其实这个就是一个选取节点的武器,让给我们来看看这部分是怎么组成的吧(有html基础的同学可能能更快反应过来)</strong></p>
<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取</p>
<p><strong>下面列出了最有用的路径表达式：</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td> /</td>
<td>从根节点选取。</td>
</tr>
<tr>
<td> //</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td> .</td>
<td>选取当前节点。</td>
</tr>
<tr>
<td> ..</td>
<td>选取当前节点的父节点。</td>
</tr>
<tr>
<td> @</td>
<td>选取属性。</td>
</tr>
</tbody>
</table>
<p>举个例子来体会一下吧,下面是xml文档格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</div><div class="line"></div><div class="line">&lt;bookstore&gt;</div><div class="line"></div><div class="line">&lt;book&gt;</div><div class="line">  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;</div><div class="line">  &lt;price&gt;29.99&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line"></div><div class="line">&lt;book&gt;</div><div class="line">  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;</div><div class="line">  &lt;price&gt;39.95&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line"></div><div class="line">&lt;/bookstore&gt;</div></pre></td></tr></table></figure>
<p><strong>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</strong></p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>bookstore</td>
<td>选取 bookstore 元素的所有子节点。</td>
</tr>
<tr>
<td>/bookstore</td>
<td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td>bookstore/book</td>
<td>选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>
<tr>
<td>//book</td>
<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td>bookstore//book</td>
<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td>//@lang</td>
<td>选取名为 lang 的所有属性。</td>
</tr>
</tbody>
</table>
<h5 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h5><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。<br>谓语被嵌在方括号中。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/book[1]</td>
<td>选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[last()-1]</td>
<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td>/bookstore/book[position()&lt;3]</td>
<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>
<tr>
<td>//title[@lang]</td>
<td>选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>
<tr>
<td>//title[@lang=’eng’</td>
<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00</td>
<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
<tr>
<td>/bookstore/book[price&gt;35.00]/title</td>
<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
</tbody>
</table>
<h5 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h5><p>XPath 通配符可用来选取未知的 XML 元素。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点。</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点。</td>
</tr>
<tr>
<td>node()</td>
<td>匹配任何类型的节点。</td>
</tr>
</tbody>
</table>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bookstore/*</td>
<td>选取 bookstore 元素的所有子元素。</td>
</tr>
<tr>
<td>//*</td>
<td>选取文档中的所有元素。</td>
</tr>
<tr>
<td>//title[@*]</td>
<td>选取所有带有属性的 title 元素。</td>
</tr>
</tbody>
</table>
<h5 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h5><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>//book/title</td>
<td>//book/price    选取 book 元素的所有 title 和 price 元素。</td>
</tr>
<tr>
<td>//title</td>
<td>//price    选取文档中的所有 title 和 price 元素。</td>
</tr>
<tr>
<td>/bookstore/book/title</td>
<td>//price    选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>
</tr>
</tbody>
</table>
<p>(以上关于节点的内容,转载自<a href="http://blog.csdn.net/ministarler/article/details/17561641" target="_blank" rel="external">Ministarler</a>,如有侵权请告知,本人将立刻删除)</p>
<h4 id="2-3-其实这个框架的使用非常简答-你要弄清楚的就是了解下面几个到底是意思"><a href="#2-3-其实这个框架的使用非常简答-你要弄清楚的就是了解下面几个到底是意思" class="headerlink" title="2.3 其实这个框架的使用非常简答,你要弄清楚的就是了解下面几个到底是意思:"></a>2.3 其实这个框架的使用非常简答,你要弄清楚的就是了解下面几个到底是意思:</h4><ul>
<li><strong>节点</strong></li>
<li><strong>节点属性</strong></li>
<li><strong>节点属性值</strong></li>
<li><strong>节点的内容</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第三方HTML解析-TFHpple-的简单使用-swift版&quot;&gt;&lt;a href=&quot;#第三方HTML解析-TFHpple-的简单使用-swift版&quot; class=&quot;headerlink&quot; title=&quot;第三方HTML解析 TFHpple 的简单使用(swift版)&quot;
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift 中异常处理do...catch的简单理解</title>
    <link href="http://yoursite.com/2016/03/12/swift-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86do-catch%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/12/swift-中异常处理do-catch的简单理解/</id>
    <published>2016-03-12T05:19:47.000Z</published>
    <updated>2016-10-17T11:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-使用枚举来设置错误值是很好的办法"><a href="#1-使用枚举来设置错误值是很好的办法" class="headerlink" title="1. 使用枚举来设置错误值是很好的办法"></a>1. 使用枚举来设置错误值是很好的办法</h4><p>使用如下办法来创建异常类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">enum NetWorkingError:Error &#123;</div><div class="line">    case NilString</div><div class="line">    case WithoutUrl</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-怎么去抛出异常"><a href="#2-怎么去抛出异常" class="headerlink" title="2. 怎么去抛出异常"></a>2. 怎么去抛出异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func getString(Str:String?) throws -&gt;String</div></pre></td></tr></table></figure>
<p>聪明的你,肯定一眼就能看明白,只想要在返回值前面写一个throws关键字就可以定义异常抛出了,其实感觉有点象以后oc中带一个error的参数.不过在swift中含有error的api几乎都改成了异常抛出了.<br>那么,如何使用呢?</p>
<p>我们只需在调用方法的时候使用do…catch就可以了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">			//如果无法处理该方法,则直接跳去catch里面</div><div class="line">         let s = try getString(Str: nil)</div><div class="line">         print(s)</div><div class="line">     &#125; catch &#123;</div><div class="line">         print(&quot;错误处理&quot;)</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>如果你觉得你已经做好了处理,肯定不会产生异常信息,可以使用<code>try!</code>,这种方法去解析,但一般不建议这样使用</p>
<pre><code>let str = try! getString(Str:&quot;abc&quot;)
</code></pre><h4 id="3-如果写入一个异常"><a href="#3-如果写入一个异常" class="headerlink" title="3. 如果写入一个异常?"></a>3. 如果写入一个异常?</h4><p>我们还没有说到异常是怎么抛出的,作为一种新的语言,swift还提供了优雅的方式来处理异常:<code>guard</code>,如果换成用语言来描述的话:条件成立的时候跳过else里面处理方式,所以有下面的写法:</p>
<pre><code>func getString(Str:String?) throws -&gt;String{

    guard let str = Str else {
        throw NetWorkingError.NilString
    }
    return &quot;........\(str)&quot;
}
</code></pre><p>这个时候就可以定义了异常的抛出了,swift也支持了 Pattern Matching 功能,是不是很像Java中的抛出?</p>
<p>所以,在代码中我们可以再作处理:</p>
<pre><code> func getString(Str:String?,Url:String?) throws -&gt;String{

    guard let str = Str else {
    //抛出一个异常
        throw NetWorkingError.NilString
    }

    guard let str = Url else {
    //抛出第二个异常
        throw NetWorkingError.WithoutUrl
    }

    return &quot;........\(str)&quot;
}
</code></pre><p>那么,我们在使用的时候就可以对异常进行二次捕抓:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try functionWillThrowError()</div><div class="line">    //</div><div class="line">  &#125; catch NetWorkingError.NilString &#123;</div><div class="line">    // deal with not exist</div><div class="line">  &#125; catch NetWorkingError.WithoutUrl &#123;</div><div class="line">    // deal with not exist</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结:"></a>4. 总结:</h4><ul>
<li>使用 ErrorType 的帮助建立你的异常类型</li>
<li>使用 throws 来声明异常，用 throw 来抛出异常</li>
<li>使用 do-catch 机制来获取和处理异常</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-使用枚举来设置错误值是很好的办法&quot;&gt;&lt;a href=&quot;#1-使用枚举来设置错误值是很好的办法&quot; class=&quot;headerlink&quot; title=&quot;1. 使用枚举来设置错误值是很好的办法&quot;&gt;&lt;/a&gt;1. 使用枚举来设置错误值是很好的办法&lt;/h4&gt;&lt;p&gt;使用如下
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
</feed>
