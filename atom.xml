<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiron</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-10T09:52:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux中链表结构体内计算偏移量的方法</title>
    <link href="http://yoursite.com/2017/07/10/linux%E4%B8%AD%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/10/linux中链表结构体内计算偏移量的方法/</id>
    <published>2017-07-10T09:23:24.000Z</published>
    <updated>2017-07-10T09:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-感悟"><a href="#1-感悟" class="headerlink" title="1.感悟"></a>1.感悟</h4><p>之前在重新学习C语言的时候,觉得前人设计的链表非常精妙,值得我们学习,一般来说,普通的指针就是有数据域和指针域构成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct Node&#123;</div><div class="line">    int data;</div><div class="line">    struct Node* next;</div><div class="line">&#125;SLIST;</div><div class="line">//提供一下方法供访问</div><div class="line">SLIST	*SList_Creat();</div><div class="line">int		SList_Print(SLIST *pHead);</div><div class="line">int		SList_NodeInsert(SLIST *pHead, int x , int y);</div><div class="line">int		SList_NodeDel(SLIST *pHead, int y);</div><div class="line">int		SList_Destory(SLIST *pHead);</div></pre></td></tr></table></figure>
<p>普通的单向链表是一种头接尾的形式一直连接下去的,至于链表的好处这里不再附属,想要表达的是在Linux内核中链表的实现,<strong>提供的连接不直接属于结构体,而是一种外部的连接</strong>.怎么理解这句话呢,其实放到面向对象来说,这个链表的设计应该是基于接口而不是基于类的实现去操作的.类可以无穷无尽.但是作为接口只有有一个就可以提供给外界访问.</p>
<h4 id="2-接口解析"><a href="#2-接口解析" class="headerlink" title="2.接口解析"></a>2.接口解析</h4><p>我们可以来看一下Linux内核为链表提供的一致的访问接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Linux内核为链表提供了一致的访问接口</div><div class="line">//初始化</div><div class="line">void INIT_LIST_HEAD(struct list_head *list)；</div><div class="line">//添加到头部</div><div class="line">void list_add(struct list_head *new, struct list_head *head)；</div><div class="line">//添加到尾部</div><div class="line">void list_add_tail(struct list_head *new, struct list_head *head)；</div><div class="line">//删除链表</div><div class="line">void list_del(struct list_head *entry);</div><div class="line">//是否为空</div><div class="line">int list_empty(const struct list_head *head)；</div></pre></td></tr></table></figure>
<p>下面用一个实例来尝试讲解一下,如何应用到Linux中链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//定义一个结构体</div><div class="line">struct int_node &#123;</div><div class="line">        int val;</div><div class="line">        struct list_head node;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        struct list_head head, *plist;</div><div class="line">        struct int_node a, b;</div><div class="line"></div><div class="line">        a.val = 2;</div><div class="line">        b.val = 3;</div><div class="line"></div><div class="line">//生成链表并将内容添加到链表</div><div class="line">        INIT_LIST_HEAD(&amp;head);</div><div class="line">        list_add(&amp;a.list, &amp;head);</div><div class="line">        list_add(&amp;b.list, &amp;head);</div><div class="line"></div><div class="line">//遍历链表</div><div class="line">        list_for_each(plist, &amp;head) &#123;</div><div class="line">                struct int_node *node = list_entry(plist, struct int_node, list);</div><div class="line">                printf(&quot;val = %d\n&quot;, node-&gt;val);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-linux内核链表分析"><a href="#3-linux内核链表分析" class="headerlink" title="3.linux内核链表分析"></a>3.linux内核链表分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct Node&#123;</div><div class="line">    int data;</div><div class="line">    struct Node* next;</div><div class="line">&#125;SLIST;</div><div class="line"></div><div class="line">typedef struct Person&#123;</div><div class="line">    char[10] name;</div><div class="line">    int age;</div><div class="line">    struct SLIST list</div><div class="line">&#125;SPerson;</div></pre></td></tr></table></figure>
<p>实际上该链表最强大的地方是做到抽象分离,和外层结构体无关,但又能经过偏移量的计算获得外部结构体的内存地址(因为结构体的偏移量在编写代码的时候就已经固定下来了).</p>
<p>我们假设链表结构体在自定义struct内存的最底层,偏移量为0,而我们又知道链表的结构,我们可以利用偏移量一个递推一个来获得Person在内存中的地址,而且这个时候我们仅仅是单靠字节数就推算处理整个Person的大小(和指针).刚刚假定linux的偏移位置是0,实际上是可以在其他位置计算出整个Person的大小(和指针).</p>
<p>需要注意的是,一定要清楚自己定义结构体的层次和结构</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-感悟&quot;&gt;&lt;a href=&quot;#1-感悟&quot; class=&quot;headerlink&quot; title=&quot;1.感悟&quot;&gt;&lt;/a&gt;1.感悟&lt;/h4&gt;&lt;p&gt;之前在重新学习C语言的时候,觉得前人设计的链表非常精妙,值得我们学习,一般来说,普通的指针就是有数据域和指针域构成:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中常用的设计模式</title>
    <link href="http://yoursite.com/2017/07/10/iOS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/07/10/iOS中常用的设计模式/</id>
    <published>2017-07-10T09:15:48.000Z</published>
    <updated>2017-07-10T09:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS设计模式"><a href="#iOS设计模式" class="headerlink" title="iOS设计模式"></a>iOS设计模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>可能我们在很多编写代码的时候都没有留意,其实设计模式无处不在,iOS中经典的模式我们都耳熟能详,例如单例模式,工厂模式等等,设计模式可以优化框架的维护性,也可以使得程序在迭代的过程中更便于扩展,设计模式听上去距离我们很远.</li>
<li><p>但事实上却距离我们很近,在最初学习iOS的过程中,并没有什么需要扩展程序的概念,但是在后期加入工作当中的时候才明白,很多需要并不是一下子就能确定下来的,而是在交流和沟通的过程中不断修改的.而我们在学习编程的过程中,为了避免重复编码,复制黏贴这样的毛病,在设计界面,理念,逻辑的时候要考虑好程序的健壮性,思考才是提升能力的关键,既然能打开网络的世界,浏览不同的最新资讯,想必大家也是非常好学和乐意提高自己的编程水平的.</p>
</li>
<li><p>写下这篇文章主要是记录下自己学习过程中的一些心得吧,之前看到设计模式庞大的家族有点被震住,感觉并不是每种设计模式都要生搬硬套到自己的项目当中,判断设计模式对当前系统是否有帮助才是最重要的,每种设计模式都有自己的优点和不足之处,所以在编程的过程中还请大家更多的思考.</p>
</li>
<li><p>本人在学习的过程中主要是参考了 <strong>[大话设计模式]</strong>,虽然语言是Java写的,但是在阅读的过程中也有很多收获,Java作为一门古老而健壮的语言已经很很长历史了,所以设计模式在Java中可能更为体系,而iOS中我看过一本名为<strong>[Objective-C编程之道：IOS设计模式解析]</strong>,感觉里面的内容更为切合与贴近iOS的程序开发,感谢作者的总结和分享,我也希望大家能亲自去阅读这两本书,能够直接在里面获得更深刻的体会和认识.</p>
</li>
<li><p>我认为好书要多读几遍才能深刻理解,常翻常新,这里是本人的初读体会,但随着时间的推移,也会及时更新本人对设计模式的理解和感悟,谢谢</p>
</li>
</ul>
<h2 id="一-简单工厂模式"><a href="#一-简单工厂模式" class="headerlink" title="一. 简单工厂模式"></a>一. 简单工厂模式</h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>简单工厂模式（Simple Factory Pattern）</strong>属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>工厂模式大家都非常熟悉,也可以写出结构优良的工厂模式代码,所以这里就简单的举例说明即可.</p>
<h4 id="2-模式"><a href="#2-模式" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>假设现在有一家工厂在生产手机,但是手机的类型暂时还不确定,等到用户需求确定了,再决定扩大某条生产线来生产手机,该工厂主要有两种产品:Android和IPhone;</p>
<h5 id="SMMobilePhone-h"><a href="#SMMobilePhone-h" class="headerlink" title="SMMobilePhone.h"></a>SMMobilePhone.h</h5><ul>
<li>主要就是一个useCall方法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">//手机基类</div><div class="line">@interface SMMobilePhone : NSObject</div><div class="line">-(void)useCall;</div><div class="line">@end</div><div class="line">//苹果,继承手机基类</div><div class="line">@interface SMIPhone : SMMobilePhone</div><div class="line">@end</div><div class="line">//安卓,继承手机基类</div><div class="line">@interface SMAndroid : SMMobilePhone</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="SMMobilePhone-m"><a href="#SMMobilePhone-m" class="headerlink" title="SMMobilePhone.m"></a>SMMobilePhone.m</h5><ul>
<li>类的初始化和方法的实现,没啥好解析的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &quot;SMMobilePhone.h&quot;</div><div class="line"></div><div class="line">@implementation SMMobilePhone</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@类初始化中&quot;,self.class);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(void)useCall&#123;</div><div class="line">    NSLog(@&quot;使用%@,呼叫10086中...&quot;,self.class);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">@implementation SMIPhone</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SMAndroid</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来为了使用用户的不同需求,我们对建立了一个工厂模式,用户需要什么类型的手机,只有下单了,我们都可以直接生产成型:</p>
<h5 id="SMFactoryImpl-h"><a href="#SMFactoryImpl-h" class="headerlink" title="SMFactoryImpl.h"></a>SMFactoryImpl.h</h5><ul>
<li>提供类方法返回手机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;SMMobilePhone.h&quot;</div><div class="line">//选择生产什么手机</div><div class="line">typedef enum : NSInteger&#123;</div><div class="line">    IPhone,</div><div class="line">    Android,</div><div class="line">&#125;IPhoneType;</div><div class="line"></div><div class="line">@protocol SMFactory &lt;NSObject&gt;</div><div class="line">//提供类方法直接返回手机</div><div class="line">+(SMMobilePhone*)creatMobileWithType:(IPhoneType)type;</div><div class="line">@end</div><div class="line">@interface SMFactoryImpl : NSObject&lt;SMFactory&gt;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="SMFactoryImpl-m"><a href="#SMFactoryImpl-m" class="headerlink" title="SMFactoryImpl.m"></a>SMFactoryImpl.m</h5><ul>
<li>利用枚举判断手机类型,实例化手机类(此处可以继续添加不同种类的手机)</li>
<li>利用了类的多态形式,返回值是父类,工厂生产出来的是子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;SMFactoryImpl.h&quot;</div><div class="line">@implementation SMFactoryImpl</div><div class="line"></div><div class="line"></div><div class="line">+(SMMobilePhone *)creatMobileWithType:(IPhoneType)type&#123;</div><div class="line">    </div><div class="line">    switch (type) &#123;</div><div class="line">        case IPhone:</div><div class="line">            return [[SMIPhone alloc]init];</div><div class="line">            break;</div><div class="line">        case Android:</div><div class="line">            return [[SMAndroid alloc]init];</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Test.m</p>
<ul>
<li>代码测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    SMMobilePhone * iphone = [SMFactoryImpl creatFactoryWithType:IPhone];</div><div class="line">    SMMobilePhone * android = [SMFactoryImpl creatFactoryWithType:Android];</div><div class="line">    [iphone useCall];</div><div class="line">    [android useCall];</div><div class="line"></div><div class="line">//打印结果</div><div class="line">//Design4OC[3636:398753] SMIPhone类初始化中</div><div class="line">//Design4OC[3636:398753] SMAndroid类初始化中</div><div class="line">//Design4OC[3636:398753] 使用SMIPhone,呼叫10086中...</div><div class="line">//Design4OC[3636:398753] 使用SMAndroid,呼叫10086中...</div></pre></td></tr></table></figure>
<h4 id="3-用途"><a href="#3-用途" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><p>工厂模式的用途非常广泛,可以基于面向对象的三大特性达到不同的效果,比如复杂类的构建过程(封装),父类指针可以指向子类对象(多态),也可以减低业务之间的耦合度.</p>
<h2 id="二-策略模式"><a href="#二-策略模式" class="headerlink" title="二.策略模式"></a>二.策略模式</h2><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>策略模式(Strategy)</strong> : 它定义了算法家族,分别封装起来,让它们之间可以<strong>相互替换</strong>,此模式让算法的改变,不会影响到算法的客户端.</p>
<p>用通俗一点的话来说,就是更改算法,不需要大量改动客户端内容.</p>
<h4 id="2-模式-1"><a href="#2-模式-1" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>比如现在商场是按原价将货物售出,但是遇到周年庆,老板打算让所有商品都按9.5折出售,这个业务很简单,只需要在代码上乘以一个系数就可以了(此时已经修改了客户端源码,有不妥之处).</p>
<p>过了一段时间以后,老板大婚,决定让商场里面的所有货物都打8.0出售,此时是不是我们又要去修改代码才能改变折扣呢?</p>
<p>…为了将临近过期的货物进口售出,此时老板决定临近过期的商品3.0折出售,另外,如果客户买满300减免100元.在业务不断变化的情况下,如果要经常修改源码才能满足业务需求的话,那可能要思考一下是否要改变一下代码的构造.</p>
<p>我们引入一个更为简单的例子来引入策略模式.</p>
<p>我们熟悉的钢铁侠既能在陆地急速奔跑,也能在水中潜行,更不要说在天空自由飞翔了,那么,每次切换不同模式,我们都可以理解为有一套最优的策略(算法)来适应陆地,海水和天空.</p>
<p>我们先定义个接口类来统一方法的调用:</p>
<h5 id="IStrategy-h"><a href="#IStrategy-h" class="headerlink" title="IStrategy.h"></a>IStrategy.h</h5><ul>
<li>operate含有相关操作 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol IStrategy &lt;NSObject&gt;</div><div class="line">-(void)operate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="STContext-h"><a href="#STContext-h" class="headerlink" title="STContext.h"></a>STContext.h</h5><ul>
<li>上下文,用来对策略(算法)的引用,使用初始化方法initWithIstragty赋值id<istrategy>引用</istrategy></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STContext : NSObject&lt;IStrategy&gt;</div><div class="line">+(instancetype)initWithIstragty:(id&lt;IStrategy&gt;)iStrategy;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="STContext-m"><a href="#STContext-m" class="headerlink" title="STContext.m"></a>STContext.m</h5><ul>
<li>此处只要实现了算法接口的类都可以当做实现类id传入,内部获取到id的引用以后,直接调用同名方法operate,内部再调用id的operate方法,直到现在,STContext不需要管id的实现,主要对接口调用即可.(可以慢慢体会面向接口编程的好处.)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;STContext.h&quot;</div><div class="line">@interface STContext()</div><div class="line">@property (nonatomic , strong ) STContext *impl;</div><div class="line">@end</div><div class="line">@implementation STContext</div><div class="line"></div><div class="line">+(instancetype)initWithIstragty:(id&lt;IStrategy&gt;)iStrategy&#123;</div><div class="line">    STContext * i =  [[STContext alloc] init];</div><div class="line">    i.impl = iStrategy;</div><div class="line">    return i;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)operate&#123;</div><div class="line">    </div><div class="line">    [self.impl operate];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后有三个实现了IStrategy接口的类,分别是:<strong>STFly</strong>,<strong>STSwimming</strong>,<strong>STSwimming</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STFly : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div><div class="line">--------------------</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STSwimming : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div><div class="line">--------------------</div><div class="line">#import &quot;IStrategy.h&quot;</div><div class="line">@interface STRunning : NSObject&lt;IStrategy&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="m"><a href="#m" class="headerlink" title=".m"></a>.m</h5><ul>
<li>此处是各个.m文件对接口的实现,对号入座即可.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)operate&#123;</div><div class="line">    NSLog(@&quot;启动飞行模式&quot;);//fly</div><div class="line">    NSLog(@&quot;启动游泳模式&quot;);//swimming</div><div class="line">    NSLog(@&quot;启动奔跑模式&quot;);//running</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Test-m"><a href="#Test-m" class="headerlink" title="Test.m"></a>Test.m</h5><ul>
<li>此时你可以发现,主要简单的修改类,即可完全改变算法,切换成奔跑模式,飞行模式,潜行模式等</li>
<li>再如一开始商场的例子,虽然可能会写多一些类,但是主要给UI加上一个选择器变可以直接改变定价策略,修改价格和优惠</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//此处的STFly可以替换成Swimming或者Running</div><div class="line">   STContext * is = [STContext initWithIstragty:[[STFly alloc]init]];</div><div class="line">   NSLog(@&quot;%@&quot;,is);</div><div class="line">   [is operate];</div></pre></td></tr></table></figure>
<h4 id="3-用途-1"><a href="#3-用途-1" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><ol>
<li>策略模式可以用来定义一系列是算法,对外提供的接口是相同的,只是改变了内部的实现即产生了不同的效果,核心作用就是用于封装算法</li>
<li>原本我们可以将所有操作封装在一个类里面,每次增加策略就需要在里面增加<code>if else</code>或者<code>switch</code>语句,但是你会发现这样耦合度很高,不方便单个算法的测试–从而也引出了策略模式的另外一个好处:简单化了单元测试,每一个算法就是一个</li>
<li>个人感觉这里算是一个面向对象特性的一个思想提升–运用了协议来统一工作方式,实质上这三个类是三个独立的存在的类,并没有规定统一父类,他们都有着自己的模式和算法.但我的思想暂时还没提高到策略模式的算法层面,只能暂时理解为解决问题的一种策略模式,可能还有偏颇!</li>
</ol>
<h2 id="三-装饰模式"><a href="#三-装饰模式" class="headerlink" title="三.装饰模式"></a>三.装饰模式</h2><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义:"></a>1.定义:</h4><p><strong>装饰模式(Decorate)</strong>,动态地给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成之类更为灵活</p>
<h4 id="2-模式-2"><a href="#2-模式-2" class="headerlink" title="2.模式:"></a>2.模式:</h4><p>如何理解装饰呢?比如说人身上的衣服,鞋子,裤子,帽子都是人身上装饰物品,没有装饰物的人依然有着能自由活动,吃饭,睡觉的基础功能.</p>
<p>再比如我们生活中常见的汽车,我们知道有低配版和高配版之分,只要价格给上去了,很多额外的装饰物都可以给你添上比如普通大灯换为疝气灯,普通沙发换成真皮沙发等等…首先可以理解为为某个类增加功能(增加特殊功能但不改变原有的类)<br>我们举一个简单的例子来说明一下,<br>首先我们有个组装的协议<br>DEComponent.h</p>
<ul>
<li>该协议里面含有一个operation的基础操作方法,类比汽车的时候可以理解为:即使我没有真皮沙发,没有疝气大灯,依然可以执行最基础的行驶功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol DEComponent &lt;NSObject&gt;</div><div class="line">-(void)operation;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DEBaseCar-h"><a href="#DEBaseCar-h" class="headerlink" title="DEBaseCar.h"></a>DEBaseCar.h</h5><ul>
<li>然后,我们以车为例子,当然需要有一个车的实例,该类遵守了协议,里面有operation方法</li>
<li>baseCar独立存在,可以不知道有其他装饰类的存在,不影响最基础的工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;DEComponent.h&quot;</div><div class="line">@interface DEBaseCar : NSObject&lt;DEComponent&gt;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DEBaseCar-m"><a href="#DEBaseCar-m" class="headerlink" title="DEBaseCar.m"></a>DEBaseCar.m</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &quot;DEBaseCar.h&quot;</div><div class="line"></div><div class="line">@implementation DEBaseCar</div><div class="line">-(void)operation&#123;</div><div class="line">    NSLog(@&quot;最基本的车,具备了安全行驶功能&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>以上功能,我们就具备了一辆最基础的车,但是现在这里车没有满足你的要求,你想要加装一些零部件,这个时候就有了新的需求</p>
<h5 id="DECarComponent-h"><a href="#DECarComponent-h" class="headerlink" title="DECarComponent.h"></a>DECarComponent.h</h5><ul>
<li>DECarDecorator是装饰者类,它定义了<strong>extraComponentOn:</strong>方法用来增强baseCar的功能,也对对象进行了包装,从而实现了每个装饰者类都可以有自己独特的功能(这样的结构会使得功能相互独立开来,有了很好的扩展),并在有需要的时候增强baseCar功能实现</li>
<li>DECarDecorator它可以是抽象基类,也可以是单个装饰者类</li>
<li>DESofaDecorator,DELightDecorator,DEDogDecorator作为装饰者类的子类,都有着自己独特的方法和属性</li>
<li>DESofaDecorator作为普通类,只给车辆换上沙发</li>
<li>DELightDecorator给汽车赋予了新亮度,有远光和近光的功能实现(装饰后拥有的独特方法)</li>
<li>DEDogDecorator香车洋狗和美女都是配在一起的,而狗可以有自己的名字(其他类不会有狗,狗也不会有名字)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;DEComponent.h&quot;</div><div class="line">@interface DECarDecorator : NSObject&lt;DEComponent&gt;</div><div class="line">@property (nonatomic , strong ,setter=extraComponentOn:) id&lt;DEComponent&gt; component;</div><div class="line">@end</div><div class="line"></div><div class="line">/*------------------作为装饰汽车的沙发(不含参数和方法)--------------------*/</div><div class="line">@interface DESofaDecorator : DECarDecorator</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的疝气灯(含私有方法)--------------------*/</div><div class="line">@interface DELightDecorator : DECarDecorator</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的养狗(含公有属性)--------------------*/</div><div class="line">@interface DEDogDecorator : DECarDecorator</div><div class="line">@property (nonatomic , strong ) NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="DECarComponent-m"><a href="#DECarComponent-m" class="headerlink" title="DECarComponent.m"></a>DECarComponent.m</h5><ul>
<li>类的属性和方法已经在上面简要说明,可以忽略这部分不看.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;DECarDecorator.h&quot;</div><div class="line"></div><div class="line">@implementation DECarDecorator</div><div class="line"></div><div class="line">-(void)extraComponentOn:(id&lt;DEComponent&gt;)component&#123;</div><div class="line">    _component = component;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)operation&#123;</div><div class="line">    if (self.component != nil) &#123;</div><div class="line">        [self.component operation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">/*------------------作为装饰汽车的沙发(不含参数和方法)--------------------*/</div><div class="line">@implementation DESofaDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    NSLog(@&quot;高配版要的就是豪华沙发...&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的沙发(含私有方法)--------------------*/</div><div class="line">//远光近光</div><div class="line">typedef enum : NSUInteger &#123;</div><div class="line">    HighLight,</div><div class="line">    LowLitght</div><div class="line">&#125; LightType;</div><div class="line"></div><div class="line">@implementation DELightDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    NSLog(@&quot;装饰了疝气灯以后可以开启照明功能&quot;);</div><div class="line">    </div><div class="line">    [self openLight:arc4random()%2];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)openLight:(LightType)ligthType&#123;</div><div class="line">    switch (ligthType) &#123;</div><div class="line">        case HighLight:</div><div class="line">            NSLog(@&quot;开启了远光灯&quot;);</div><div class="line">            break;</div><div class="line">        case LowLitght:</div><div class="line">            NSLog(@&quot;开启了近光灯&quot;);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">/*------------------作为装饰汽车的养狗(含公有属性)--------------------*/</div><div class="line">@implementation DEDogDecorator</div><div class="line">-(void)operation&#123;</div><div class="line">    [super operation];</div><div class="line">    if (self.name ==nil) &#123;</div><div class="line">        NSLog(@&quot;刚刚捡回来的小狗没有名字&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;%@,跟大家打招呼吧!&quot;,self.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="Test-m-1"><a href="#Test-m-1" class="headerlink" title="Test.m"></a>Test.m</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;---最新出厂---&quot;);</div><div class="line">DEBaseCar * car = [[DEBaseCar alloc] init];</div><div class="line">NSLog(@&quot;---把沙发,疝气灯,狗搬到装配车间---&quot;);</div><div class="line">DESofaDecorator * sofaDecorator = [[DESofaDecorator alloc] init];</div><div class="line">DELightDecorator * lightDecorator = [[DELightDecorator alloc] init];</div><div class="line">DEDogDecorator * dogDecorator = [[DEDogDecorator alloc] init];</div><div class="line">//设置狗的名字</div><div class="line">[dogDecorator setName:@&quot;旺财&quot;];</div><div class="line">NSLog(@&quot;开始装饰,将需要的东西组装到车上&quot;);</div><div class="line">[sofaDecorator extraComponentOn:car];</div><div class="line">[lightDecorator extraComponentOn:sofaDecorator];</div><div class="line">[dogDecorator extraComponentOn:lightDecorator];</div><div class="line">NSLog(@&quot;---------------------&quot;);</div><div class="line">[dogDecorator operation];</div><div class="line">//打印结果</div><div class="line">//Design4OC[8316:763030] ---最新出厂---</div><div class="line">//Design4OC[8316:763030] ---把沙发,疝气灯,狗搬到装配车间---</div><div class="line">//Design4OC[8316:763030] 开始装饰,将需要的东西组装到车上</div><div class="line">//Design4OC[8316:763030] ---------------------</div><div class="line">//Design4OC[8316:763030] 最基本的车,具备了安全行驶功能</div><div class="line">//Design4OC[8316:763030] 高配版要的就是豪华沙发...</div><div class="line">//Design4OC[8316:763030] 装饰了疝气灯以后可以开启照明功能</div><div class="line">//Design4OC[8316:763030] 开启了近光灯</div></pre></td></tr></table></figure>
<h4 id="3-用途-2"><a href="#3-用途-2" class="headerlink" title="3. 用途:"></a>3. 用途:</h4><ol>
<li>装饰者模式可以理解为在一个基础的类上,增强或增加某些功能的实现,大家在维护老代码的时候不一定方便直接修改源码(当增强的功能并不常用,这个时候其实不应该直接修改源码,额外的增加了这个类的职责和负担,违背了职责单一的原则)</li>
<li>把核心功能和其他功能区分开,方便拆装和管理</li>
<li>个人感觉,使用分类也能增加类的实现,在不导入分类的头文件时,其实类的功能也没有加载进来,也像是一种装饰者的特殊实现吧,以后有更多的体会再来更改现在的想法</li>
</ol>
<h2 id="四-工厂方法模式"><a href="#四-工厂方法模式" class="headerlink" title="四.工厂方法模式"></a>四.工厂方法模式</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>工厂方法模式(Factory Method)</strong>:定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使得一个类的实例化延迟到其子类.</p>
<h4 id="2-模式-3"><a href="#2-模式-3" class="headerlink" title="2. 模式"></a>2. 模式</h4><p>为何前面有说一个简单工厂模式,现在又来一个工厂方法模式?看到定义估计还比较模模糊糊,实际上工厂模式是简单工厂模式的抽象和推广.</p>
<p>简单工厂模式是在内部case判断返回什么内容给控制器,同一个工厂可以生产不同的产品,而如果需要修改产品的类型,就需要重新在内部部署生产设备,在工厂内部协调工作</p>
<p>而工厂模式是在控制器就选择好了要生成什么类型的类,不同的工厂生产不同的产品,每个工厂都有自己独特的产品,接到指令时不需要在内部协调就可以直接生产产品.先上代码:</p>
<h5 id="FMMobilePhoneFactory-h"><a href="#FMMobilePhoneFactory-h" class="headerlink" title="FMMobilePhoneFactory.h"></a>FMMobilePhoneFactory.h</h5><ul>
<li>FMFactoryProtocol: 是工厂模式的抽象接口,使子类有一个实例化方法</li>
<li>FMMobilePhoneFactory:作为工厂基类,其他的工厂类应该继承该父类</li>
<li>FMIPhoneFactory和FMAndroidFactory: 父类是FMMobilePhoneFactory,使用协议方法的时候可以实例化具体的产品</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line">@class FMMobilePhoneFactory;</div><div class="line"></div><div class="line">//</div><div class="line">@protocol FMFactoryProtocol&lt;NSObject&gt;</div><div class="line">-(FMMobilePhone*)creatFactory;</div><div class="line">@end</div><div class="line">//工厂基类</div><div class="line">@interface FMMobilePhoneFactory : NSObject&lt;FMFactoryProtocol&gt;</div><div class="line"></div><div class="line">@end</div><div class="line">//苹果工厂,继承工厂基类</div><div class="line">@interface FMIPhoneFactory : FMMobilePhoneFactory</div><div class="line">@end</div><div class="line">//安卓工厂,继承工厂基类</div><div class="line">@interface FMAndroidFactory : FMMobilePhoneFactory</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="FMMobilePhoneFactory-m"><a href="#FMMobilePhoneFactory-m" class="headerlink" title="FMMobilePhoneFactory.m"></a>FMMobilePhoneFactory.m</h5><ul>
<li>不同的工厂生产不同的产品,基类不可直接使用,这里不再做判断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &quot;FMMobilePhoneFactory.h&quot;</div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line">@implementation FMMobilePhoneFactory</div><div class="line"></div><div class="line">-(FMMobilePhone*)creatFactory&#123;</div><div class="line">    return [[FMMobilePhone alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">@implementation FMIPhoneFactory</div><div class="line">-(FMMobilePhone *)creatFactory&#123;</div><div class="line">    return [[FMIPhone alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FMAndroidFactory</div><div class="line">-(FMMobilePhone *)creatFactory&#123;</div><div class="line">    return [[FMAndroid alloc]init];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="FMMobilePhone-h"><a href="#FMMobilePhone-h" class="headerlink" title="FMMobilePhone.h"></a>FMMobilePhone.h</h5><h5 id="FMMobilePhone-m"><a href="#FMMobilePhone-m" class="headerlink" title="FMMobilePhone.m"></a>FMMobilePhone.m</h5><ul>
<li>产品类在简单工厂模式的时候已经讲过了,也比较简单,自己可以看看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface FMMobilePhone : NSObject</div><div class="line">-(void)useCall;</div><div class="line">@end</div><div class="line">//苹果,继承手机基类</div><div class="line">@interface FMIPhone : FMMobilePhone</div><div class="line">@end</div><div class="line">//安卓,继承手机基类</div><div class="line">@interface FMAndroid : FMMobilePhone</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//-------------.m------------------</div><div class="line"></div><div class="line">#import &quot;FMMobilePhone.h&quot;</div><div class="line"></div><div class="line">@implementation FMMobilePhone</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@类初始化中&quot;,self.class);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(void)useCall&#123;</div><div class="line">    NSLog(@&quot;使用%@,呼叫10086中...&quot;,self.class);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FMIPhone@end</div><div class="line"></div><div class="line">@implementation FMAndroid@end</div></pre></td></tr></table></figure>
<h5 id="Test-m-2"><a href="#Test-m-2" class="headerlink" title="Test.m"></a>Test.m</h5><ul>
<li>下面是控制器的调用,我们可以看到,其实两台代码完全相同,就只是在实例化工厂的时候选择了FMIPhoneFactory和FMAndroidFactory就可以改变产品的产品,避免了产品增多的时候要修改工厂类(实际上是违背了封闭-开放原则)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FMMobilePhoneFactory * iphoneFactory = [[FMIPhoneFactory alloc]init];</div><div class="line">  FMMobilePhone * iphone = [iphoneFactory creatFactory];</div><div class="line">  [iphone useCall];</div><div class="line">  </div><div class="line">  FMMobilePhoneFactory * andoridFactory = [[FMAndroidFactory alloc]init];</div><div class="line">  FMMobilePhone * andorid = [andoridFactory creatFactory];</div><div class="line">  [andorid useCall];</div><div class="line">  </div><div class="line">   //FMIPhone类初始化中</div><div class="line">   //使用FMIPhone,呼叫10086中...</div><div class="line">   //FMAndroid类初始化中</div><div class="line">   //使用FMAndroid,呼叫10086中...</div></pre></td></tr></table></figure>
<h4 id="3-用途-3"><a href="#3-用途-3" class="headerlink" title="3.用途"></a>3.用途</h4><ol>
<li>实际上是简单工厂模式的抽象和推广,克服了简单工厂模式违背了封闭-开放原则,又保持了封装对象的优点</li>
<li>把从工厂的内部判断移动到了控制器,产生子类的选择更加灵活</li>
<li>个人感觉,一直都习惯了在工厂类中做了条件判断来生产不同的产品类,而且每产生多一个产品就要多一个工厂类和产品类,工作量有所增加,如果能用运行时来产生不同的子类更好</li>
</ol>
<h2 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五.原型模式"></a>五.原型模式</h2><h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>原型模式(Prototype)</strong>:用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象.</p>
<h4 id="2-模式-4"><a href="#2-模式-4" class="headerlink" title="2.模式"></a>2.模式</h4><p>其实这篇文章就是要说明<strong>复制</strong>这个概念,网上也很多文章无数次分析深拷贝和浅拷贝了,这里就不在详细说明深拷贝和浅拷贝的内容了,深拷贝复制对象,浅拷贝复制引用地址.</p>
<p>现在来举例说明,我们有一个学生对象和书本对象,里面分别有如下属性:</p>
<p>PTStudent.h</p>
<ul>
<li>学生手中有一本书,直接拿在手上看的,属性为:book</li>
<li>书包里面有很多书,用<code>NSMutableArray&lt;PTBook*&gt;</code> 存储</li>
<li>学生还有名字和年龄两个属性</li>
<li>学生还有不同的老师,用字符串来表示<code>NSMutableArray&lt;NSString*&gt;</code>(也可以理解为老师只有一个,大家共享这个字符串的资源)</li>
</ul>
<h6 id="PTStudent-h"><a href="#PTStudent-h" class="headerlink" title="PTStudent.h"></a>PTStudent.h</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;PTBook.h&quot;</div><div class="line">@interface PTStudent : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic , strong ) PTBook *book;</div><div class="line">@property (nonatomic , strong ) NSString *name;</div><div class="line">@property (nonatomic , assign ) int age;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;NSString*&gt; *teachers;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;PTBook*&gt; *package;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTBook-h"><a href="#PTBook-h" class="headerlink" title="PTBook.h"></a>PTBook.h</h5><ul>
<li>书本有名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface PTBook : NSObject&lt;NSCopying&gt;</div><div class="line">@property (nonatomic , strong ) NSString *bookName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTBook-m"><a href="#PTBook-m" class="headerlink" title="PTBook.m"></a>PTBook.m</h5><ul>
<li><code>book.bookName = [NSString stringWithFormat:@&quot;%@&quot;,self.bookName];</code>这个是作为深复制存在,开辟了新的内存空间</li>
<li><code>book.bookName = [self.bookName copy];</code> 此时使用的是浅复制,共享常量字符串的内容,可以结合内存地址查看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#import &quot;PTBook.h&quot;</div><div class="line"></div><div class="line">@implementation PTBook</div><div class="line">-(id)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    </div><div class="line">     book.bookName = [NSString stringWithFormat:@&quot;%@&quot;,self.bookName];</div><div class="line">    /*</div><div class="line">     (lldb) p student.book.bookName</div><div class="line">     (__NSCFConstantString *) $0 = 0x00000001043616b0 @&quot;B&quot;</div><div class="line">     (lldb) p otherStudent.book.bookName</div><div class="line">     (NSTaggedPointerString *) $1 = 0xa000000000000421 @&quot;B&quot;</div><div class="line">     (lldb)</div><div class="line">     </div><div class="line">     </div><div class="line">     */</div><div class="line">    </div><div class="line">    </div><div class="line">//book.bookName = [self.bookName copy];</div><div class="line">    </div><div class="line">    /*</div><div class="line">     (lldb) p student.book.bookName</div><div class="line">     (__NSCFConstantString *) $0 = 0x00000001074466b0 @&quot;B&quot;</div><div class="line">     (lldb) p otherStudent.book.bookName</div><div class="line">     (__NSCFConstantString *) $1 = 0x00000001074466b0 @&quot;B&quot;</div><div class="line">     (lldb)</div><div class="line">     */</div><div class="line"></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="PTStudent-m"><a href="#PTStudent-m" class="headerlink" title="PTStudent.m"></a>PTStudent.m</h5><ul>
<li>常量字符串在常量区共享,也可以用字符串对象开辟新的内存空间</li>
<li>由于age是NSUInteger类型的，属于基本数据类型，则直接赋值</li>
<li>book对象遵守了NSCopying协议,里面已经处理,可以直接用copy方法深复制</li>
<li>teachers作为了常量字符串容器,里面的字符串是共享的,但是容器是作了深拷贝</li>
<li>package里面装有book对象,除了拿到新容器外,还需要把book存进容器里面,这个时候就可以使用遍历或者<code>copyItems:YES</code>这种方式(后来才找到有这个方法…)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#import &quot;PTStudent.h&quot;</div><div class="line">@interface PTStudent()</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation PTStudent</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        PTBook* book = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;新华字典&quot;;</div><div class="line">        </div><div class="line">        PTBook* bookA = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;A&quot;;</div><div class="line">        </div><div class="line">        PTBook* bookB = [[PTBook alloc]init];</div><div class="line">        book.bookName = @&quot;B&quot;;</div><div class="line">        </div><div class="line">        self.book = book;</div><div class="line">        self.name = @&quot;小明&quot;;</div><div class="line">        self.age = 18;</div><div class="line">        self.teachers = [NSMutableArray arrayWithObjects:@&quot;张飞&quot;,@&quot;刘备&quot;,@&quot;关羽&quot;, nil];</div><div class="line">        self.package=[NSMutableArray arrayWithObjects:bookA,bookB, nil];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">-(id)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    PTStudent* student = [[[self class] allocWithZone:zone]init];</div><div class="line">    student.age = self.age;</div><div class="line">    student.book = [self.book copy];</div><div class="line">    //这里会深复制,再开辟内存空间</div><div class="line">    student.name = [NSString stringWithFormat:@&quot;%@&quot;,self.name];</div><div class="line">    student.teachers = [NSMutableArray arrayWithArray:self.teachers];</div><div class="line">    //NSMutableArray&lt;PTBook*&gt; *package;</div><div class="line">    student.package = [NSMutableArray array];</div><div class="line">    </div><div class="line"> //原本是打算通过遍历的方法来深复制</div><div class="line">//    [self.package enumerateObjectsUsingBlock:^(PTBook * _Nonnull book, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">//        [student.package addObject:[book copy]];</div><div class="line">//    &#125;];</div><div class="line"></div><div class="line">    //后来发现一种不需要遍历的方法,如果你只需要数组中数组第一层的深拷贝,那么</div><div class="line">    student.package= [[NSMutableArray alloc] initWithArray:self.package copyItems:YES];</div><div class="line">    </div><div class="line">    </div><div class="line">    //这里是浅复制</div><div class="line">    //指向的是常量区</div><div class="line">    ////student.name = [self.name copy];</div><div class="line">    //此处数组可以复制,但是里面每一个元素的指针都是没有被复制的,和原来的类型指向同一内容</div><div class="line">    //student.teachers = [self.teachers mutableCopy];</div><div class="line">//    student.package = [NSMutableArray mutableCopy];</div><div class="line">    return student;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="3-用途-4"><a href="#3-用途-4" class="headerlink" title="3.用途"></a>3.用途</h4><ol>
<li>需要重复创建对象的时候可以考虑使用原型模式</li>
<li>原型模式也属于创建模式的一种,工厂模式会new一个全新的对象,使用原型模式就可以拷贝一份对象出来,工厂模式和原型模式其实效率差不多,但是如果在大量创建数据的时候,原型模式则更加节省资源,效率更高.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS设计模式&quot;&gt;&lt;a href=&quot;#iOS设计模式&quot; class=&quot;headerlink&quot; title=&quot;iOS设计模式&quot;&gt;&lt;/a&gt;iOS设计模式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息转发的performSelector和invocation</title>
    <link href="http://yoursite.com/2016/12/15/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E7%9A%84performSelector%E5%92%8Cinvocation/"/>
    <id>http://yoursite.com/2016/12/15/消息转发的performSelector和invocation/</id>
    <published>2016-12-15T13:09:39.000Z</published>
    <updated>2016-12-15T15:09:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="消息转发实际上是调用了C底层的函数"><a href="#消息转发实际上是调用了C底层的函数" class="headerlink" title="消息转发实际上是调用了C底层的函数"></a>消息转发实际上是调用了C底层的函数</h4><p>我们都知道在OC中方法,使用方法叫做发送消息,其实这种说法主要是因为OC在调用方法的时候会将一个方法转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div></pre></td></tr></table></figure>
<p>该第一个参数是对象,第二个参数是方法名字,第三个参数是方法参数.<br>这个时候,如果给对象发送一个当前对象不存在的方法,系统暂时还不会崩溃,它还会调用三个方法给开发者上次机会补救这个方法的”缺失”(事实上是因此OC才能成为一门真正动态的语言)</p>
<h4 id="给函数发送失败后会发生什么事情"><a href="#给函数发送失败后会发生什么事情" class="headerlink" title="给函数发送失败后会发生什么事情"></a>给函数发送失败后会发生什么事情</h4><ul>
<li>1.动态方法解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;//实例方法</div><div class="line">+ (BOOL)resolveClassMethod : (SEL)selector//类方法</div></pre></td></tr></table></figure>
<p>首先，当接受到未能识别的选择子时，运行时系统会调用该函数用以给对象一次机会来添加相应的方法实现，如果用户在该函数中动态添加了相应方法的实现，则跳转到方法的实现部分，并将该实现存入缓存中，以供下次调用。(52个建议中写道,其实这个缓存机制会缓存在”快速哈希表”中,下次获取的时候就能首先在这个方法列表中寻找高频使用的方法,减少遍历次数)</p>
<p>首先我们先定义一个Person类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Person.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic ,copy ) NSString* name;</div><div class="line">@property (nonatomic , assign ) NSUInteger age;</div><div class="line">-(void)run:(NSString*)name withWhere:(NSString*)where;</div><div class="line">-(void)eat;</div><div class="line">-(void)dynamicSelector;</div><div class="line">@end</div><div class="line">----------------------------------------------</div><div class="line">Person.m</div><div class="line">@implementation Person</div><div class="line">-(void)run:(NSString*)name withWhere:(NSString*)where&#123;</div><div class="line">    NSLog(@&quot;%@ is running in %@ &quot;,name,where);</div><div class="line">&#125;</div><div class="line">-(void)eat&#123;</div><div class="line">    NSLog(@&quot;eat&quot;);</div><div class="line">&#125;</div><div class="line">-(void)dynamicSelector&#123;</div><div class="line">    NSLog(@&quot;dynamicSelector&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>好吧,很简单的一个类,主要有一个run/eat/dynamicSelector方法.没有其他好介绍的了,接下来我们在控制器中实例化一个对象,然后调用某个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person * p = [[Person alloc]init];</div><div class="line">    self.person = p;</div><div class="line"></div><div class="line">#pragma clang diagnostic push//添加该代码可以去除编译器带来的警告,好烦人啊,后面就不再写这句了,默认在找不到方法的地方都应该添加这几行代码</div><div class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</div><div class="line">    [self performSelector:@selector(dynamicSelector) withObject:nil];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>
<p>因为self里面肯定没有dynamicSelector啊,我们想要在这里调用Person中的dynamicSelector要怎么办呢?<br>这里就可以使用我们动态方法解析机制了,系统在该类中找不到这个方法的时候就会调用下面这个函数,执行里面的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//定义一个备用的C方法来防止程序崩溃</div><div class="line">void myMehtod(id self,SEL _cmd)&#123;</div><div class="line">    NSLog(@&quot;This is added dynamic&quot;);</div><div class="line">&#125;</div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">   </div><div class="line">    if (sel == @selector(dynamicSelector)) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)myMehtod, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125; else &#123;</div><div class="line">        return [super resolveInstanceMethod:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处被调用后,控制台打印了”This is added dynamic”</p>
<ul>
<li><ol>
<li>备援接收者</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>如果运行时在消息转发的第一步中未找到所调用方法的实现，那么当前接收者还有第二次机会进行未知选择子的处理。这时运行期系统会调用上述方法，并将未知选择子作为参数传入，该方法可以返回一个能处理该选择子的对象，运行时系统会根据返回的对象进行查找，若找到则跳转到相应方法的实现，则消息转发结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">    </div><div class="line">    if (aSelector==@selector(dynamicSelector)&amp;&amp;[self.person respondsToSelector:@selector(dynamicSelector)]) &#123;</div><div class="line">        return self.person;</div><div class="line">    &#125; else &#123;</div><div class="line">        return [super forwardingTargetForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的调用频率还是可以很高,因为很多时候此方法的调用还是很廉价的,经过第一步的方法查找如果失败,直接使用这个方法继续查找,这个时候你可以安排这个对象来实现这个方法.如Person中有能够响应dynamicSelector的方法,则返回这个self.Person来执行这个方法,此处打印台中会打印:<strong>dynamicSelector</strong></p>
<ul>
<li>3.完整的消息转发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div></pre></td></tr></table></figure>
<p>当运行时系统检测到第二步中用户未返回能处理相应选择子的对象时，那么来到这一步就要启动完整的消息转发机制了。该方法可以改变消息调用目标，运行时系统根据所改变的调用目标，向调用目标方法列表中查询对应方法的实现并实现跳转，这种方式和第二步的操作非常相似。当然你也可以修改方法的选择子，亦或者向所调用方法中追加一个参数等来跳转到相关方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    if ([self.person respondsToSelector:[anInvocation selector]]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:self.person];</div><div class="line">    &#125; else &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处的代码也会实现Person中的dynamicSelector,这个时候有的同学就懵逼了(反正我是懵逼了),这个NSInvocation到底是什么,怎么这么神奇…</p>
<h3 id="NSInvocation方法调用解析"><a href="#NSInvocation方法调用解析" class="headerlink" title="NSInvocation方法调用解析"></a>NSInvocation方法调用解析</h3><p>标题中写了performSelector和invocation,实际上的更像说说后者,前者由于所带的参数有局限性,所以没有办法,最多只能whitObject*2 ,参数个数一旦超过两个的时候,我们就得想其他办法来布局了.那么,我们首先考虑到的方案就是NSiNInvocation啦.</p>
<ul>
<li>1.要使用该方法,第一步是要进行方法”签名”:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//根据方法来初始化NSMethodSignature</div><div class="line">NSMethodSignature* signature = [Person instanceMethodSignatureForSelector:@selector(run:withWhere:)];</div></pre></td></tr></table></figure>
<p>方法签名中保存了方法的名称/参数/返回值，协同NSInvocation来进行消息的转发.方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系</p>
<p>但有一点要注意:如果方法不存在的话就会崩溃,所以我们在签名以后还要做一件事情:方法不存在的时候抛出异常提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (signature == nil) &#123;</div><div class="line">   NSString *info = [NSString stringWithFormat:@&quot;方法找不到&quot;];</div><div class="line">  [NSException raise:@&quot;方法调用出现异常&quot; format:info, nil];</div><div class="line">        //    NSLog(@&quot;%@&quot;,signature);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2.创建NSInvocation对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NSInvocation* invocation =  [NSInvocation invocationWithMethodSignature:signature];</div><div class="line">   //设置方法调用者</div><div class="line">   invocation.target = self.person;</div><div class="line">    </div><div class="line">    //注意：这里的方法名一定要与方法签名类中的方法一致</div><div class="line">    invocation.selector = @selector(run:withWhere:);</div><div class="line">    </div><div class="line">    //参数</div><div class="line">    NSString* name = @&quot;小寒&quot;;</div><div class="line">    NSString* where = @&quot;广州&quot;;</div><div class="line">    </div><div class="line">    //参数数组</div><div class="line">    NSMutableArray* objects =  [NSMutableArray array];</div><div class="line">    [objects addObject:name];</div><div class="line">    [objects addObject:where];</div></pre></td></tr></table></figure>
<p>这里面的objects数组可以装多个参数,到时会按顺序塞进去参数列表中,供方法调用,下面开始使用下面方法设置参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setArgument:(void *)argumentLocation atIndex:(NSInteger)idx;</div></pre></td></tr></table></figure></p>
<p>方法中的第二个参数就是用来存放插入的方法参数的,这里按道理来说,我们需要使用遍历objects数组的个数来赋值参数,但是由于外界传进来的参数个数是不可控的,此处不能通过遍历参数数组来设置参数.还记得signature做了方法签名吗?其实最开始的时候有提到过,签名后能获得方法的名称/参数/返回值,其中里面还提供了通过numberOfArguments方法获取的参数个数(但是这个方面里面包含了包含self和_cmd的，所以我们要比较方法需要的参数和外界传进来的参数个数，并且取它们之间的最小值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSUInteger argsCount = signature.numberOfArguments - 2;</div><div class="line">    </div><div class="line">    NSUInteger arrCount = objects.count;</div><div class="line">//获取最小值</div><div class="line">    NSUInteger count = MIN(argsCount, arrCount);</div><div class="line">    </div><div class="line">    NSLog(@&quot;argsCount: %ld,arrCount: %ld,count: %ld&quot;,argsCount,arrCount,count);</div><div class="line"></div><div class="line">    for (int i = 0; i&lt;count; i++) &#123;</div><div class="line">        id arg = objects[i];</div><div class="line">        </div><div class="line">        if ([arg isKindOfClass:[NSNull class]]) arg = nil;</div><div class="line">        //这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd),即使方法的参数为空的时候,此处也应该加2</div><div class="line">        [invocation setArgument:&amp;arg atIndex: i + 2 ];</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法的调用和返回值</li>
</ul>
<p>需要调用该方法,实际上就是调用invoke方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">   [invocation invoke];</div></pre></td></tr></table></figure>
<p>执行完这一步以后,就已经可以顺利调用self.person方法中的run:withWhere:方法.</p>
<p>如果你的代码中需要有返回值的话,可以调用下面这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//此处可以获得参数的返回值</div><div class="line">    id res = nil;</div><div class="line">    if (signature.methodReturnLength != 0) &#123;</div><div class="line">        [invocation getReturnValue:&amp;res];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;return : %@&quot;,res);</div></pre></td></tr></table></figure>
<p>现在可以感受到oc中消息调用的魅力了吧,强大之处实在令人佩服,结合runtime来使用的话,就是一种所谓的黑魔法吧.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;消息转发实际上是调用了C底层的函数&quot;&gt;&lt;a href=&quot;#消息转发实际上是调用了C底层的函数&quot; class=&quot;headerlink&quot; title=&quot;消息转发实际上是调用了C底层的函数&quot;&gt;&lt;/a&gt;消息转发实际上是调用了C底层的函数&lt;/h4&gt;&lt;p&gt;我们都知道在OC中方
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Button事件的闭包形式</title>
    <link href="http://yoursite.com/2016/12/04/Button%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%97%AD%E5%8C%85%E5%BD%A2%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/12/04/Button事件的闭包形式/</id>
    <published>2016-12-04T01:40:34.000Z</published>
    <updated>2016-12-04T01:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为业务中经常要用到button的事件点击,但是习惯了BlockKit和RAC的高聚合事件点击写法以后,感觉方法要跳来跳去太麻烦了,特意写一个分类来修改这个弊端,这个分类还包括了一下功能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. addTarget点击事件</div><div class="line">2. 按钮倒计时</div><div class="line">3. 重新排布image和label的位置</div></pre></td></tr></table></figure>
<p>主要代码如下:</p>
<p>.m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface UIButton (XHAdd)</div><div class="line">//button中image和label的相对位置</div><div class="line">typedef enum : NSUInteger&#123;</div><div class="line">    XHButtonImageLocatedLabelTop,</div><div class="line">    XHButtonImageLocatedLabelButtom,</div><div class="line">    XHButtonImageLocatedLabelLeft,</div><div class="line">    XHButtonImageLocatedLabelRight</div><div class="line">&#125;XHButtonImageLocatedLabelEnum;</div><div class="line"></div><div class="line">//设置使得图片和文字的位置改变</div><div class="line">-(void)xh_ButtonImageLocatedLabel:(XHButtonImageLocatedLabelEnum)located whitSpace:(CGFloat)space;</div><div class="line">//设置button在一定时间间隔内不能再次点击</div><div class="line">-(void)xh_buttonBanWithTheCountdown:(int)time;</div><div class="line">//设置某种点击事件后的回调</div><div class="line">-(void)xh_blockWhitControlEvents:(UIControlEvents)ControlEvents block:(void(^)())block;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIButton+XHAdd.h&quot;</div><div class="line">#import &quot;NSTimer+XHAdd.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">typedef void(^ButtonClikcBlock)();</div><div class="line">@interface UIButton()</div><div class="line">@property (nonatomic ,copy )  ButtonClikcBlock block;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation UIButton (HXAdd)</div><div class="line">-(void)xh_ButtonImageLocatedLabel:(XHButtonImageLocatedLabelEnum)located whitSpace:(CGFloat)space&#123;</div><div class="line">//    NSLog(@&quot;label:%@,imageView:%@&quot;,self.titleLabel,self.imageView);</div><div class="line">    </div><div class="line">    CGFloat imageWidth = self.imageView.frame.size.height;</div><div class="line">    CGFloat imageHeight = self.imageView.frame.size.width;</div><div class="line">    </div><div class="line">    CGFloat labelWidth = 0.0;</div><div class="line">    CGFloat labelHeight = 0.0;</div><div class="line">    </div><div class="line">    if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</div><div class="line">        // 由于iOS8中titleLabel的size为0，用下面的这种设置</div><div class="line">        labelWidth = self.titleLabel.intrinsicContentSize.width;</div><div class="line">        labelHeight = self.titleLabel.intrinsicContentSize.height;</div><div class="line">    &#125;else&#123;</div><div class="line">        labelWidth = self.titleLabel.frame.size.width;</div><div class="line">        labelHeight = self.titleLabel.frame.size.height;</div><div class="line">    &#125;</div><div class="line">    // 2. 声明全局的imageEdgeInsets和labelEdgeInsets</div><div class="line">    UIEdgeInsets imageEdgeInsets = UIEdgeInsetsZero;</div><div class="line">    UIEdgeInsets labelEdgeInsets = UIEdgeInsetsZero;</div><div class="line">    </div><div class="line">    // 3. 根据style和space得到imageEdgeInsets和labelEdgeInsets的值</div><div class="line">    switch (located) &#123;</div><div class="line">        case XHButtonImageLocatedLabelTop:&#123;</div><div class="line">            imageEdgeInsets = UIEdgeInsetsMake(-labelHeight-space/2.0, 0, 0, -labelWidth);</div><div class="line">            labelEdgeInsets = UIEdgeInsetsMake(0, -imageWidth, -imageHeight-space/2.0, 0);</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case XHButtonImageLocatedLabelButtom:&#123;</div><div class="line">            </div><div class="line">            imageEdgeInsets = UIEdgeInsetsMake(0, 0, -labelHeight-space/2.0, -labelWidth);</div><div class="line">            labelEdgeInsets = UIEdgeInsetsMake(-imageHeight-space/2.0, -imageWidth, 0, 0);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case XHButtonImageLocatedLabelLeft:&#123;</div><div class="line">            </div><div class="line">            imageEdgeInsets = UIEdgeInsetsMake(0, -space/2.0, 0, space/2.0);</div><div class="line">            labelEdgeInsets = UIEdgeInsetsMake(0, space/2.0, 0, -space/2.0);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case XHButtonImageLocatedLabelRight:&#123;</div><div class="line">            </div><div class="line">            imageEdgeInsets = UIEdgeInsetsMake(0, labelWidth+space/2.0, 0, -labelWidth-space/2.0);</div><div class="line">            labelEdgeInsets = UIEdgeInsetsMake(0, -imageWidth-space/2.0, 0, imageWidth+space/2.0);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    // 4. 赋值</div><div class="line">    self.titleEdgeInsets = labelEdgeInsets;</div><div class="line">    self.imageEdgeInsets = imageEdgeInsets;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)xh_buttonBanWithTheCountdown:(int)time&#123;</div><div class="line"> </div><div class="line">    //1.禁止按钮多次点击</div><div class="line">    self.enabled = NO;</div><div class="line">    __block int count = time;</div><div class="line">    //2. 设置时间</div><div class="line">    [self setTitle:[NSString stringWithFormat:@&quot;%ds&quot;,count] forState:UIControlStateDisabled];</div><div class="line">    </div><div class="line">    //3. 开始倒计时(此处使用了NSTimer的分类来防止忘记取消定时器造成的其他影响)</div><div class="line">    __block NSTimer* timer =  [NSTimer xh_scheduledTimerWithTimeInterval:1 block:^&#123;</div><div class="line">        if (count &lt;= 0) &#123;</div><div class="line">            //5.销毁定时器</div><div class="line">            [timer invalidate];</div><div class="line">            timer = nil;</div><div class="line">            self.enabled = YES;</div><div class="line">        &#125;else&#123;</div><div class="line">            //4. 设置倒计时</div><div class="line">            count--;</div><div class="line">            [self setTitle:[NSString stringWithFormat:@&quot;%ds&quot;,count] forState:UIControlStateDisabled];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125; repeats:YES];</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//addTarget事件</div><div class="line">-(void)xh_blockWhitControlEvents:(UIControlEvents)ControlEvents block:(void(^)())block&#123;</div><div class="line">    [self addTarget:self action:@selector(xh_buttonClick:) forControlEvents:ControlEvents];</div><div class="line">    </div><div class="line">    self.block = block;</div><div class="line">&#125;</div><div class="line">-(void)xh_buttonClick:(UIButton*)button&#123;</div><div class="line">    </div><div class="line">    if (self.block) &#123;</div><div class="line">        self.block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#pragma set/get</div><div class="line">-(void)setBlock:(ButtonClikcBlock)block&#123;</div><div class="line">    if (block) &#123;</div><div class="line">        objc_setAssociatedObject(self, _cmd, block, OBJC_ASSOCIATION_COPY);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">-(ButtonClikcBlock)block&#123;</div><div class="line">    return objc_getAssociatedObject(self, @selector(setBlock:));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为业务中经常要用到button的事件点击,但是习惯了BlockKit和RAC的高聚合事件点击写法以后,感觉方法要跳来跳去太麻烦了,特意写一个分类来修改这个弊端,这个分类还包括了一下功能:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block判断的简写与静态类单例的应用</title>
    <link href="http://yoursite.com/2016/11/30/block%E5%88%A4%E6%96%AD%E7%9A%84%E7%AE%80%E5%86%99%E4%B8%8E%E9%9D%99%E6%80%81%E7%B1%BB%E5%8D%95%E4%BE%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/11/30/block判断的简写与静态类单例的应用/</id>
    <published>2016-11-30T12:40:01.000Z</published>
    <updated>2016-11-30T13:02:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天研究了一些AFN中的一些代码 ,额外发现了一些有趣的东西,记录下来方便以后复习和思考.</p>
<h4 id="block的简写"><a href="#block的简写" class="headerlink" title="block的简写"></a>block的简写</h4><p>这个东西简直能和swift的self?.block媲美一样简介,但是我们先看看三目运算符是怎么工作的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 3;</div><div class="line">int y = (x&gt;0)? : 3;</div><div class="line">int z = (x&gt;0)? 2:3;</div></pre></td></tr></table></figure>
<p>各位会觉得该代码中y和z中会打印什么值呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y=1,z = 2;</div></pre></td></tr></table></figure></p>
<p>实际上第二条赋值语言只是省略了条件为真的时候的返回参数,这个时候就会返回数值1了,至于为什么是返回1呢?我是这么去查看的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int y = (x&gt;0)? true : false;</div></pre></td></tr></table></figure>
<p>如果这里面为两个值都为空的时候,就会返回这两个东西,而true在逻辑上是等于1的,false中逻辑是等于0的,所以如果后面的条件不写的话,按道理来说是会返回0的,但是由于语法设置不允许我们这么写,所以如果大家有什么好的方法来测试也可以告诉我,相互学习.</p>
<p>那么,在这个基础上,我们就可以来判断闭包的操作了,例如常用的点击按钮后,我们要先用if来判断闭包是否存在,不存在的时候就直接跳过,存在的时候就要执行这个闭包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(self.block)&#123;</div><div class="line">self.block();</div><div class="line">&#125;//这是闭包没有参数的情况,复杂情况也是一个套路就不写了</div></pre></td></tr></table></figure></p>
<p>然后如果根据我们的三目运算符的话,我们可以把闭包写成下面这种形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!self.block?:self.block():</div></pre></td></tr></table></figure></p>
<p>这句语法的意思是如果self.block存在的时候,就执行self.block..<br>在afn中它是这样使用的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">           if (self.completionHandler) &#123;</div><div class="line">               self.completionHandler(task.response, responseObject, error);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">           &#125;);</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>嗯,是不是觉得还是可以和swift的语法相比较…另外,在这段代码中我还看到了url_session_manager_completion_group(),一开始觉得没有什么,但是后面才发现原来这里是用()来调用的啊,是C的函数吗???<br>然后我里面一戳…</p>
<h4 id="静态类单例的写法"><a href="#静态类单例的写法" class="headerlink" title="静态类单例的写法"></a>静态类单例的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static dispatch_queue_t url_session_manager_processing_queue() &#123;</div><div class="line">    static dispatch_queue_t af_url_session_manager_processing_queue;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return af_url_session_manager_processing_queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static dispatch_group_t url_session_manager_completion_group() &#123;</div><div class="line">    static dispatch_group_t af_url_session_manager_completion_group;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        af_url_session_manager_completion_group = dispatch_group_create();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return af_url_session_manager_completion_group;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我米有学过C,但感觉这跟java的语法已经很像了,去查看了一下,原来这样可以形成一种类内部的静态单例,意思就是不会被外部所访问的单例写法,那么我们很自己可以想到如果一个类有有queue和group等东西的时候可以使用该方法来描述,其他对象也可以用该方法来封装静态类单例哦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static NSArray * arr()&#123;</div><div class="line">    static NSArray* arr = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        arr=@[@&quot;abc&quot;,@&quot;cba&quot;];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;%@&quot;,arr()); </div><div class="line">///abc,cba</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天研究了一些AFN中的一些代码 ,额外发现了一些有趣的东西,记录下来方便以后复习和思考.&lt;/p&gt;
&lt;h4 id=&quot;block的简写&quot;&gt;&lt;a href=&quot;#block的简写&quot; class=&quot;headerlink&quot; title=&quot;block的简写&quot;&gt;&lt;/a&gt;block的简写&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的Promise函数使用</title>
    <link href="http://yoursite.com/2016/11/16/js%E4%B8%AD%E7%9A%84Promise%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/11/16/js中的Promise函数使用/</id>
    <published>2016-11-16T11:43:10.000Z</published>
    <updated>2016-11-16T12:17:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="初闻Promise"><a href="#初闻Promise" class="headerlink" title="初闻Promise"></a>初闻Promise</h5><p>先贴上Promise的使用吧,其实我对它的理解并不是特别深厚,厉害理解透彻了再回来重新深刻的理解,本文中代码出于<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000#0" target="_blank" rel="external">廖雪峰老师的博客</a>,仅学习记录之用,并非人原创~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">          console.log(&apos;start new Promise&apos;);</div><div class="line">            var timeOut = Math.random() * 2;</div><div class="line">            console.log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">            setTimeout(function()&#123;</div><div class="line">                  if(timeOut&lt;1)&#123;</div><div class="line">                    console.log(&apos;call resolver()...&apos;);</div><div class="line">                    resolve(&apos;200 ok&apos;);</div><div class="line">                    //reject(&apos;失败原因是注释了代码&apos;);</div><div class="line">                  &#125;else &#123;</div><div class="line">                    console.log(&apos;call reject()...&apos;);</div><div class="line">                    reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">                  &#125;</div><div class="line">            &#125;,timeOut * 1000);</div><div class="line">        </div><div class="line">        &#125;).then(function(result)&#123;</div><div class="line">          console.log(&apos;成功&apos;+result);</div><div class="line">        &#125;).catch(function (reason) &#123;</div><div class="line">          console.log(&apos;Failed: &apos; + reason);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>该段代码打印的结果是:<code>成功200 ok</code></p>
<h5 id="进行链式编程"><a href="#进行链式编程" class="headerlink" title="进行链式编程"></a>进行链式编程</h5><p>最初的时候我感觉很不明白为何只是执行了两个参数的其中一个为何能够调用下面then的函数,后来通过注释…只要我执行了resolve的话,肯定回调then中的代码,如果我执行了reject的话,就会执行catch中的代码,这里还会把参数带过去给then和catch中的函数,那么,如果一直调用then的话,就可以进行链式变成了,返回的对象当然是要<code>Promise</code>对象~我们来看老师下面这段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function multiply(input)&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">        console.log(&apos;calculating &apos; + input + &apos; x &apos; + input + &apos;...&apos;);</div><div class="line">        setTimeout(resolve,500,input* input);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function add(input) &#123;</div><div class="line">  return new Promise(function(resolve,reject) &#123;</div><div class="line">    console.log(&apos;calculating &apos; + input + &apos; + &apos; + input + &apos;...&apos;);</div><div class="line">    setTimeout(resolve, 500, input + input);</div><div class="line"></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;start new Promise...&apos;);</div><div class="line">    resolve(123);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(add)</div><div class="line">.then(multiply)</div><div class="line">.then(add)</div><div class="line">.then(function (result) &#123;</div><div class="line">  console.log(&apos;Got value: &apos; + result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为每一次返回值都是Promise对象,所以还是可以.then来延时调用,等待函数体内自行了resolve的时候真正执行该函数.</p>
<h5 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h5><p>基于Promise的原理,我们也可以对ajax进行一个简单的封装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">// ajax函数将返回Promise对象:</div><div class="line">function ajax(method, url, data) &#123;</div><div class="line">    var request = new XMLHttpRequest();</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        request.onreadystatechange = function () &#123;</div><div class="line">            if (request.readyState === 4) &#123;</div><div class="line">                if (request.status === 200) &#123;</div><div class="line">                //成功时把参数传出去</div><div class="line">                    resolve(request.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                //失败时把失败原因回调</div><div class="line">                    reject(request.status);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        request.open(method, url);</div><div class="line">        request.send(data);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class="line">p.then(function (text) &#123; // 如果AJAX成功，获得响应内容</div><div class="line">    log.innerText = text;</div><div class="line">&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码</div><div class="line">    log.innerText = &apos;ERROR: &apos; + status;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种封装的感觉其实就跟OC中网络请求的闭包回调非常相似,大家可以类比的进行学习</p>
<h5 id="所谓的Promise到底是"><a href="#所谓的Promise到底是" class="headerlink" title="所谓的Promise到底是?"></a>所谓的Promise到底是?</h5><p>Promise就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</p>
<p>Promise 对象有以下两个特点。</p>
<ol>
<li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</li>
</ol>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><strong>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</strong><br>来自:<a href="http://www.cnblogs.com/libin-1/p/5947602.html" target="_blank" rel="external">彻底理解Javascript 中的 Promise</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;初闻Promise&quot;&gt;&lt;a href=&quot;#初闻Promise&quot; class=&quot;headerlink&quot; title=&quot;初闻Promise&quot;&gt;&lt;/a&gt;初闻Promise&lt;/h5&gt;&lt;p&gt;先贴上Promise的使用吧,其实我对它的理解并不是特别深厚,厉害理解透彻了再回来重
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的箭头函数和普通函数的对比</title>
    <link href="http://yoursite.com/2016/11/16/js%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2016/11/16/js中的箭头函数和普通函数的对比/</id>
    <published>2016-11-16T04:47:32.000Z</published>
    <updated>2016-11-16T05:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="箭头对象"><a href="#箭头对象" class="headerlink" title="箭头对象"></a>箭头对象</h5><p>在基于ES6标准下,JavaScript有了一个新的函数叫做箭头函数,那么,这个箭头函数有什么作用呢?现在用以前的写法写几个简答的函数看看吧!(首先要确认您的浏览器支持箭头函数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var abs = &#123;</div><div class="line">        fun1:function(x)&#123;</div><div class="line">          return x * x ;</div><div class="line">        &#125;,</div><div class="line">        fun2:function(x)&#123;</div><div class="line">          if (x &gt; 0) &#123;</div><div class="line">            return x ;</div><div class="line">          &#125; else &#123;</div><div class="line">            return -x;</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        fun3:function(x,y)&#123;</div><div class="line">          return x * y;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      console.log(abs.fun1(10));//100</div><div class="line">      console.log(abs.fun2(-10));//10</div><div class="line">      console.log(abs.fun3(10,10));//100</div></pre></td></tr></table></figure>
<p>那么,如果和箭头函数对比起来是怎么样的差异呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var fun1 = x =&gt; x * x;</div><div class="line">console.log(fun1(20));//400</div><div class="line"></div><div class="line">var fun2 = x =&gt; &#123;</div><div class="line">    if (x &gt; 0) &#123;</div><div class="line">      return x ;</div><div class="line">    &#125; else &#123;</div><div class="line">      return -x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(fun2(10));//10</div><div class="line">console.log(fun2(-20));//20</div><div class="line"></div><div class="line"></div><div class="line">var fun3 = (x,y) =&gt; x * y;</div><div class="line">console.log(fun3(20,30));//600</div></pre></td></tr></table></figure>
<p>由fun1的函数可以发现,我们箭头函数的写法是 <code>x =&gt; x * x</code>这种格式,这个单个参数的函数,fun2也是单个参数的函数,而fun3 <code>(x,y) =&gt; x * y</code>是一个双参数的函数,如此类推,多个函数的闭包可以使用我们之前说过<code>(x,y,...rest) =&gt; {return xxx}</code>,如果需要返回一个对象的话,需要使用一下的方法:<code>x =&gt; ({foo:x})</code></p>
<h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>this关键字的意思在指向了当前对象,它和匿名函数相似,但也有一个明显的区别:箭头函数中的this是词法作用域,由上下文确定.<br>看一个经典的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = function () &#123;</div><div class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此处的this对window进行了错误的绑定,所以运行的时候会报错,但是如果我们改用下面这个例子的话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn =&gt;  new Date().getFullYear() - this.birth; // this指向obj对象</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); // 25</div></pre></td></tr></table></figure>
<p>当然,我们也可以使用hack的这种写法,可能多一句话没有那么优雅吧~<code>var that = this</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;箭头对象&quot;&gt;&lt;a href=&quot;#箭头对象&quot; class=&quot;headerlink&quot; title=&quot;箭头对象&quot;&gt;&lt;/a&gt;箭头对象&lt;/h5&gt;&lt;p&gt;在基于ES6标准下,JavaScript有了一个新的函数叫做箭头函数,那么,这个箭头函数有什么作用呢?现在用以前的写法写几个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js在ES6中可以使用iterable进行遍历</title>
    <link href="http://yoursite.com/2016/11/15/js%E5%9C%A8ES6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8iterable%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2016/11/15/js在ES6中可以使用iterable进行遍历/</id>
    <published>2016-11-15T03:50:14.000Z</published>
    <updated>2016-11-15T11:50:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用iterable的时候首先要确认浏览器时候支持ES6的语法,可以使用以下代码来检查是否适配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;ues strict&apos;</div><div class="line">var a = [1,2,3];</div><div class="line">for (var x of a) &#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">alert(&apos;你的浏览器支持for ... of&apos;);</div></pre></td></tr></table></figure>
<p>在正常情况下,<code>Array</code>可以支持以下两种形式来进行下标遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> for (var i = 0; i &lt; array.length; i++) &#123;</div><div class="line">   array[i]</div><div class="line">   for (var variable in object) &#123;</div><div class="line">     if (object.hasOwnProperty(variable)) &#123;</div><div class="line">       </div><div class="line">   	&#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">for (var variable in object) &#123;</div><div class="line">   if (object.hasOwnProperty(variable)) &#123;</div><div class="line">     </div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>但是对于ES6新增的<code>Set</code>和<code>Map</code>类型就无法使用该方法来进行遍历了,因此在ES6中引入了一个新的解决模式:<code>iterable</code>类型的模式来进行<code>for...of</code>遍历.样式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;];</div><div class="line">    var s = new Set([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]);</div><div class="line">    var m = new Map([[1,&apos;x&apos;],[2,&apos;y&apos;],[3,&apos;z&apos;]]);</div><div class="line"></div><div class="line">    for (var x of a) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;;</div><div class="line">//A -&gt; B  -&gt; C</div><div class="line"></div><div class="line">    for (var x of s) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;</div><div class="line">//A -&gt; B  -&gt; C</div><div class="line">    for (var x of m) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;</div><div class="line">//[1,&apos;x&apos;]-&gt;  [2,&apos;y&apos;] -&gt; [3,&apos;z&apos;]</div></pre></td></tr></table></figure>
<p><code>for...in</code>实际上和最新的<code>for...of</code>是有区别的,<code>for...in</code>它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var a = [1,2,3];</div><div class="line">a.name = &apos;xiaoming&apos;;</div><div class="line">for (var b in a) &#123;</div><div class="line">  console.log(b);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">结果如下:</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">name</div><div class="line"> */</div></pre></td></tr></table></figure>
<p><code>for ... in</code>循环将把name包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.name = &apos;Hello&apos;;</div><div class="line">for (var x of a) &#123;</div><div class="line">    alert(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是为什么要引入新的<code>for ... of</code>循环。</p>
<p>然而，更好的方式是直接使用iterable内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.forEach(function (element, index, array) &#123;</div><div class="line">    // element: 指向当前元素的值</div><div class="line">    // index: 指向当前索引</div><div class="line">    // array: 指向Array对象本身</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，<code>forEach()</code>方法是ES5.1标准引入的，你需要测试浏览器是否支持。</p>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</div><div class="line">s.forEach(function (element, sameElement, set) &#123;</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</div><div class="line">m.forEach(function (value, key, map) &#123;</div><div class="line">    alert(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.forEach(function (element) &#123;</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用iterable的时候首先要确认浏览器时候支持ES6的语法,可以使用以下代码来检查是否适配:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS最全性能优化</title>
    <link href="http://yoursite.com/2016/11/13/iOS%E6%9C%80%E5%85%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/11/13/iOS最全性能优化/</id>
    <published>2016-11-13T14:48:30.000Z</published>
    <updated>2016-11-14T04:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)</p>
<p>原文地址:<a href="http://www.jianshu.com/p/9c450e512020" target="_blank" rel="external">iOS最全性能优化 - HelloYeah</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级："><a href="#我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级：" class="headerlink" title="我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级："></a>我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：</h4><ul>
<li>入门级（这是些你一定会经常用在你app开发中的建议）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. 用ARC管理内存</div><div class="line">2. 在正确的地方使用reuseIdentifier</div><div class="line">3. 尽可能使Views透明</div><div class="line">4. 避免庞大的XIB</div><div class="line">5. 不要block主线程</div><div class="line">6. 在Image Views中调整图片大小</div><div class="line">7. 选择正确的Collection</div><div class="line">8. 打开gzip压缩</div></pre></td></tr></table></figure>
<ul>
<li>中级（这些是你可能在一些相对复杂情况下可能用到的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">9. 重用和延迟加载Views</div><div class="line">10. Cache, Cache, 还是Cache！</div><div class="line">11. 权衡渲染方法</div><div class="line">12. 处理内存警告</div><div class="line">13. 重用大开销的对象</div><div class="line">14. 使用Sprite Sheets</div><div class="line">15. 避免反复处理数据</div><div class="line">16. 选择正确的数据格式</div><div class="line">17. 正确地设定Background Images</div><div class="line">18. 减少使用Web特性</div><div class="line">19. 设定Shadow Path</div><div class="line">20. 优化你的Table View</div><div class="line">21. 选择正确的数据存储选项</div></pre></td></tr></table></figure>
<ul>
<li>进阶级（这些建议只应该在你确信他们可以解决问题和得心应手的情况下采用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">22. 加速启动时间</div><div class="line">23. 使用Autorelease Pool</div><div class="line">24. 选择是否缓存图片</div><div class="line">25. 尽量避免日期格式转换</div></pre></td></tr></table></figure>
<p>初学者性能提升<br>这个部分致力于一些能提高性能的基本改变。但所有层次的开发者都有可能会从这个记录了一些被忽视的项目的小小的性能备忘录里获得一些提升。</p>
<h5 id="1-用ARC管理内存"><a href="#1-用ARC管理内存" class="headerlink" title="1.用ARC管理内存"></a>1.用ARC管理内存</h5><ul>
<li><p>ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。<br>  下面是你会经常用来去创建一个View的代码段:</p>
<pre><code>UIView *view = [[UIView alloc] init];
 // ...
[self.view addSubview:view];
 [view release];
</code></pre></li>
<li><p>忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。这都啥年代了，你应该在你的所有项目里使用ARC!</p>
</li>
</ul>
<h5 id="2-在正确的地方使用-reuseIdentifier"><a href="#2-在正确的地方使用-reuseIdentifier" class="headerlink" title="2.在正确的地方使用 reuseIdentifier"></a>2.在正确的地方使用 reuseIdentifier</h5><ul>
<li><p>一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。</p>
</li>
<li><p>为了性能最优化，table view用 tableView:cellForRowAtIndexPath: 为rows分配cells的时候，它的数据应该重用自UITableViewCell。 一个table view维持一个队列的数据可重用的UITableViewCell对象。不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。</p>
</li>
</ul>
<ul>
<li>自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers</li>
</ul>
<h5 id="3-尽量把views设置为完全不透明"><a href="#3-尽量把views设置为完全不透明" class="headerlink" title="3.尽量把views设置为完全不透明"></a>3.尽量把views设置为完全不透明</h5><ul>
<li><p>如果你有透明的Views你应该设置它们的opaque(不透明)属性为YES。例如一个黑色半透明的可以设置为一个灰色不透明的View替代.原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p>
<ul>
<li>Apple的文档对于为图片设置透明属性的描述是：<br>(opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</li>
</ul>
</li>
</ul>
<ul>
<li><p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p>
</li>
<li><p>换种说法，大家可能更好理解：</p>
<p> 只要一个视图的不透明度小于1,就会导致blending.blending操作在iOS的图形处理器（GPU）中完成的,blending主要指的是混合像素颜色的计算。举个例子,我们把两个图层叠加在一起,如果第一个图层的有透明效果,则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。</p>
<ul>
<li><p>为什么Blending会导致性能的损失？</p>
<p>原因是很直观的,如果一个图层是完全不透明的,则系统直接显示该图层的颜色即可。而如果图层是带透明效果的,则会引入更多的计算,因为需要把下面的图层也包括进来,进行混合后颜色的计算。</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-避免过于庞大的XIB"><a href="#4-避免过于庞大的XIB" class="headerlink" title="4. 避免过于庞大的XIB"></a>4. 避免过于庞大的XIB</h5><ul>
<li><p>iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。</p>
</li>
<li><p>如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>
</li>
<li><p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的imageNamed:方法来获取图片资源。</p>
</li>
</ul>
<h5 id="5-不要阻塞主线程"><a href="#5-不要阻塞主线程" class="headerlink" title="5. 不要阻塞主线程"></a>5. 不要阻塞主线程</h5><ul>
<li><p>永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应</p>
</li>
<li><p>大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。或者使用像 AFNetworking这样的框架来异步地做这些操作。</p>
</li>
<li>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.<br>  你可以使用NSURLConnection异步地做网络操作:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler</div></pre></td></tr></table></figure>
<h5 id="6-在Image-Views中调整图片大小"><a href="#6-在Image-Views中调整图片大小" class="headerlink" title="6. 在Image Views中调整图片大小"></a>6. 在Image Views中调整图片大小</h5><ul>
<li>如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</li>
<li>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</li>
</ul>
<h5 id="7-选择正确的Collection"><a href="#7-选择正确的Collection" class="headerlink" title="7. 选择正确的Collection"></a>7. 选择正确的Collection</h5><ul>
<li><p>学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。</p>
</li>
<li><p>Apple有一个 Collections Programming Topics 的文档详尽介绍了可用的classes间的差别和你该在哪些场景中使用它们。这对于任何使用collections的人来说是一个必读的文档。<br>呵呵，我就知道你因为太长没看…这是一些常见collection的总结：</p>
<p>  Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。<br>  Dictionaries: 存储键值对。 用键来查找比较快。<br>  Sets: 无序的一组值。用值来查找很快，插入/删除很快。</p>
</li>
</ul>
<h5 id="8-打开gzip压缩"><a href="#8-打开gzip压缩" class="headerlink" title="8. 打开gzip压缩"></a>8. 打开gzip压缩</h5><ul>
<li>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</li>
<li>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。<ul>
<li>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。</li>
</ul>
</li>
</ul>
<h5 id="9-重用和延迟加载-lazy-load-Views"><a href="#9-重用和延迟加载-lazy-load-Views" class="headerlink" title="9. 重用和延迟加载(lazy load) Views"></a>9. 重用和延迟加载(lazy load) Views</h5><ul>
<li>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</li>
<li>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</li>
<li><p>这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。<br>创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p>
<ol>
<li>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</li>
<li>当需要时才创建并展示。</li>
</ol>
</li>
<li><p>每个方案都有其优缺点。</p>
<ul>
<li>用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</li>
<li>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</li>
</ul>
</li>
</ul>
<h5 id="10-Cache-Cache-还是Cache"><a href="#10-Cache-Cache-还是Cache" class="headerlink" title="10. Cache, Cache, 还是Cache!"></a>10. Cache, Cache, 还是Cache!</h5><ul>
<li><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。<br>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p>
</li>
<li><p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。<br>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url &#123;</div><div class="line"> NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div><div class="line"></div><div class="line"> request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image</div><div class="line"> request.HTTPShouldHandleCookies = NO;</div><div class="line"> request.HTTPShouldUsePipelining = YES;</div><div class="line"> [request addValue:@&quot;image/*&quot;forHTTPHeaderField:@&quot;Accept&quot;];</div><div class="line"></div><div class="line"> returnrequest;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p>
</li>
<li><p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。<br><code>NSCache</code>和<code>NSDictionary</code>类似，不同的是系统回收内存的时候它会自动删掉它的内容。</p>
</li>
</ul>
<h5 id="11-权衡渲染方法"><a href="#11-权衡渲染方法" class="headerlink" title="11. 权衡渲染方法"></a>11. 权衡渲染方法</h5><ul>
<li><p>在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，或者可以用CALayer， CoreGraphics甚至OpenGL来画它们。<br>当然每个不同的解决方法都有不同的复杂程度和相应的性能。有一篇Apple UIKit team中的一员Andy Matuschak推荐过的很棒的关于graphic性能的帖子很值得一读。</p>
</li>
<li><p>简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积 – 这就是使用可变大小的图片更好的地方了: 你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。</p>
</li>
<li>然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。</li>
<li>总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。</li>
</ul>
<h5 id="12-处理内存警告"><a href="#12-处理内存警告" class="headerlink" title="12. 处理内存警告"></a>12. 处理内存警告</h5><ul>
<li>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:<br>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.<br>幸运的是，UIKit提供了几种收集低内存警告的方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 在app delegate中使用applicationDidReceiveMemoryWarning: 的方法</div><div class="line">* 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning</div><div class="line">* 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</div></pre></td></tr></table></figure>
<ul>
<li><p>一旦收到这类通知，你就需要释放任何不必要的内存使用。<br>例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>
</li>
<li><p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。<br>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>
</li>
</ul>
<h5 id="13-重用大开销对象"><a href="#13-重用大开销对象" class="headerlink" title="13. 重用大开销对象"></a>13. 重用大开销对象</h5><ul>
<li><p>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。<br>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p>
</li>
<li><p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。<br>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// in your .h or inside a class extension</div><div class="line">@property (nonatomic, strong) NSDateFormatter *formatter;</div><div class="line"></div><div class="line">// inside the implementation (.m)</div><div class="line">// When you need, just use self.formatter</div><div class="line">- (NSDateFormatter *)formatter &#123;</div><div class="line">    if(! _formatter) &#123;</div><div class="line">        _formatter = [[NSDateFormatter alloc] init];</div><div class="line">        _formatter.dateFormat = @&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;;// twitter date format</div><div class="line">    &#125;</div><div class="line">    return_formatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</li>
</ul>
<h5 id="14-使用Sprite-Sheets"><a href="#14-使用Sprite-Sheets" class="headerlink" title="14. 使用Sprite Sheets"></a>14. 使用Sprite Sheets</h5><ul>
<li>你是一个游戏开发者吗，那么Sprite sheets一定是一个你的最好的朋友了。Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。<br>我们有两个很好的关于Sprite的教程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How To Use Animations and Sprite Sheets in Cocos2D</div><div class="line">How to Create and Optimize Sprite Sheets in Cocos2D with Texture Packer and Pixel Formats</div></pre></td></tr></table></figure>
<ul>
<li>第二个教程涵盖了可能在很大程度上影响你游戏性能的pixel格式的细节。<br>如果你对于spirte sheet还不是很熟悉，可以看下这两个(youtube)视频SpriteSheets – The Movie, Part 1 和Part 2。视频的作者是创建Sprite sheet很流行的工具之一Texture Packer的作者Andreas Löw。<br>除了使用Sprite sheets，其它写在这里的建议当然也可以用于游戏开发中。比如你需要很多的Sprite sheets，像敌人，导弹之类的动作类必备元素，你可以重用这些sprites而不用每次都要重新创建。</li>
</ul>
<h5 id="15-避免反复处理数据"><a href="#15-避免反复处理数据" class="headerlink" title="15. 避免反复处理数据"></a>15. 避免反复处理数据</h5><ul>
<li>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。<br>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</li>
<li>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</li>
</ul>
<h5 id="16-选择正确的数据格式"><a href="#16-选择正确的数据格式" class="headerlink" title="16. 选择正确的数据格式"></a>16. 选择正确的数据格式</h5><p>从app和网络服务间传输数据有很多方案，最常见的就是JSON和XML。你需要选择对你的app来说最合适的一个。</p>
<ul>
<li>解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。</li>
<li>但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</li>
</ul>
<h5 id="17-正确设定背景图片"><a href="#17-正确设定背景图片" class="headerlink" title="17. 正确设定背景图片"></a>17. 正确设定背景图片</h5><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p>
<pre><code>使用UIColor的 colorWithPatternImage来设置背景色；
在view中添加一个UIImageView作为一个子View。
</code></pre><p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>
<pre><code>// You could also achieve the same result in Interface Builder
UIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;background&quot;]];
[self.view addSubview:backgroundView];
</code></pre><p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>
<pre><code>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;background&quot;]];
</code></pre><h5 id="18-减少使用Web特性"><a href="#18-减少使用Web特性" class="headerlink" title="18. 减少使用Web特性"></a>18. 减少使用Web特性</h5><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。<br>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。</p>
<p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。</p>
<p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。<br>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>
<p>更多相关信息可以看下 WWDC 2012 session #601 – Optimizing Web Content in UIWebViews and Websites on iOS</p>
<h5 id="19-设定Shadow-Path"><a href="#19-设定Shadow-Path" class="headerlink" title="19. 设定Shadow Path"></a>19. 设定Shadow Path</h5><p>如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">// Somewhere later ...</div><div class="line">UIView *view = [[UIView alloc] init];</div><div class="line"></div><div class="line">// Setup the shadow ...</div><div class="line">view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);</div><div class="line">view.layer.shadowRadius = 5.0f;</div><div class="line">view.layer.shadowOpacity = 0.6;</div></pre></td></tr></table></figure>
<p>看起来很简单，对吧。<br>可是，坏消息是使用这个方法也有它的问题… Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。<br>使用shadowPath的话就避免了这个问题：</p>
<pre><code>view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];
</code></pre><p>使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.<br>想了解更多可以看看Mark Pospesel的这篇。</p>
<h5 id="20-优化Table-View"><a href="#20-优化Table-View" class="headerlink" title="20. 优化Table View"></a>20. 优化Table View</h5><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。<br>为了保证table view平滑滚动，确保你采取了以下的措施:</p>
<pre><code>正确使用reuseIdentifier来重用cells
尽量使所有的view opaque，包括cell自身
避免渐变，图片缩放，后台选人
缓存行高
如果cell内现实的内容来自web，使用异步加载，缓存请求结果
使用shadowPath来画阴影
减少subviews的数量
尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果
使用正确的数据结构来存储数据
尽量使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate
</code></pre><h5 id="21-选择正确的数据存储选项"><a href="#21-选择正确的数据存储选项" class="headerlink" title="21. 选择正确的数据存储选项"></a>21. 选择正确的数据存储选项</h5><p>当做本地数据存储时你会怎么做？<br>你有很多选择，比如：</p>
<pre><code>使用NSUerDefaults
使用XML, JSON, 或者 plist
使用NSCoding存档
使用类似SQLite的本地SQL数据库
使用 Core Data
</code></pre><ul>
<li><p>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>
</li>
<li><p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>
</li>
<li><p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>
</li>
<li><p>当存储大块数据时,以上的方法都不适用. 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。<br>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>
</li>
</ul>
<h5 id="22-加速启动时间"><a href="#22-加速启动时间" class="headerlink" title="22. 加速启动时间"></a>22. 加速启动时间</h5><p>快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。</p>
<ul>
<li>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</li>
<li>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！<ul>
<li>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</li>
</ul>
</li>
</ul>
<h5 id="23-使用Autorelease-Pool"><a href="#23-使用Autorelease-Pool" class="headerlink" title="23. 使用Autorelease Pool"></a>23. 使用Autorelease Pool</h5><ul>
<li>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</li>
<li>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。<br>好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</div><div class="line">    for(NSURL *url in urls) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">      NSError *error;</div><div class="line">      NSString *fileContents = [NSString stringWithContentsOfURL:url</div><div class="line">                                             encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">            /* Process the string, creating and autoreleasing more objects. */</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码在每次遍历后释放所有autorelease对象</p>
<h5 id="24-选择是否缓存图片"><a href="#24-选择是否缓存图片" class="headerlink" title="24. 选择是否缓存图片"></a>24. 选择是否缓存图片</h5><p>常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。</p>
<p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p>
<p>imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:<br>这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。<br>相反的，imageWithContentsOfFile仅加载图片。<br>下面的代码说明了这两种方法的用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;];// caching</div><div class="line">// or</div><div class="line">UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;];// no caching</div></pre></td></tr></table></figure>
<p>那么我们应该如何选择呢？<br>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。<br>然而，在图片反复重用的情况下imageNamed是一个好得多的选择。</p>
<h5 id="25-避免日期格式转换"><a href="#25-避免日期格式转换" class="headerlink" title="25. 避免日期格式转换"></a>25. 避免日期格式转换</h5><p>如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。<br>然而，如果你需要更多速度，那么直接用C是一个好的方案。Sam Soffes有一个不错的帖子<a href="http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="external">(点进进入)</a>里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。<br>嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！<br>如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   - (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp &#123;</div><div class="line">return[NSDate dateWithTimeIntervalSince1970:timestamp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样会比用C来解析日期字符串还快！<br>需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;http://www.jianshu.com/p/9c450e512020&quot; target=&quot;_bla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>runtime之获得一个类的成员变量</title>
    <link href="http://yoursite.com/2016/11/12/runtime%E4%B9%8B%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2016/11/12/runtime之获得一个类的成员变量/</id>
    <published>2016-11-12T10:49:29.000Z</published>
    <updated>2016-11-12T11:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何获得一个类的成员变量"><a href="#如何获得一个类的成员变量" class="headerlink" title="如何获得一个类的成员变量?"></a>如何获得一个类的成员变量?</h4><p>对于runtime这个Objective-C的黑魔法,其实我在理论中并没有理解得很到位,但是在开发中慢慢变更的需求,我们开始就会按照网上的模板来写代码,写得多了,其实就会有”到位”的感觉.</p>
<p>使用runtime获得成员变量最常用的地方就是在一个对象归档和解档的时候使用了,因为如果每次都要手动写比较累,而且也容易写错,那不如我们直接用这项黑魔法来减轻我们的工作量–</p>
<p>&gt;<br>//必须要导入的头文件</p>
<objc runtime.h="">

<ol>
<li>获得某个类的所有成员变量（outCount 会返回成员变量的总数）<br><code>Ivar *class_copyIvarList(Class cls , unsigned int *outCount)</code><br>第一个参数是:类的类型<br>第二个参数是:unsigned int *outCount放一个接收值的地址，用来存放属性的个数</li>
<li>获得成员变量的名字<br><code>const char *ivar_getName(Ivar v)</code></li>
<li>获得成员变量的类型<br><code>const char *ivar_getTypeEndcoding(Ivar v)</code></li>
</ol>
<h4 id="举一个普通的例子"><a href="#举一个普通的例子" class="headerlink" title="举一个普通的例子"></a>举一个普通的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unsigned int outCount = 0;</div><div class="line">Ivar *ivars = class_copyIvarList([Person class], &amp;outCount);</div><div class="line"></div><div class="line">// 遍历所有成员变量</div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">    // 取出i位置对应的成员变量</div><div class="line">    Ivar ivar = ivars[i];</div><div class="line">    const char *name = ivar_getName(ivar);</div><div class="line">    const char *type = ivar_getTypeEncoding(ivar);</div><div class="line">    NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);</div><div class="line">&#125;</div><div class="line">// 注意释放内存！</div><div class="line">free(ivars);</div></pre></td></tr></table></figure>
<h4 id="利用runtime-获取所有属性来重写归档解档方法"><a href="#利用runtime-获取所有属性来重写归档解档方法" class="headerlink" title="利用runtime 获取所有属性来重写归档解档方法"></a>利用runtime 获取所有属性来重写归档解档方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 设置不需要归解档的属性</div><div class="line">- (NSArray *)ignoredNames &#123;</div><div class="line">    return @[@&quot;_aaa&quot;,@&quot;_bbb&quot;,@&quot;_ccc&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解档方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line">        // 获取所有成员变量</div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            // 将每个成员变量名转换为NSString对象类型</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 忽略不需要解档的属性</div><div class="line">            if ([[self ignoredNames] containsObject:key]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 根据变量名解档取值，无论是什么类型</div><div class="line">            id value = [aDecoder decodeObjectForKey:key];</div><div class="line">            // 取出的值再设置给属性</div><div class="line">            [self setValue:value forKey:key];</div><div class="line">            // 这两步就相当于以前的 self.age = [aDecoder decodeObjectForKey:@&quot;_age&quot;];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 归档调用方法</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">     // 获取所有成员变量</div><div class="line">    unsigned int outCount = 0;</div><div class="line">    Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">    for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        // 将每个成员变量名转换为NSString对象类型</div><div class="line">        NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">        // 忽略不需要归档的属性</div><div class="line">        if ([[self ignoredNames] containsObject:key]) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 通过成员变量名，取出成员变量的值</div><div class="line">        id value = [self valueForKeyPath:key];</div><div class="line">        // 再将值归档</div><div class="line">        [aCoder encodeObject:value forKey:key];</div><div class="line">        // 这两步就相当于 [aCoder encodeObject:@(self.age) forKey:@&quot;_age&quot;];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>依据上面的原理我们就可以给NSObject做一个分类，让我们不需要每次都写这么一长串代码，只要实现一小段代码就可以让一个对象具有归解档的能力。</p>
<p><strong>注意，下面的代码我换了一个方法名（不然会覆盖系统原来的方法！），加了一个忽略属性方法是否被实现的判断，并加上了对父类属性的归解档循环。</strong></p>
<p><code>NSObject+Extension.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSObject (Extension)</div><div class="line"></div><div class="line">- (NSArray *)ignoredNames;</div><div class="line">- (void)encode:(NSCoder *)aCoder;</div><div class="line">- (void)decode:(NSCoder *)aDecoder;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>NSObject+Extension.m</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSObject+Extension.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (Extension)</div><div class="line"></div><div class="line">- (void)decode:(NSCoder *)aDecoder &#123;</div><div class="line">    // 一层层父类往上查找，对父类的属性执行归解档方法</div><div class="line">    Class c = self.class;</div><div class="line">    while (c &amp;&amp;c != [NSObject class]) &#123;</div><div class="line"></div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList(c, &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 如果有实现该方法再去调用</div><div class="line">            if ([self respondsToSelector:@selector(ignoredNames)]) &#123;</div><div class="line">                if ([[self ignoredNames] containsObject:key]) continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            id value = [aDecoder decodeObjectForKey:key];</div><div class="line">            [self setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">        c = [c superclass];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encode:(NSCoder *)aCoder &#123;</div><div class="line">    // 一层层父类往上查找，对父类的属性执行归解档方法</div><div class="line">    Class c = self.class;</div><div class="line">    while (c &amp;&amp;c != [NSObject class]) &#123;</div><div class="line"></div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 如果有实现该方法再去调用</div><div class="line">            if ([self respondsToSelector:@selector(ignoredNames)]) &#123;</div><div class="line">                if ([[self ignoredNames] containsObject:key]) continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            id value = [self valueForKeyPath:key];</div><div class="line">            [aCoder encodeObject:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">        c = [c superclass];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面分类使用方法：在需要归解档的对象中实现下面方法即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 设置需要忽略的属性</div><div class="line">- (NSArray *)ignoredNames &#123;</div><div class="line">    return @[@&quot;bone&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在系统方法内来调用我们的方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        [self decode:aDecoder];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">    [self encode:aCoder];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看来，我们每次又要写同样的代码，我们可以将归解档两个方法封装为宏，在需要的地方一句宏搞定，如果有不需要归解档的属性就实现ignoredNames 方法，具体可以看我的demo，这个也是MJExtension中那个一句宏就可以解决归解档的实现原理。</p>
</objc>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;如何获得一个类的成员变量&quot;&gt;&lt;a href=&quot;#如何获得一个类的成员变量&quot; class=&quot;headerlink&quot; title=&quot;如何获得一个类的成员变量?&quot;&gt;&lt;/a&gt;如何获得一个类的成员变量?&lt;/h4&gt;&lt;p&gt;对于runtime这个Objective-C的黑魔法,其
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>52个建议中的&#39;class-continuation分类&#39;</title>
    <link href="http://yoursite.com/2016/11/09/52%E4%B8%AA%E5%BB%BA%E8%AE%AE%E4%B8%AD%E7%9A%84-class-continuation%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/11/09/52个建议中的-class-continuation分类/</id>
    <published>2016-11-09T13:24:01.000Z</published>
    <updated>2016-11-09T14:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧"><a href="#一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧" class="headerlink" title="一开始看书的时候是有点懵逼的,但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白,个人认为核心的要点就是在实现文件类再一次做分类,类似于一个内部类一样吧.先上一下代码吧."></a>一开始看书的时候是有点懵逼的,但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白,个人认为核心的要点就是在实现文件类再一次做分类,类似于一个内部类一样吧.先上一下代码吧.</h4><h3 id="Pseron-h"><a href="#Pseron-h" class="headerlink" title="Pseron.h"></a>Pseron.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic ,copy,readonly ) NSString* name;</div><div class="line">@property (nonatomic , assign,readonly ) NSUInteger age;</div><div class="line">-(instancetype)initWithName:(NSString*)name WithAge:(NSUInteger)age;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后在接口.h文件,属性使用了readonly关键字,使得外部只能获取,不能修改这个属性,因为每个人的年龄和姓名不是说修改就修改的,考虑到这个逻辑的话,最好就是在接口文件里面修改成只读类型.</p>
<h3 id="Person-m"><a href="#Person-m" class="headerlink" title="Person.m"></a>Person.m</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@interface Person()</div><div class="line">@property (nonatomic ,copy ,readwrite) NSString* name;</div><div class="line">@property (nonatomic ,assign,readwrite ) NSUInteger age;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">-(instancetype)initWithName:(NSString *)name WithAge:(NSUInteger)age&#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _name = name;</div><div class="line">        _age = age;</div><div class="line">    &#125;</div><div class="line">    return  self;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Person (Student)</div><div class="line">//在分类中添加的属性,必须由我们自己来配置get和set属性~</div><div class="line">@property (nonatomic ,copy ) NSString * firstName;</div><div class="line">@end</div><div class="line">@implementation Person(Student)</div><div class="line">static char * PersonFirstName = &quot;PersonFirstName&quot;;</div><div class="line"></div><div class="line">-(void)setFirstName:(NSString *)firstName&#123;</div><div class="line">//此处使用runtime来添加这个属性,因为在分类里面是无法直接添加属性的,只有通过运行时才能添加熟悉,该方法是设置属性的方法,其中`static char * PersonFirstName = &quot;PersonFirstName&quot;;`这个是一个定义常量,必须是C语言字符串</div><div class="line">    objc_setAssociatedObject(self, PersonFirstName, firstName, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSString *)firstName&#123;</div><div class="line">    //该方法是货到属性的方法</div><div class="line">    return objc_getAssociatedObject(self, PersonFirstName);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="Runtime的使用就不再这里多说明了-主要表达的是"><a href="#Runtime的使用就不再这里多说明了-主要表达的是" class="headerlink" title="Runtime的使用就不再这里多说明了,主要表达的是:"></a>Runtime的使用就不再这里多说明了,主要表达的是:</h4><ol>
<li>我们可以在实现文件里面再写多一个类的分类,加深了这种类文件和方法加密的方式,更好的隐蔽了我们的类</li>
<li>同时,个人还觉得如果有一些类只使用一次,我们也可以直接封装在某个.m文件下面做一个匿名的类使用.</li>
<li>或者如同52个建议里面所说的,可以在分类中添加实例变量,如果想类所遵循的协议隐藏,也可以使用class-continuation分类</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧&quot;&gt;&lt;a href=&quot;#一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tableView代理的分离</title>
    <link href="http://yoursite.com/2016/11/07/tableView%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2016/11/07/tableView代理的分离/</id>
    <published>2016-11-07T02:30:43.000Z</published>
    <updated>2016-11-07T08:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-通用性较强-这个类中只添加了cell选中状态的闭包操作-其他可以按需求添加"><a href="#有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-通用性较强-这个类中只添加了cell选中状态的闭包操作-其他可以按需求添加" class="headerlink" title="有没有小伙伴觉得整天重复写tableView的代理很繁琐,在看了iOS中协议的一些内容以后,简单的对tableView的代理作了简单的抽离,方便使用者减少重复代码,其中定义了cellStyleBlock,该闭包的返回值是cell,所以可以在外部操作cell的样式,通用性较强,这个类中只添加了cell选中状态的闭包操作,其他可以按需求添加."></a>有没有小伙伴觉得整天重复写tableView的代理很繁琐,在看了iOS中协议的一些内容以后,简单的对tableView的代理作了简单的抽离,方便使用者减少重复代码,其中定义了cellStyleBlock,该闭包的返回值是cell,所以可以在外部操作cell的样式,通用性较强,这个类中只添加了cell选中状态的闭包操作,其他可以按需求添加.</h5><h3 id="TableViewDelegateObj-h"><a href="#TableViewDelegateObj-h" class="headerlink" title="TableViewDelegateObj.h"></a>TableViewDelegateObj.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@class TableViewDelegateObj;</div><div class="line"></div><div class="line"></div><div class="line">//cell中各个方法通过闭包回调处理</div><div class="line">typedef void(^cellFunctionBlock) (UITableView* tableView,NSIndexPath *indexPath);</div><div class="line">//闭包返回cell的样式</div><div class="line">typedef UITableViewCell* (^cellStyleBlock)(UITableView* tableView,NSIndexPath *indexPath);</div><div class="line"></div><div class="line">@interface TableViewDelegateObj : NSObject&lt;UITableViewDelegate,UITableViewDataSource&gt;</div><div class="line"></div><div class="line"></div><div class="line">//创建cell的样式</div><div class="line">+(instancetype)creatTableViewDelagateWithDataList:(NSArray *)dataList</div><div class="line">                                        cellStyle:(cellStyleBlock) cellStyle;</div><div class="line">/**</div><div class="line"> *  选中cell时回调闭包</div><div class="line"> */</div><div class="line">-(instancetype)selectBlock:(cellFunctionBlock)Block;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="TableViewDelegateObj-m"><a href="#TableViewDelegateObj-m" class="headerlink" title="TableViewDelegateObj.m"></a>TableViewDelegateObj.m</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#import &quot;TableViewDelegateObj.h&quot;</div><div class="line">@interface TableViewDelegateObj()</div><div class="line">@property (nonatomic , strong ) NSArray *dataList;</div><div class="line">@property (nonatomic ,copy ) cellFunctionBlock selectBlock;</div><div class="line">@property (nonatomic ,copy ) cellStyleBlock cellBlock;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation TableViewDelegateObj</div><div class="line"></div><div class="line">+(instancetype)creatTableViewDelagateWithDataList:(NSArray *)dataList cellStyle:(cellStyleBlock)cellStyleBlock&#123;</div><div class="line">    </div><div class="line">    return  [[[self class] alloc] initTabelViewDelegateWithDataList:dataList cellStyle:cellStyleBlock ];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">-(instancetype)initTabelViewDelegateWithDataList:(NSArray*)dataList cellStyle:(cellStyleBlock)cellStyleBlock&#123;</div><div class="line">    </div><div class="line">    self =  [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        self.dataList = dataList;</div><div class="line">        </div><div class="line">        self.cellBlock = cellStyleBlock;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    </div><div class="line">    return self.dataList.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;    </div><div class="line">    </div><div class="line">    return self.cellBlock(tableView,indexPath);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//选中</div><div class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:NO];</div><div class="line">    self.selectBlock(tableView,indexPath);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-(instancetype)selectBlock:(cellFunctionBlock)Block&#123;</div><div class="line">    </div><div class="line">    self.selectBlock = Block;</div><div class="line">    return self;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;TableViewDelegateObj.h&quot;</div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic , strong ) UITableView *tableView;</div><div class="line">@property (nonatomic , strong ) TableViewDelegateObj*tabelViewDealage;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;NSString*&gt; *dataList;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.dataList =  [NSMutableArray array];</div><div class="line">    for (NSInteger i = 0; i &lt;= 10; i++) &#123;</div><div class="line">        NSString* str =  [NSString stringWithFormat:@&quot;我的第%ld行cell&quot;,i];</div><div class="line">        [self.dataList addObject:str];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tableView =  [[UITableView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) style:UITableViewStylePlain];</div><div class="line">    [self.view addSubview:self.tableView];</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tabelViewDealage =  [[TableViewDelegateObj creatTableViewDelagateWithDataList:self.dataList cellStyle:^UITableViewCell *(UITableView *tableView, NSIndexPath *indexPath) &#123;</div><div class="line">        //返回cell的样式</div><div class="line">        static NSString* identifier = @&quot;cell&quot;;</div><div class="line">        </div><div class="line">        UITableViewCell* cell =  [tableView dequeueReusableCellWithIdentifier:identifier];</div><div class="line">        if (!cell) &#123;</div><div class="line">            cell =  [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];</div><div class="line">            cell.textLabel.text = self.dataList[indexPath.row];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return cell;</div><div class="line"></div><div class="line">    &#125;] selectBlock:^(UITableView *tableView, NSIndexPath *indexPath) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tableView.delegate = self.tabelViewDealage;</div><div class="line">    self.tableView.dataSource = self.tabelViewDealage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何在项目已初始化成功以后建立git仓库</title>
    <link href="http://yoursite.com/2016/10/31/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%8A%9F%E4%BB%A5%E5%90%8E%E5%BB%BA%E7%AB%8Bgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2016/10/31/如何在项目已初始化成功以后建立git仓库/</id>
    <published>2016-10-31T11:01:37.000Z</published>
    <updated>2016-10-31T11:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:<code>git@github.com:vshiron/html-css-js-dome.git</code></li>
<li>然后你就需要在本地创建一个文件,把你需要的东西先考进去吧,然后打开终端,cd进入你的目录:<code>cd /Users/vshiron/Desktop/html学习/jsdome</code></li>
<li>在该目录下使用git的初始化命令:<code>git init</code></li>
<li>以后的每一次增加目录里面的内容,都必须要用该命令来添加到本地仓库,用”.”是代表通配符,命令如下:<code>git add .</code>,成功后不会显示任何东西</li>
<li>然后就是提交代码的信息,修改了什么就顺便写上去,第一次初始化就可以写first啦:<code>git commit -m &quot;first commit&quot;</code><br>大概会显示下面内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[master (root-commit) 6ddc496] first commit</div><div class="line">2 files changed, 229 insertions(+)</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/.project&quot;</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/index.html&quot;</div></pre></td></tr></table></figure>
<ol>
<li><p>完事了以后,就要添加一个远程本地的仓库:<code>git remote add origin git@github.com:vshiron/html-css-js-dome.git</code>,完事后没有任何代码显示</p>
</li>
<li><p>接下来再输入另外一个代码,就是我们希望把代码推送到服务器上的命令:<code>git push origin master</code><br>这个时候会显示如下信息,他大概的意思是告诉你,推送代码时要养成拉代码合并的习惯~</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line"> ! [rejected]        master -&gt; master (fetch first)</div><div class="line">error: failed to push some refs to &apos;git@github.com:vshiron/html-css-js-dome.git&apos;</div><div class="line">hint: Updates were rejected because the remote contains work that you do</div><div class="line">hint: not have locally. This is usually caused by another repository pushing</div><div class="line">hint: to the same ref. You may want to first integrate the remote changes</div><div class="line">hint: (e.g., &apos;**git pull ...&apos;**) before pushing again.</div><div class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</div></pre></td></tr></table></figure>
<ol>
<li>那么,我们就先拉一下代码吧,运行命令:<code>git pull origin master</code>,拉完代码以后会显示下面信息:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">From github.com:vshiron/html-css-js-dome</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Merge made by the &apos;recursive&apos; strategy.</div><div class="line"> README.md | 2 ++</div><div class="line"> 1 file changed, 2 insertions(+)</div><div class="line"> create mode 100644 README.md</div></pre></td></tr></table></figure>
<ol>
<li>操作完成上面那一步的话,我们可以继续使用该命令:<code>git push origin master</code>,这个时候可能会让你输入相应的账号和密码,输入就是了~<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pushing to git@github.com:vshiron/html-css-js-dome.git</div><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line">   73c75b2..1907e5f  master -&gt; master</div><div class="line">updating local tracking ref &apos;refs/remotes/origin/master&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时候就已经完成项目的推送了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:&lt;code&gt;git@github.com:vshiron/html-css-js-dome.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后你就需要在本地创
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Controller间的自定义过渡效果</title>
    <link href="http://yoursite.com/2016/10/17/Controller%E9%97%B4%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2016/10/17/Controller间的自定义过渡效果/</id>
    <published>2016-10-17T10:58:48.000Z</published>
    <updated>2016-10-27T13:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">阅读原文</a>)</strong></p>
<blockquote>
<p>本篇文章主要讲的就是在学习了UIView的基础上,如何在学习UIViewController的自定义效果</p>
</blockquote>
<p>效果图如下:</p>
<ul>
<li>点击模态controller，会弹出一个新的绿色UIViewController，手指下滑可以dismiss这个controller</li>
<li>四个角的按钮可以自定义圆形切换的过渡效果切换的一个红色的UIViewController，点击返回用同样的方式切换回来</li>
</ul>
<p><a href="http://liuyanwei.jumppo.com/assets/uploads/ControllerTransitioning1.gif" target="_blank" rel="external"></a></p>
<h4 id="出场人物介绍"><a href="#出场人物介绍" class="headerlink" title="出场人物介绍"></a>出场人物介绍</h4><blockquote>
<p>介绍一下Controller过渡和交互用到的类</p>
</blockquote>
<h5 id="presention-and-presented"><a href="#presention-and-presented" class="headerlink" title="presention and presented"></a><code>presention and presented</code></h5><pre><code>A中模态显示B,那么A就是presention，b就是presented，后续内容会使用这种叫法称呼Modal下的2个controller
</code></pre><h5 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><code>UIViewControllerTransitioningDelegate</code></h5><pre><code>Controller modal过渡的presented和dismiss的动画交互协议，你需要实现协议，它会询问你：
</code></pre><ul>
<li>当PresentedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当DismissedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当PresentedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>当DismissedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
</ul>
<h5 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><code>UIViewControllerAnimatedTransitioning</code></h5><p>过渡动画效果的具体实现的接口，需要实现它的3个方法，即可完成一个controller过渡动画效果</p>
<ul>
<li><code>func animationEnded</code>：过渡动画完成后要执行的代码可以写到这个方法中</li>
<li><code>func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval</code>：给定一个过渡动画的执行时间</li>
<li><code>func animateTransition(transitionContext: UIViewControllerContextTransitioning)</code> ：具体过渡动画都在这个方法里面实现，在这个方法中可以通过transitionContext拿到一切你需要的对象，后面会有讲到</li>
</ul>
<h5 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><code>UINavigationControllerDelegate</code></h5><pre><code>Controller 非模态状态下的的过渡动画，就不能使用之前说的那个UIViewControllerTransitioningDelegate委托解决了，就需要用UINavigationControllerDelegate，接口方法比较类似，但也不完全一样
</code></pre><ul>
<li>你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>willShowViewController，didShowViewController ： 生命周期事件</li>
<li>navigationControllerSupportedInterfaceOrientations: 屏幕支持的方向</li>
</ul>
<h5 id="UIViewControllerInteractiveTransitioning"><a href="#UIViewControllerInteractiveTransitioning" class="headerlink" title="UIViewControllerInteractiveTransitioning"></a><code>UIViewControllerInteractiveTransitioning</code></h5><pre><code>这个类用于实现在转场过路效果中的交互，比如在demo中，用它实现了一个手指下滑解除modal状态的效果
</code></pre><h5 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><code>UIViewControllerContextTransitioning</code></h5><p>UIViewControllerAnimatedTransitioning协议的关键方法<code>animateTransition(transitionContext: UIViewControllerContextTransitioning)</code>里面可以得到，使用transitionContext可以获取一些重要的上下文信息，比如前后的controller，转换时的容器等，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //拿到过渡动画执行时间</div><div class="line">        transitionDuration(transitionContext)</div></pre></td></tr></table></figure>
<h4 id="Controller-modal过渡效果"><a href="#Controller-modal过渡效果" class="headerlink" title="Controller modal过渡效果"></a>Controller modal过渡效果</h4><p>我们先来实现一个简单的示例，点击一个按钮，出现一个modal controller，自定义从下往上弹出并且有些回弹效果的过渡动画。从这个例子中我们可以了解</p>
<ul>
<li>如何实现UIViewControllerTransitioningDelegate</li>
<li>如何实现UIViewControllerAnimatedTransitioning</li>
<li>如何组合在一起完成功能</li>
</ul>
<p>示例效果见demo点击后，弹出的绿色界</p>
<h5 id="步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己"><a href="#步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己" class="headerlink" title="步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己"></a><code>步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//模态视图切换效果</div><div class="line">   @IBAction func Transitioning2(sender: AnyObject) &#123;</div><div class="line">       let toVC = To2ViewController()</div><div class="line">       //设置transitioning委托为自己</div><div class="line">       toVC.transitioningDelegate = self</div><div class="line">       navigationController?.presentViewController(toVC, animated: true, completion: nil)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="步骤2：controller-实现-UIViewControllerTransitioningDelegate"><a href="#步骤2：controller-实现-UIViewControllerTransitioningDelegate" class="headerlink" title="步骤2：controller 实现 UIViewControllerTransitioningDelegate"></a>步骤2：<code>controller 实现 UIViewControllerTransitioningDelegate</code></h5><p>demo中使用了extension的方式继承UIViewControllerTransitioningDelegate，好处是代码逻辑分离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//模态视图切换效果</div><div class="line">extension ControllerTransitioningDemoViewController:UIViewControllerTransitioningDelegate&#123;</div><div class="line"></div><div class="line">    //返回Presented使用的UIViewControllerAnimatedTransitioning类</div><div class="line">    </div><div class="line">    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line">        return PresentedAnimation() // PresentedAnimation 是自定义的过渡动画效果的实现类，继承自UIViewControllerAnimatedTransitioning 步骤3中介绍它</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"><a href="#步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类" class="headerlink" title="步骤3: 实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"></a>步骤3: <code>实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类</code></h5><p>就如之前对UIViewControllerAnimatedTransitioning介绍的那样，需要继承自UIViewControllerAnimatedTransitioning，然后实现它的三个委托方法，具体实现请看代码注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">public class PresentedAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        //转场过渡动画的执行时间</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</div><div class="line">    //在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</div><div class="line">    public func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        //拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        //弹出的控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //获取屏幕宽高</div><div class="line">        let bounds = UIScreen.mainScreen().bounds</div><div class="line">        //设置弹出控制器的初始位置</div><div class="line">        toVC.view.frame = CGRectOffset(finalFrameForVC, 0, bounds.size.height)</div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //自下而上弹出toVC的动画</div><div class="line">        UIView.animateWithDuration(transitionDuration(transitionContext),</div><div class="line">                                    delay: 0.0,</div><div class="line">                                    usingSpringWithDamping: 0.7,</div><div class="line">                                    initialSpringVelocity: 0.0,</div><div class="line">                                    options: .CurveLinear,</div><div class="line">                                    animations: &#123;</div><div class="line">                                    //执行的动画</div><div class="line">                                    //原来的控制给透明度</div><div class="line">                                    fromVC.view.alpha = 0.5</div><div class="line">                                    //修改弹出控制的frame</div><div class="line">                                    toVC.view.frame = finalFrameForVC</div><div class="line">                                    &#125;, completion: &#123;</div><div class="line">                                        finished in</div><div class="line">                                        	//动画完成后执行</div><div class="line">                                        	transitionContext.completeTransition(true)</div><div class="line">                                        	</div><div class="line">                                        fromVC.view.alpha = 1.0</div><div class="line">                                    &#125;)</div><div class="line">         NSLog(&quot;animateTransition&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   &lt;!-- UIView.animateWithDuration(1.0, animations: &#123; </div><div class="line">            </div><div class="line">            toVC.view.frame = finalFrameForVC;</div><div class="line">            fromVC.view.alpha = 0.5</div><div class="line">            </div><div class="line">            &#125;) &#123; (isCompletion) in</div><div class="line">                transitionContext.completeTransition(true)</div><div class="line">                fromVC.view.alpha = 1.0</div><div class="line">        &#125;--&gt;</div><div class="line"></div><div class="line"></div><div class="line">    //执行完成后的回调</div><div class="line">    public func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">            NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>madal的转场动画分为2类，present和dismiss，刚才我们实现的是animationControllerForPresentedController，这是present类，下节我们实现dissmiss的转场过渡效果</p>
<h4 id="Controller-dismiss过渡效果"><a href="#Controller-dismiss过渡效果" class="headerlink" title="Controller dismiss过渡效果"></a><code>Controller dismiss过渡效果</code></h4><p>present的过渡效果实现和modal过渡效果类似，也是设置委托、实现委托、实现动画，就不详细说明了，大家可以参考demo。这里我们只说说和present过渡的区别</p>
<h5 id="区别1-委托入口不同"><a href="#区别1-委托入口不同" class="headerlink" title="区别1 委托入口不同"></a><code>区别1 委托入口不同</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//Presented使用的委托</div><div class="line">   func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //Dismiss使用的委托</div><div class="line">   func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</div><div class="line">       //返回一个UIViewControllerAnimatedTransitioning类型</div><div class="line">       return DismissAnimation()</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"><a href="#区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。" class="headerlink" title="区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"></a>区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。</h5><p>DismissAnimation的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class DismissAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</div><div class="line">        //当前控制器</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        print(fromVC.dynamicType)//toViewController</div><div class="line">        //后控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">         print(toVC.dynamicType)//UINavigationController</div><div class="line">        </div><div class="line">        //获得大小</div><div class="line">        let screenBounds = UIScreen.mainScreen().bounds</div><div class="line">        </div><div class="line">        //当前控制器初始化大小</div><div class="line">        let initFrame = transitionContext.initialFrameForViewController(fromVC)</div><div class="line">        </div><div class="line">        //控制器最终的位置</div><div class="line">        let finalFrame = CGRectOffset(initFrame, 0, screenBounds.size.height)</div><div class="line">        //获得视图容器</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //容器中添加后面控制的view</div><div class="line">        containerView?.addSubview(toVC.view)</div><div class="line">        //????</div><div class="line">        containerView?.sendSubviewToBack(toVC.view)</div><div class="line">        //获得切换时间</div><div class="line">        let duration: NSTimeInterval = self.transitionDuration(transitionContext)</div><div class="line">        </div><div class="line">        </div><div class="line">        UIView.animateWithDuration(duration, animations: &#123;</div><div class="line">            </div><div class="line">            fromVC.view.frame = finalFrame</div><div class="line">            </div><div class="line">            &#125;, completion: &#123;</div><div class="line">                (finished: Bool) in</div><div class="line">                </div><div class="line">                //是否完成</div><div class="line">                transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="Controller-push、pop过渡效果"><a href="#Controller-push、pop过渡效果" class="headerlink" title="Controller push、pop过渡效果"></a><code>Controller push、pop过渡效果</code></h4><p>push、pop和present、dismiss的过渡走的是两个完全不同的委托，委托里面的方法有相似之处，比如都可以分为过渡和交互两类。交互的内容后面再说，先说过渡效果的区别。</p>
<ul>
<li><p><strong>实现的委托不同</strong>: push、pop自定义过渡动画，需要实现UINavigationControllerDelegate，而present、dismiss实现的是UIViewControllerTransitioningDelegate</p>
</li>
<li><p><strong>区分类型方式不同</strong>: UIViewControllerTransitioningDelegate通过2个委托present和dismiss区分开来，而在UINavigationControllerDelegate中，对应转场过渡动画只有一个委托，通过委托中的参数operation: UINavigationControllerOperation 区分pop和push</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"><a href="#UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果" class="headerlink" title="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"></a>UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果</h4><h4 id="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"><a href="#步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托" class="headerlink" title="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"></a><code>步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//推出视图切换效果</div><div class="line">    @IBAction func Transitioning1(sender: AnyObject) &#123;</div><div class="line">        let toVC = To1ViewController()</div><div class="line">        //设置委托</div><div class="line">        navigationController?.delegate = self</div><div class="line">        //主要是动画实现圆形扩大效果，需要知道一个初始园的位置，所以把uiview传过去。这种方式传递uiview不是一个很好的方式，这里为了demo能尽量的简单，所以这么做了</div><div class="line">        transitioningSender = sender as! UIView</div><div class="line">        navigationController?.pushViewController(toVC, animated: true)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="步骤2实现UINavigationControllerDelegate"><a href="#步骤2实现UINavigationControllerDelegate" class="headerlink" title="步骤2实现UINavigationControllerDelegate"></a><code>步骤2实现UINavigationControllerDelegate</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"><a href="#步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation" class="headerlink" title="步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"></a><code>步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation</code></h4><p>这个动画效果我就简单说说实现步骤，其余的大家看看代码。下面的参考文章中，有一篇对这个效果说的比较详细，大家可以去阅读</p>
<p>实现这样一个效果，基本原理是使用遮罩层，罩住presenting，有一个小圆是初始按钮点击的圆形路径，一个大圆是大于presenting的圆形路径。大圆和小圆作为遮罩的路径。判断过渡类型是presention -》 presenting还是presenting -》 presention，分别做不同的处理</p>
<p>presention -》 presenting ： 小圆作为初始遮罩层路径，罩住presenting，使用baseAnimation动画把遮罩层的路径从小圆路径变为大圆路径，presenting即可显示出来，完成过渡效果。 小圆的位置是通过跳转点击按钮决定的，小圆位置不同会影响到大圆结束的位置，所以分了左上、左下、右上、右下四个位置分别处理。这个步骤由于偷懒在presenting -》 presention这个过程里面被省略了，每次都指定了固定的小圆位置</p>
<p>presenting -》 presention ： 使用大圆遮住presenting，使用baseAnimation动画把遮罩层的路径从大圆路径变为小圆路径，presenting慢慢变小到看不见，presention慢慢即可显示出来，完成过渡效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class ExpandAnimation: NSObject, UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    //保存上下文</div><div class="line">    var transitionContext:UIViewControllerContextTransitioning!</div><div class="line">    //Pop or push</div><div class="line">    var type:UINavigationControllerOperation!</div><div class="line">    //初始点击的uiview对象，需要他的frame作为初始位置</div><div class="line">    var sender:UIView?</div><div class="line"></div><div class="line">    convenience init(type:UINavigationControllerOperation) &#123;</div><div class="line">        self.init()</div><div class="line">        self.type = type</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        return 0.5</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        self.transitionContext = transitionContext</div><div class="line">        NSLog(&quot;animateTransition&quot;)</div><div class="line">        if(type == .Push)&#123;</div><div class="line">            PushTransition(transitionContext)</div><div class="line">        &#125;else if(type == .Pop)&#123;</div><div class="line">            PopTransition(transitionContext)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">        NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //弹出效果 在固定位置进行的动画，可以根据需要改成动态位置触发</div><div class="line">    func PopTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line">        containerView!.addSubview(fromVC.view)</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        fromVC.view.layer.mask = mask</div><div class="line"></div><div class="line">        //画出小圆</div><div class="line">        let s_center = CGPoint(x: 50, y: 50)</div><div class="line">        let s_radius:CGFloat =  sqrt(800)</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: s_center.x, y: s_center.y, width: 1, height: 1), -s_radius, -s_radius))</div><div class="line">        //        mask.path = s_maskPath.CGPath</div><div class="line"></div><div class="line">        //画出大圆</div><div class="line">        let l_center = CGPoint(x: 50, y: 50)</div><div class="line">        let l_radius = sqrt( pow(view.bounds.width - l_center.x, 2) + pow(view.bounds.height - l_center.y, 2) ) + 150</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = l_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = s_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //present 动画，根据触发点的位置开始启动动画</div><div class="line">    func PushTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let finalFrame = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //小圆路径</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:(sender?.frame)!)</div><div class="line"></div><div class="line">        //大圆路径</div><div class="line">        let l_center =  (sender?.center)!</div><div class="line"></div><div class="line">        var l_radius:CGFloat</div><div class="line">        if(sender!.frame.origin.x &gt; (toVC.view.bounds.size.width / 2))&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //右上角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //右下角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //左上角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //左下角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        l_radius += 50 //稍微增加一些位置</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        mask.path = l_maskPath.CGPath</div><div class="line">        view.layer.mask = mask</div><div class="line"></div><div class="line"></div><div class="line">        ////错误用法，animationWithDuration不能通过操作layer产生动画</div><div class="line">        //UIView.animateWithDuration(5) &#123; () -&gt; Void in</div><div class="line">        //     mask.path = b_maskPath.CGPath</div><div class="line">        //&#125;</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = s_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = l_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.completeTransition(true)</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)?.view.layer.mask = nil</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)?.view.layer.mask = nil</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处&lt;a href=&quot;http://liuyanwei.jumppo.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Java中abstract不能共存的关键字</title>
    <link href="http://yoursite.com/2016/10/13/Java%E4%B8%ADabstract%E4%B8%8D%E8%83%BD%E5%85%B1%E5%AD%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/10/13/Java中abstract不能共存的关键字/</id>
    <published>2016-10-13T15:34:54.000Z</published>
    <updated>2016-10-13T15:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>##abstract修饰不能和哪些关键字共存?</p>
<ul>
<li><strong>static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.</strong></li>
<li><strong>final 不能和abstract组合,由于final不允许重写方法,abstract需要直接重写方法</strong></li>
<li><strong>private 不能和abstract组合,abstract是为了让子类看到并且重写,而private是不让外界使用和了解</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##abstract修饰不能和哪些关键字共存?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final 不能和abstract组
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift泛型初探</title>
    <link href="http://yoursite.com/2016/10/08/Swift%E6%B3%9B%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2016/10/08/Swift泛型初探/</id>
    <published>2016-10-08T14:33:34.000Z</published>
    <updated>2016-10-10T14:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming language一书,重新看了一遍里面的内容–其实对于泛型,我最初的理解是来源于Java,在项目中我真的比较少用到泛型.</p>
<h4 id="泛型需求的产生"><a href="#泛型需求的产生" class="headerlink" title="泛型需求的产生"></a>泛型需求的产生</h4><p>下面是书里面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  func swapTwoInt(inout a:Int,inout b:Int)&#123;</div><div class="line">        let tempA = a;</div><div class="line">        a = b;</div><div class="line">        b = tempA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要是我有这个交换两个内容的要求,但是这紧紧单纯是对Int但种类型的配置,如果我还需要有String和Double的话,我必须要拷贝代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func swapTwoString(inout a:String,inout b:String)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">&#125;</div><div class="line"></div><div class="line">      func swapTwoDouble(inout a:Double,inout b:Double)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>于是我们产生了泛型,它可以定义一种统一的类型<t>,这个时候你可以在参数里面写入这个参数,它代表了前后一致的类型,如String,Int,Double…</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)&#123;</div><div class="line">       let tempA = a;</div><div class="line">       a = b;</div><div class="line">       b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>在我写泛型的时候,遇到的第一个问题是返回值怎么处理?<br>唔哼,这个问题让我们继续把泛型的其他定义看下去的时候再继续思考吧.</p>
<h4 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h4><p>那么,泛型的书写方法就是用一对箭括号把类型名称合并起来:如 <strong><em><t></t></em></strong>,当然,你也可以一两个其他字母表示,<strong><em><u,t></u,t></em></strong></p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p> 其中,书中里面举了一个泛型类型的例子是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct IntStack &#123;</div><div class="line">    var items = [Int]();</div><div class="line">    /*</div><div class="line">     mutating关键字:由于swift功能强大,不仅可以让class遵守,也可以让enum和struct遵守</div><div class="line">     mutating关键字在定义协议的方法的时候可以在前面加上,让其三种类型在遵守协议的时候对有关键字的方法有不同的&quot;提示&quot;:</div><div class="line">    class: 在class中实现带有mutating方法的接口时，不用mutating进行修饰。因为对于class来说，类的成员变量和方法都是透明的，所以不必使用 mutating 来进行修饰</div><div class="line">     enum:</div><div class="line">     struct:如果将struct中的mutating去掉，则会报错不能改变结构体的成员。</div><div class="line">    */</div><div class="line">    //将一个数值入栈</div><div class="line">    mutating func push(item:Int)</div><div class="line">    &#123;</div><div class="line">        items.append(item)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //和内存中的栈一样,先进后出,所以只要移除最后一个元素即可</div><div class="line">    mutating func pop() -&gt; Int&#123;</div><div class="line">        </div><div class="line">        return items.removeLast()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是只针对Int一种类型避免也显得太弱了吧,所以我们可以用泛型对其进行改良:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Stack&lt;T&gt; &#123;</div><div class="line">      var items = [T]()</div><div class="line">      mutating func push(item: T) &#123;</div><div class="line">        items.append(item)</div><div class="line">      &#125;</div><div class="line">      mutating func pop() -&gt; T &#123;</div><div class="line">        return items.removeLast()</div><div class="line">      &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候可以将该类型延伸为相应的类型,如string:</p>
<pre><code>var stringsInStack = Stack&lt;String&gt;()
stringsInStack.push(&quot;1&quot;);//1
stringsInStack.push(&quot;2&quot;);//1,2
stringsInStack.push(&quot;3&quot;);//1,2,3
stringsInStack.push(&quot;4&quot;);//1,2,3,4
stringsInStack.pop()//1,2,3
</code></pre><p>现在,有点明白了Array和Dictionary为什么可以指定类型了吧,其实无形中我们已经用了很多泛型的内容,只是我们缺少了总结和理解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     //定义了一个内容必须为字符串的数组</div><div class="line">  var arr :[String] = []</div><div class="line">     arr[0] = &quot;name&quot;;</div><div class="line">     arr[1] = &quot;age&quot;;</div><div class="line">     arr[3] = &quot;height&quot;;</div><div class="line"></div><div class="line">//定义了一个key为String,value为AnyObject的字典  </div><div class="line">   var parma : [String:AnyObject] = [:]</div><div class="line">      parma[&quot;name&quot;] = &quot;shiron&quot;</div><div class="line">      parma[&quot;age&quot;] = 22</div><div class="line">      parma[&quot;height&quot;] = 1.70</div></pre></td></tr></table></figure>
<p>这里可以延伸出后面的一个话题:类型约束.</p>
<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>输入Dictionary点进去可以看到该类的属性和方法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible&#123;</div><div class="line">各种dict的属性和方法......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现在dict对泛型进行定义的时候,key有一个特殊的限制:</p>
<p><strong><strong><key: hashable,value=""></key:></strong></strong><br>此时,我们可以看到key被强制遵守了一个hashable的协议(注意:Swift 标准库中定义的一个特定协议,所有的 Swift 基本类型(如 String , Int , Double 和 Bool )默认都是可哈希。)</p>
<p>当你对泛型的有较高的输入要求时,可以限制某种类或者协议来进行类型约束,定义方法就是在泛型字母后面添加 T:SomeProtocol或者U:someClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func someFunction&lt;T:someClass,U:someProtocol&gt;(someT:T,someU:U)&#123;</div><div class="line">    //函数主体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩展一个泛型类型"><a href="#扩展一个泛型类型" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h4><p>当然我们泛型的好用之处不仅这么一点点.</p>
<p>书中还对Stack的类型作出了一个扩展:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension Stack &#123;</div><div class="line">    var topItem: T? &#123;</div><div class="line">        return items.isEmpty ? nil : items[items.count - 1]</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> topItem 属性会返回一个 T 类型的可选值。当栈为空的时候, topItem 将会返回 nil ;当栈不为空的时候, topItem 会返回 items 数组中的最后一个元素,然而你注意到了吗?我们在扩展里面并没有使用泛型类型的定义,它是从结构体中直接带过来了,对它进行解包则可以自己使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if let topItem = stackOfStrings.topItem &#123; </div><div class="line">    print(&quot; \(topItem)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming l
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中懒加载的then语法</title>
    <link href="http://yoursite.com/2016/09/13/swift%E4%B8%AD%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84then%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/13/swift中懒加载的then语法/</id>
    <published>2016-09-13T15:19:27.000Z</published>
    <updated>2016-10-19T09:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文:<br><a href="http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;mid=2652684686&amp;idx=1&amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;chksm=f00b6f44c77ce6521a20506a99cf446792ac70b537c09d05b7ad4066aa4b8a4cfaba4bedb2af&amp;scene=0#wechat_redirect" target="_blank" rel="external">Swift：让人眼前一亮的初始化方式</a></p>
<h3 id="then语法"><a href="#then语法" class="headerlink" title="then语法"></a>then语法</h3><p>个人非常喜欢这种简介的懒加载模式,唔,不过有时候真的会觉得$0的时候,无法感应该类的属性真蛋疼. 以下是加载方式,供大家参考学习.</p>
<pre><code>  import Foundation

 public protocol Then {}

 extension Then where Self: Any {
         /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: inout Self -&gt; Void) -&gt; Self {
        var copy = self
        block(&amp;copy)
        return copy
    }
     }

 extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: Self -&gt; Void) -&gt; Self {
        block(self)
        return self
     }
    }

extension NSObject: Then {}


  //textFiled的常用懒加载模式
    private lazy var textFiled : UITextField={
        let textFiled = UITextField()
        textFiled.placeholder = &quot;请输入文字&quot;
        return textFiled
    }()

  //在尾随闭包中实例化了UILabel时的写法
     lazy var label : UILabel={

        $0.text = &quot;我是占位文字,textFiled改变时我也会改变&quot;
        $0.font = UIFont.systemFontOfSize(16)

        return $0
    }(UILabel())


//文章开始时给出的then代码段,使得初始化更简洁
 let label = UILabel().then {
      $0.textAlignment = .Center
      $0.textColor = .blackColor()
      $0.text = &quot;Hello, World!&quot;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文:&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;amp;mid=2652684686&amp;amp;idx=1&amp;amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;amp
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习汇总</title>
    <link href="http://yoursite.com/2016/09/10/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/09/10/Java基础学习汇总/</id>
    <published>2016-09-10T15:31:12.000Z</published>
    <updated>2016-10-19T09:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础学习汇总"><a href="#Java基础学习汇总" class="headerlink" title="Java基础学习汇总"></a>Java基础学习汇总</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>了解:所谓多线程,即是在一个进程中,可以同时运行的多任务.如果把现实中的每个人理解为一个进程(QQ),那每个人可以同时处理多项任务,如一边听歌一边写作业可以理解为多线程开启.一个进程占用CUP时间是有限的,通常我们感觉不到有切换是因为CUP切换的速度极快.<h3 id="多线程的实现方法有两种"><a href="#多线程的实现方法有两种" class="headerlink" title="多线程的实现方法有两种"></a>多线程的实现方法有两种</h3></li>
<li><p>1.继承Thread</p>
<ul>
<li>定义类继承Thread</li>
<li>重写run方法</li>
<li>把新线程要做的内容写在run方法中</li>
<li>创建类的对象</li>
<li>执行start方法</li>
<li>注意:匿名内部类和普通类方式非常相似</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	//1.普通定义一个新的类来创建</div><div class="line">	Person p = new Person();</div><div class="line">	p.start();</div><div class="line">	//1.普通定义一个匿名类来创建</div><div class="line">	new Thread()&#123;</div><div class="line">		public void run()&#123;</div><div class="line">			System.out.println(&quot;Thread多线程启动(匿名内	部类)&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;.start();	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Thread方式</div><div class="line">class Person extends Thread &#123;</div><div class="line">	public void run()&#123;</div><div class="line">	System.out.println(&quot;Thread多线程启动,继承方式&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.实现接口Runnable(Thread构造函数中传递了runnable的引用,通过init()方法传递target,用于判断是否执行run()方法)</p>
<ul>
<li>定义类实现Runnable</li>
<li>实现run方法</li>
<li>把操作写在run中</li>
<li>创建Thread对象,传入runnable</li>
<li>调用Runnable的start方法</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">//1.普通类实现了runnable接口来实现调用里面的run方法</div><div class="line">Student s = new Student();</div><div class="line">Thread t = new Thread(s);</div><div class="line">t.start();</div><div class="line">//2.匿名类来实现runnable接口</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;匿名内部类Runnable多线程启动方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;).start();	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class Student implements Runnable&#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;Runnable多线程启动方法,继承方式&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="两种线程的区别"><a href="#两种线程的区别" class="headerlink" title="两种线程的区别"></a>两种线程的区别</h3><ul>
<li>继承Thread<ul>
<li>好处:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端:如果已经有父类,就不能用这种方式</li>
</ul>
</li>
<li>实现Runnable<ul>
<li>好处:可以有父类,直接只是实现接口</li>
<li>弊端:间接把对象作为构造方法的参数传递进去,较为复杂,但自由度较大</li>
</ul>
</li>
</ul>
<h3 id="线程中其他操作"><a href="#线程中其他操作" class="headerlink" title="线程中其他操作"></a>线程中其他操作</h3><ul>
<li>通过getName()可以获得当前线程的名字</li>
<li>通过setName(String)可以设置线程名字</li>
<li>Thread.currentThread()可以获得当前线程对象,获得对象后可以对其进行操作(改名,获得名字)</li>
<li>Thread.sleep(毫秒),类方法调用,可以使得当前线程休眠</li>
<li>setPriority()设置线程的优先级</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java基础学习汇总&quot;&gt;&lt;a href=&quot;#Java基础学习汇总&quot; class=&quot;headerlink&quot; title=&quot;Java基础学习汇总&quot;&gt;&lt;/a&gt;Java基础学习汇总&lt;/h2&gt;&lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;header
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>swift中的extension(持续更新)</title>
    <link href="http://yoursite.com/2016/08/25/swift%E4%B8%AD%E7%9A%84extension-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/08/25/swift中的extension-持续更新/</id>
    <published>2016-08-25T04:36:39.000Z</published>
    <updated>2016-10-27T13:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用"><a href="#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用" class="headerlink" title="在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~"></a>在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~</h4><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension String&#123;</div><div class="line">    </div><div class="line">      /**</div><div class="line">     将时间戳转换成时间</div><div class="line">     </div><div class="line">     - parameter timestamp: 时间戳</div><div class="line">     - parameter formatter: 时间格式</div><div class="line">     */</div><div class="line">    static func stringFromTimestamp(timestamp: String?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let stamp = timestamp, fm = formatter else &#123; return nil &#125;</div><div class="line">        let nsStamp = NSString(string: stamp)</div><div class="line">        let date = NSDate(timeIntervalSince1970: nsStamp.doubleValue)</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(date)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将时间转换成字符串</div><div class="line">     </div><div class="line">     */</div><div class="line">    static func stringFromDate(date: NSDate?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let timeDate = date, fm = formatter else &#123; return nil &#125;</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(timeDate)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    手机号验证</div><div class="line">    </div><div class="line">    - parameter mobile: 手机号</div><div class="line">    </div><div class="line">    - returns: true/fales 符合条件,不符合条件</div><div class="line">    */</div><div class="line">    static func isValidateMobile(mobile: String?) -&gt; Bool &#123;</div><div class="line">        let phoneRegex = &quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;</div><div class="line">        let phoneTest = NSPredicate(format: &quot;SELF MATCHES %@&quot;, phoneRegex)</div><div class="line">        if mobile != nil &#123;</div><div class="line">            return phoneTest.evaluateWithObject(mobile)</div><div class="line">        &#125; else &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    四舍五入</div><div class="line">    </div><div class="line">    - parameter price:    要四舍五入的值</div><div class="line">    - parameter position: 保留多少小数位</div><div class="line">    </div><div class="line">    - returns: 返回四舍五入后的值</div><div class="line">    */</div><div class="line">    static func notRounding(price: Float, afterPoint position: Int16) -&gt; NSString? &#123;</div><div class="line">        let roundingBehavior = NSDecimalNumberHandler(roundingMode: NSRoundingMode.RoundUp, scale: position, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: false)</div><div class="line">        var ouncesDecimal: NSDecimalNumber</div><div class="line">        var roundedOunces: NSDecimalNumber</div><div class="line">        </div><div class="line">        ouncesDecimal = NSDecimalNumber(float: price)</div><div class="line">        roundedOunces = ouncesDecimal.decimalNumberByRoundingAccordingToBehavior(roundingBehavior)</div><div class="line">        </div><div class="line">        return roundedOunces.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    获取当前星期几</div><div class="line">    </div><div class="line">    - parameter date: 传入的时间</div><div class="line">    </div><div class="line">    - returns: 返回当前为星期几元祖</div><div class="line">    */</div><div class="line">    static func getCurrentWeekDay(date: NSDate) -&gt; (String, Int)? &#123;</div><div class="line">        let arrWeek = [&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;]</div><div class="line">        let date = NSDate()</div><div class="line">        let calendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)</div><div class="line">        let timeZone = NSTimeZone(name: &quot;Asia/Shanghai&quot;)</div><div class="line">        calendar!.timeZone = timeZone!</div><div class="line">        var comps = NSDateComponents()</div><div class="line">        comps = calendar!.components(NSCalendarUnit.Weekday, fromDate: date)</div><div class="line">        let week = comps.weekday</div><div class="line">        return (arrWeek[week - 1], week - 1)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     - parameter comment:   注释名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?, comment: String?) -&gt; String &#123;</div><div class="line">        </div><div class="line">        guard let commentStr = comment else &#123;</div><div class="line">            return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: commentStr)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?) -&gt; String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 对应默认的Localizable.strings</div><div class="line">    var localized: String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: nil, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    浮点数相乘</div><div class="line">    */</div><div class="line">    static func decimalNumberMutiplyWithString(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByMultiplyingBy(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相加</div><div class="line">     */</div><div class="line">    static func decimalNumberByAdding(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByAdding(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相减</div><div class="line">     */</div><div class="line">    static func decimalNumberBySubtracting(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplierNumber.decimalNumberBySubtracting(multiplicandNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     过滤空格</div><div class="line">     */</div><div class="line">    static func trimmingCharactersWhite(str: String) -&gt; String &#123;</div><div class="line">        // 去除两端空格</div><div class="line">        let temp = str.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())</div><div class="line">        // 去除其余空格</div><div class="line">        let text = temp.stringByReplacingOccurrencesOfString(&quot; &quot;, withString: &quot;&quot;)</div><div class="line">        return text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    //截取特定字符串</div><div class="line">    subscript (r: Range&lt;Int&gt;) -&gt; String &#123;</div><div class="line">        get &#123;</div><div class="line">            let startIndex = self.startIndex.advancedBy(r.startIndex)</div><div class="line">            let endIndex = self.startIndex.advancedBy(r.endIndex)</div><div class="line">            </div><div class="line">            return self[Range(start: startIndex, end: endIndex)]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将当前字符串拼接到cache目录后面</div><div class="line">     */</div><div class="line">    func cacheDir() -&gt; String&#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.cachesDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到doc目录后面</div><div class="line">     */</div><div class="line">    func docDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到tmp目录后面</div><div class="line">     */</div><div class="line">    func tmpDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSTemporaryDirectory() as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot;&gt;&lt;a href=&quot;#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 万能跳转界面方法</title>
    <link href="http://yoursite.com/2016/08/15/iOS-%E4%B8%87%E8%83%BD%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/15/iOS-万能跳转界面方法/</id>
    <published>2016-08-15T01:52:07.000Z</published>
    <updated>2016-11-15T01:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://www.cocoachina.com/ios/20150824/13104.html" target="_blank" rel="external">cocoaChina的汉斯哈哈哈</a></p>
<p>在开发项目中，会有这样变态的需求：</p>
<ul>
<li><p>推送：根据服务端推送过来的数据规则，跳转到对应的控制器</p>
</li>
<li><p>feeds列表：不同类似的cell，可能跳转不同的控制器（嘘！产品经理是这样要求：我也不确定会跳转哪个界面哦，可能是这个又可能是那个，能给我做灵活吗？根据后台返回规则任意跳转？）</p>
</li>
</ul>
<p>思考：wocao！这变态的需求，要拒绝他吗？</p>
<p>switch判断呗，考虑所有跳转的因素？这不得写死我…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">switch () &#123;</div><div class="line">    case :</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>我是这么个实现的（runtime是个好东西）</strong></p>
<p>利用runtime动态生成对象、属性、方法这特性，我们可以先跟服务端商量好，定义跳转规则，比如要跳转到A控制器，需要传属性id、type，那么服务端返回字典给我，里面有控制器名，两个属性名跟属性值，客户端就可以根据控制器名生成对象，再用kvc给对象赋值，这样就搞定了 —O(∩_∩)O哈哈哈</p>
<p>比如：根据推送规则跳转对应界面HSFeedsViewController</p>
<p>HSFeedsViewController.h：</p>
<ul>
<li>进入该界面需要传的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">@interface HSFeedsViewController : UIViewController</div><div class="line">// 注：根据下面的两个属性，可以从服务器获取对应的频道列表数据</div><div class="line">/** 频道ID */</div><div class="line">@property (nonatomic, copy) NSString *ID;</div><div class="line">/** 频道type */</div><div class="line">@property (nonatomic, copy) NSString *type;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>AppDelegate.m：</p>
<ul>
<li>推送过来的消息规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 这个规则肯定事先跟服务端沟通好，跳转对应的界面需要对应的参数</div><div class="line">NSDictionary *userInfo = @&#123;</div><div class="line">                           @&quot;class&quot;: @&quot;HSFeedsViewController&quot;,</div><div class="line">                           @&quot;property&quot;: @&#123;</div><div class="line">                                        @&quot;ID&quot;: @&quot;123&quot;,</div><div class="line">                                        @&quot;type&quot;: @&quot;12&quot;</div><div class="line">                                   &#125;</div><div class="line">                           &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>接收推送消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</div><div class="line">&#123;</div><div class="line">    [self push:userInfo];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>跳转界面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">- (void)push:(NSDictionary *)params</div><div class="line">&#123;</div><div class="line">    // 类名</div><div class="line">    NSString *class =[NSString stringWithFormat:@&quot;%@&quot;, params[@&quot;class&quot;]];</div><div class="line">    const char *className = [class cStringUsingEncoding:NSASCIIStringEncoding];</div><div class="line">    // 从一个字串返回一个类</div><div class="line">    Class newClass = objc_getClass(className);</div><div class="line">    if (!newClass)</div><div class="line">    &#123;</div><div class="line">        // 创建一个类</div><div class="line">        Class superClass = [NSObject class];</div><div class="line">        newClass = objc_allocateClassPair(superClass, className, 0);</div><div class="line">        // 注册你创建的这个类</div><div class="line">        objc_registerClassPair(newClass);</div><div class="line">    &#125;</div><div class="line">    // 创建对象</div><div class="line">    id instance = [[newClass alloc] init];</div><div class="line">    // 对该对象赋值属性</div><div class="line">    NSDictionary * propertys = params[@&quot;property&quot;];</div><div class="line">    [propertys enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">        // 检测这个对象是否存在该属性</div><div class="line">        if ([self checkIsExistPropertyWithInstance:instance verifyPropertyName:key]) &#123;</div><div class="line">            // 利用kvc赋值</div><div class="line">            [instance setValue:obj forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    // 获取导航控制器</div><div class="line">    UITabBarController *tabVC = (UITabBarController *)self.window.rootViewController;</div><div class="line">    UINavigationController *pushClassStance = (UINavigationController *)tabVC.viewControllers[tabVC.selectedIndex];</div><div class="line">    // 跳转到对应的控制器</div><div class="line">    [pushClassStance pushViewController:instance animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>检测对象是否存在该属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (BOOL)checkIsExistPropertyWithInstance:(id)instance verifyPropertyName:(NSString *)verifyPropertyName</div><div class="line">&#123;</div><div class="line">    unsigned int outCount, i;</div><div class="line">    // 获取对象里的属性列表</div><div class="line">    objc_property_t * properties = class_copyPropertyList([instance</div><div class="line">                                                           class], &amp;outCount);</div><div class="line">    for (i = 0; i &lt; outCount; i++) &#123;</div><div class="line">        objc_property_t property =properties[i];</div><div class="line">        //  属性名转成字符串</div><div class="line">        NSString *propertyName = [[NSString alloc] initWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">        // 判断该属性是否存在</div><div class="line">        if ([propertyName isEqualToString:verifyPropertyName]) &#123;</div><div class="line">            free(properties);</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;a href=&quot;http://www.cocoachina.com/ios/20150824/13104.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cocoaChina的汉斯哈哈哈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在开发项目中，会有这样变
    
    </summary>
    
    
  </entry>
  
</feed>
