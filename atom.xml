<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiron</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-16T12:17:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js中的Promise函数使用</title>
    <link href="http://yoursite.com/2016/11/16/js%E4%B8%AD%E7%9A%84Promise%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/11/16/js中的Promise函数使用/</id>
    <published>2016-11-16T11:43:10.000Z</published>
    <updated>2016-11-16T12:17:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="初闻Promise"><a href="#初闻Promise" class="headerlink" title="初闻Promise"></a>初闻Promise</h5><p>先贴上Promise的使用吧,其实我对它的理解并不是特别深厚,厉害理解透彻了再回来重新深刻的理解,本文中代码出于<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000#0" target="_blank" rel="external">廖雪峰老师的博客</a>,仅学习记录之用,并非人原创~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">          console.log(&apos;start new Promise&apos;);</div><div class="line">            var timeOut = Math.random() * 2;</div><div class="line">            console.log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">            setTimeout(function()&#123;</div><div class="line">                  if(timeOut&lt;1)&#123;</div><div class="line">                    console.log(&apos;call resolver()...&apos;);</div><div class="line">                    resolve(&apos;200 ok&apos;);</div><div class="line">                    //reject(&apos;失败原因是注释了代码&apos;);</div><div class="line">                  &#125;else &#123;</div><div class="line">                    console.log(&apos;call reject()...&apos;);</div><div class="line">                    reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">                  &#125;</div><div class="line">            &#125;,timeOut * 1000);</div><div class="line">        </div><div class="line">        &#125;).then(function(result)&#123;</div><div class="line">          console.log(&apos;成功&apos;+result);</div><div class="line">        &#125;).catch(function (reason) &#123;</div><div class="line">          console.log(&apos;Failed: &apos; + reason);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>该段代码打印的结果是:<code>成功200 ok</code></p>
<h5 id="进行链式编程"><a href="#进行链式编程" class="headerlink" title="进行链式编程"></a>进行链式编程</h5><p>最初的时候我感觉很不明白为何只是执行了两个参数的其中一个为何能够调用下面then的函数,后来通过注释…只要我执行了resolve的话,肯定回调then中的代码,如果我执行了reject的话,就会执行catch中的代码,这里还会把参数带过去给then和catch中的函数,那么,如果一直调用then的话,就可以进行链式变成了,返回的对象当然是要<code>Promise</code>对象~我们来看老师下面这段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function multiply(input)&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">        console.log(&apos;calculating &apos; + input + &apos; x &apos; + input + &apos;...&apos;);</div><div class="line">        setTimeout(resolve,500,input* input);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function add(input) &#123;</div><div class="line">  return new Promise(function(resolve,reject) &#123;</div><div class="line">    console.log(&apos;calculating &apos; + input + &apos; + &apos; + input + &apos;...&apos;);</div><div class="line">    setTimeout(resolve, 500, input + input);</div><div class="line"></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;start new Promise...&apos;);</div><div class="line">    resolve(123);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(add)</div><div class="line">.then(multiply)</div><div class="line">.then(add)</div><div class="line">.then(function (result) &#123;</div><div class="line">  console.log(&apos;Got value: &apos; + result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为每一次返回值都是Promise对象,所以还是可以.then来延时调用,等待函数体内自行了resolve的时候真正执行该函数.</p>
<h5 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h5><p>基于Promise的原理,我们也可以对ajax进行一个简单的封装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">// ajax函数将返回Promise对象:</div><div class="line">function ajax(method, url, data) &#123;</div><div class="line">    var request = new XMLHttpRequest();</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        request.onreadystatechange = function () &#123;</div><div class="line">            if (request.readyState === 4) &#123;</div><div class="line">                if (request.status === 200) &#123;</div><div class="line">                //成功时把参数传出去</div><div class="line">                    resolve(request.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                //失败时把失败原因回调</div><div class="line">                    reject(request.status);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        request.open(method, url);</div><div class="line">        request.send(data);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class="line">p.then(function (text) &#123; // 如果AJAX成功，获得响应内容</div><div class="line">    log.innerText = text;</div><div class="line">&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码</div><div class="line">    log.innerText = &apos;ERROR: &apos; + status;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种封装的感觉其实就跟OC中网络请求的闭包回调非常相似,大家可以类比的进行学习</p>
<h5 id="所谓的Promise到底是"><a href="#所谓的Promise到底是" class="headerlink" title="所谓的Promise到底是?"></a>所谓的Promise到底是?</h5><p>Promise就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</p>
<p>Promise 对象有以下两个特点。</p>
<ol>
<li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</li>
</ol>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><strong>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</strong><br>来自:<a href="http://www.cnblogs.com/libin-1/p/5947602.html" target="_blank" rel="external">彻底理解Javascript 中的 Promise</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;初闻Promise&quot;&gt;&lt;a href=&quot;#初闻Promise&quot; class=&quot;headerlink&quot; title=&quot;初闻Promise&quot;&gt;&lt;/a&gt;初闻Promise&lt;/h5&gt;&lt;p&gt;先贴上Promise的使用吧,其实我对它的理解并不是特别深厚,厉害理解透彻了再回来重
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的箭头函数和普通函数的对比</title>
    <link href="http://yoursite.com/2016/11/16/js%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2016/11/16/js中的箭头函数和普通函数的对比/</id>
    <published>2016-11-16T04:47:32.000Z</published>
    <updated>2016-11-16T05:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="箭头对象"><a href="#箭头对象" class="headerlink" title="箭头对象"></a>箭头对象</h5><p>在基于ES6标准下,JavaScript有了一个新的函数叫做箭头函数,那么,这个箭头函数有什么作用呢?现在用以前的写法写几个简答的函数看看吧!(首先要确认您的浏览器支持箭头函数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var abs = &#123;</div><div class="line">        fun1:function(x)&#123;</div><div class="line">          return x * x ;</div><div class="line">        &#125;,</div><div class="line">        fun2:function(x)&#123;</div><div class="line">          if (x &gt; 0) &#123;</div><div class="line">            return x ;</div><div class="line">          &#125; else &#123;</div><div class="line">            return -x;</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        fun3:function(x,y)&#123;</div><div class="line">          return x * y;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      console.log(abs.fun1(10));//100</div><div class="line">      console.log(abs.fun2(-10));//10</div><div class="line">      console.log(abs.fun3(10,10));//100</div></pre></td></tr></table></figure>
<p>那么,如果和箭头函数对比起来是怎么样的差异呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var fun1 = x =&gt; x * x;</div><div class="line">console.log(fun1(20));//400</div><div class="line"></div><div class="line">var fun2 = x =&gt; &#123;</div><div class="line">    if (x &gt; 0) &#123;</div><div class="line">      return x ;</div><div class="line">    &#125; else &#123;</div><div class="line">      return -x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(fun2(10));//10</div><div class="line">console.log(fun2(-20));//20</div><div class="line"></div><div class="line"></div><div class="line">var fun3 = (x,y) =&gt; x * y;</div><div class="line">console.log(fun3(20,30));//600</div></pre></td></tr></table></figure>
<p>由fun1的函数可以发现,我们箭头函数的写法是 <code>x =&gt; x * x</code>这种格式,这个单个参数的函数,fun2也是单个参数的函数,而fun3 <code>(x,y) =&gt; x * y</code>是一个双参数的函数,如此类推,多个函数的闭包可以使用我们之前说过<code>(x,y,...rest) =&gt; {return xxx}</code>,如果需要返回一个对象的话,需要使用一下的方法:<code>x =&gt; ({foo:x})</code></p>
<h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>this关键字的意思在指向了当前对象,它和匿名函数相似,但也有一个明显的区别:箭头函数中的this是词法作用域,由上下文确定.<br>看一个经典的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = function () &#123;</div><div class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此处的this对window进行了错误的绑定,所以运行的时候会报错,但是如果我们改用下面这个例子的话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn =&gt;  new Date().getFullYear() - this.birth; // this指向obj对象</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); // 25</div></pre></td></tr></table></figure>
<p>当然,我们也可以使用hack的这种写法,可能多一句话没有那么优雅吧~<code>var that = this</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;箭头对象&quot;&gt;&lt;a href=&quot;#箭头对象&quot; class=&quot;headerlink&quot; title=&quot;箭头对象&quot;&gt;&lt;/a&gt;箭头对象&lt;/h5&gt;&lt;p&gt;在基于ES6标准下,JavaScript有了一个新的函数叫做箭头函数,那么,这个箭头函数有什么作用呢?现在用以前的写法写几个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js在ES6中可以使用iterable进行遍历</title>
    <link href="http://yoursite.com/2016/11/15/js%E5%9C%A8ES6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8iterable%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2016/11/15/js在ES6中可以使用iterable进行遍历/</id>
    <published>2016-11-15T03:50:14.000Z</published>
    <updated>2016-11-15T11:50:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用iterable的时候首先要确认浏览器时候支持ES6的语法,可以使用以下代码来检查是否适配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&apos;ues strict&apos;</div><div class="line">var a = [1,2,3];</div><div class="line">for (var x of a) &#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">alert(&apos;你的浏览器支持for ... of&apos;);</div></pre></td></tr></table></figure>
<p>在正常情况下,<code>Array</code>可以支持以下两种形式来进行下标遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> for (var i = 0; i &lt; array.length; i++) &#123;</div><div class="line">   array[i]</div><div class="line">   for (var variable in object) &#123;</div><div class="line">     if (object.hasOwnProperty(variable)) &#123;</div><div class="line">       </div><div class="line">   	&#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">for (var variable in object) &#123;</div><div class="line">   if (object.hasOwnProperty(variable)) &#123;</div><div class="line">     </div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>但是对于ES6新增的<code>Set</code>和<code>Map</code>类型就无法使用该方法来进行遍历了,因此在ES6中引入了一个新的解决模式:<code>iterable</code>类型的模式来进行<code>for...of</code>遍历.样式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;];</div><div class="line">    var s = new Set([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]);</div><div class="line">    var m = new Map([[1,&apos;x&apos;],[2,&apos;y&apos;],[3,&apos;z&apos;]]);</div><div class="line"></div><div class="line">    for (var x of a) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;;</div><div class="line">//A -&gt; B  -&gt; C</div><div class="line"></div><div class="line">    for (var x of s) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;</div><div class="line">//A -&gt; B  -&gt; C</div><div class="line">    for (var x of m) &#123;</div><div class="line">      console.log(x);</div><div class="line">    &#125;</div><div class="line">//[1,&apos;x&apos;]-&gt;  [2,&apos;y&apos;] -&gt; [3,&apos;z&apos;]</div></pre></td></tr></table></figure>
<p><code>for...in</code>实际上和最新的<code>for...of</code>是有区别的,<code>for...in</code>它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var a = [1,2,3];</div><div class="line">a.name = &apos;xiaoming&apos;;</div><div class="line">for (var b in a) &#123;</div><div class="line">  console.log(b);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">结果如下:</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">name</div><div class="line"> */</div></pre></td></tr></table></figure>
<p><code>for ... in</code>循环将把name包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.name = &apos;Hello&apos;;</div><div class="line">for (var x of a) &#123;</div><div class="line">    alert(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是为什么要引入新的<code>for ... of</code>循环。</p>
<p>然而，更好的方式是直接使用iterable内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.forEach(function (element, index, array) &#123;</div><div class="line">    // element: 指向当前元素的值</div><div class="line">    // index: 指向当前索引</div><div class="line">    // array: 指向Array对象本身</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，<code>forEach()</code>方法是ES5.1标准引入的，你需要测试浏览器是否支持。</p>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</div><div class="line">s.forEach(function (element, sameElement, set) &#123;</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</div><div class="line">m.forEach(function (value, key, map) &#123;</div><div class="line">    alert(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">a.forEach(function (element) &#123;</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用iterable的时候首先要确认浏览器时候支持ES6的语法,可以使用以下代码来检查是否适配:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS最全性能优化</title>
    <link href="http://yoursite.com/2016/11/13/iOS%E6%9C%80%E5%85%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/11/13/iOS最全性能优化/</id>
    <published>2016-11-13T14:48:30.000Z</published>
    <updated>2016-11-14T04:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)</p>
<p>原文地址:<a href="http://www.jianshu.com/p/9c450e512020" target="_blank" rel="external">iOS最全性能优化 - HelloYeah</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级："><a href="#我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级：" class="headerlink" title="我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级："></a>我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：</h4><ul>
<li>入门级（这是些你一定会经常用在你app开发中的建议）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. 用ARC管理内存</div><div class="line">2. 在正确的地方使用reuseIdentifier</div><div class="line">3. 尽可能使Views透明</div><div class="line">4. 避免庞大的XIB</div><div class="line">5. 不要block主线程</div><div class="line">6. 在Image Views中调整图片大小</div><div class="line">7. 选择正确的Collection</div><div class="line">8. 打开gzip压缩</div></pre></td></tr></table></figure>
<ul>
<li>中级（这些是你可能在一些相对复杂情况下可能用到的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">9. 重用和延迟加载Views</div><div class="line">10. Cache, Cache, 还是Cache！</div><div class="line">11. 权衡渲染方法</div><div class="line">12. 处理内存警告</div><div class="line">13. 重用大开销的对象</div><div class="line">14. 使用Sprite Sheets</div><div class="line">15. 避免反复处理数据</div><div class="line">16. 选择正确的数据格式</div><div class="line">17. 正确地设定Background Images</div><div class="line">18. 减少使用Web特性</div><div class="line">19. 设定Shadow Path</div><div class="line">20. 优化你的Table View</div><div class="line">21. 选择正确的数据存储选项</div></pre></td></tr></table></figure>
<ul>
<li>进阶级（这些建议只应该在你确信他们可以解决问题和得心应手的情况下采用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">22. 加速启动时间</div><div class="line">23. 使用Autorelease Pool</div><div class="line">24. 选择是否缓存图片</div><div class="line">25. 尽量避免日期格式转换</div></pre></td></tr></table></figure>
<p>初学者性能提升<br>这个部分致力于一些能提高性能的基本改变。但所有层次的开发者都有可能会从这个记录了一些被忽视的项目的小小的性能备忘录里获得一些提升。</p>
<h5 id="1-用ARC管理内存"><a href="#1-用ARC管理内存" class="headerlink" title="1.用ARC管理内存"></a>1.用ARC管理内存</h5><ul>
<li><p>ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。<br>  下面是你会经常用来去创建一个View的代码段:</p>
<pre><code>UIView *view = [[UIView alloc] init];
 // ...
[self.view addSubview:view];
 [view release];
</code></pre></li>
<li><p>忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。这都啥年代了，你应该在你的所有项目里使用ARC!</p>
</li>
</ul>
<h5 id="2-在正确的地方使用-reuseIdentifier"><a href="#2-在正确的地方使用-reuseIdentifier" class="headerlink" title="2.在正确的地方使用 reuseIdentifier"></a>2.在正确的地方使用 reuseIdentifier</h5><ul>
<li><p>一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。</p>
</li>
<li><p>为了性能最优化，table view用 tableView:cellForRowAtIndexPath: 为rows分配cells的时候，它的数据应该重用自UITableViewCell。 一个table view维持一个队列的数据可重用的UITableViewCell对象。不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。</p>
</li>
</ul>
<ul>
<li>自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers</li>
</ul>
<h5 id="3-尽量把views设置为完全不透明"><a href="#3-尽量把views设置为完全不透明" class="headerlink" title="3.尽量把views设置为完全不透明"></a>3.尽量把views设置为完全不透明</h5><ul>
<li><p>如果你有透明的Views你应该设置它们的opaque(不透明)属性为YES。例如一个黑色半透明的可以设置为一个灰色不透明的View替代.原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p>
<ul>
<li>Apple的文档对于为图片设置透明属性的描述是：<br>(opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</li>
</ul>
</li>
</ul>
<ul>
<li><p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p>
</li>
<li><p>换种说法，大家可能更好理解：</p>
<p> 只要一个视图的不透明度小于1,就会导致blending.blending操作在iOS的图形处理器（GPU）中完成的,blending主要指的是混合像素颜色的计算。举个例子,我们把两个图层叠加在一起,如果第一个图层的有透明效果,则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。</p>
<ul>
<li><p>为什么Blending会导致性能的损失？</p>
<p>原因是很直观的,如果一个图层是完全不透明的,则系统直接显示该图层的颜色即可。而如果图层是带透明效果的,则会引入更多的计算,因为需要把下面的图层也包括进来,进行混合后颜色的计算。</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-避免过于庞大的XIB"><a href="#4-避免过于庞大的XIB" class="headerlink" title="4. 避免过于庞大的XIB"></a>4. 避免过于庞大的XIB</h5><ul>
<li><p>iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。</p>
</li>
<li><p>如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>
</li>
<li><p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的imageNamed:方法来获取图片资源。</p>
</li>
</ul>
<h5 id="5-不要阻塞主线程"><a href="#5-不要阻塞主线程" class="headerlink" title="5. 不要阻塞主线程"></a>5. 不要阻塞主线程</h5><ul>
<li><p>永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应</p>
</li>
<li><p>大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。或者使用像 AFNetworking这样的框架来异步地做这些操作。</p>
</li>
<li>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.<br>  你可以使用NSURLConnection异步地做网络操作:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler</div></pre></td></tr></table></figure>
<h5 id="6-在Image-Views中调整图片大小"><a href="#6-在Image-Views中调整图片大小" class="headerlink" title="6. 在Image Views中调整图片大小"></a>6. 在Image Views中调整图片大小</h5><ul>
<li>如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</li>
<li>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</li>
</ul>
<h5 id="7-选择正确的Collection"><a href="#7-选择正确的Collection" class="headerlink" title="7. 选择正确的Collection"></a>7. 选择正确的Collection</h5><ul>
<li><p>学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。</p>
</li>
<li><p>Apple有一个 Collections Programming Topics 的文档详尽介绍了可用的classes间的差别和你该在哪些场景中使用它们。这对于任何使用collections的人来说是一个必读的文档。<br>呵呵，我就知道你因为太长没看…这是一些常见collection的总结：</p>
<p>  Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。<br>  Dictionaries: 存储键值对。 用键来查找比较快。<br>  Sets: 无序的一组值。用值来查找很快，插入/删除很快。</p>
</li>
</ul>
<h5 id="8-打开gzip压缩"><a href="#8-打开gzip压缩" class="headerlink" title="8. 打开gzip压缩"></a>8. 打开gzip压缩</h5><ul>
<li>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</li>
<li>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。<ul>
<li>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。</li>
</ul>
</li>
</ul>
<h5 id="9-重用和延迟加载-lazy-load-Views"><a href="#9-重用和延迟加载-lazy-load-Views" class="headerlink" title="9. 重用和延迟加载(lazy load) Views"></a>9. 重用和延迟加载(lazy load) Views</h5><ul>
<li>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</li>
<li>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</li>
<li><p>这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。<br>创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p>
<ol>
<li>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</li>
<li>当需要时才创建并展示。</li>
</ol>
</li>
<li><p>每个方案都有其优缺点。</p>
<ul>
<li>用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</li>
<li>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</li>
</ul>
</li>
</ul>
<h5 id="10-Cache-Cache-还是Cache"><a href="#10-Cache-Cache-还是Cache" class="headerlink" title="10. Cache, Cache, 还是Cache!"></a>10. Cache, Cache, 还是Cache!</h5><ul>
<li><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。<br>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p>
</li>
<li><p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。<br>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url &#123;</div><div class="line"> NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div><div class="line"></div><div class="line"> request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image</div><div class="line"> request.HTTPShouldHandleCookies = NO;</div><div class="line"> request.HTTPShouldUsePipelining = YES;</div><div class="line"> [request addValue:@&quot;image/*&quot;forHTTPHeaderField:@&quot;Accept&quot;];</div><div class="line"></div><div class="line"> returnrequest;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p>
</li>
<li><p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。<br><code>NSCache</code>和<code>NSDictionary</code>类似，不同的是系统回收内存的时候它会自动删掉它的内容。</p>
</li>
</ul>
<h5 id="11-权衡渲染方法"><a href="#11-权衡渲染方法" class="headerlink" title="11. 权衡渲染方法"></a>11. 权衡渲染方法</h5><ul>
<li><p>在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，或者可以用CALayer， CoreGraphics甚至OpenGL来画它们。<br>当然每个不同的解决方法都有不同的复杂程度和相应的性能。有一篇Apple UIKit team中的一员Andy Matuschak推荐过的很棒的关于graphic性能的帖子很值得一读。</p>
</li>
<li><p>简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积 – 这就是使用可变大小的图片更好的地方了: 你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。</p>
</li>
<li>然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。</li>
<li>总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。</li>
</ul>
<h5 id="12-处理内存警告"><a href="#12-处理内存警告" class="headerlink" title="12. 处理内存警告"></a>12. 处理内存警告</h5><ul>
<li>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:<br>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.<br>幸运的是，UIKit提供了几种收集低内存警告的方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 在app delegate中使用applicationDidReceiveMemoryWarning: 的方法</div><div class="line">* 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning</div><div class="line">* 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</div></pre></td></tr></table></figure>
<ul>
<li><p>一旦收到这类通知，你就需要释放任何不必要的内存使用。<br>例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>
</li>
<li><p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。<br>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>
</li>
</ul>
<h5 id="13-重用大开销对象"><a href="#13-重用大开销对象" class="headerlink" title="13. 重用大开销对象"></a>13. 重用大开销对象</h5><ul>
<li><p>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。<br>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p>
</li>
<li><p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。<br>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// in your .h or inside a class extension</div><div class="line">@property (nonatomic, strong) NSDateFormatter *formatter;</div><div class="line"></div><div class="line">// inside the implementation (.m)</div><div class="line">// When you need, just use self.formatter</div><div class="line">- (NSDateFormatter *)formatter &#123;</div><div class="line">    if(! _formatter) &#123;</div><div class="line">        _formatter = [[NSDateFormatter alloc] init];</div><div class="line">        _formatter.dateFormat = @&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;;// twitter date format</div><div class="line">    &#125;</div><div class="line">    return_formatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</li>
</ul>
<h5 id="14-使用Sprite-Sheets"><a href="#14-使用Sprite-Sheets" class="headerlink" title="14. 使用Sprite Sheets"></a>14. 使用Sprite Sheets</h5><ul>
<li>你是一个游戏开发者吗，那么Sprite sheets一定是一个你的最好的朋友了。Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。<br>我们有两个很好的关于Sprite的教程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How To Use Animations and Sprite Sheets in Cocos2D</div><div class="line">How to Create and Optimize Sprite Sheets in Cocos2D with Texture Packer and Pixel Formats</div></pre></td></tr></table></figure>
<ul>
<li>第二个教程涵盖了可能在很大程度上影响你游戏性能的pixel格式的细节。<br>如果你对于spirte sheet还不是很熟悉，可以看下这两个(youtube)视频SpriteSheets – The Movie, Part 1 和Part 2。视频的作者是创建Sprite sheet很流行的工具之一Texture Packer的作者Andreas Löw。<br>除了使用Sprite sheets，其它写在这里的建议当然也可以用于游戏开发中。比如你需要很多的Sprite sheets，像敌人，导弹之类的动作类必备元素，你可以重用这些sprites而不用每次都要重新创建。</li>
</ul>
<h5 id="15-避免反复处理数据"><a href="#15-避免反复处理数据" class="headerlink" title="15. 避免反复处理数据"></a>15. 避免反复处理数据</h5><ul>
<li>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。<br>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</li>
<li>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</li>
</ul>
<h5 id="16-选择正确的数据格式"><a href="#16-选择正确的数据格式" class="headerlink" title="16. 选择正确的数据格式"></a>16. 选择正确的数据格式</h5><p>从app和网络服务间传输数据有很多方案，最常见的就是JSON和XML。你需要选择对你的app来说最合适的一个。</p>
<ul>
<li>解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。</li>
<li>但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</li>
</ul>
<h5 id="17-正确设定背景图片"><a href="#17-正确设定背景图片" class="headerlink" title="17. 正确设定背景图片"></a>17. 正确设定背景图片</h5><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p>
<pre><code>使用UIColor的 colorWithPatternImage来设置背景色；
在view中添加一个UIImageView作为一个子View。
</code></pre><p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>
<pre><code>// You could also achieve the same result in Interface Builder
UIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;background&quot;]];
[self.view addSubview:backgroundView];
</code></pre><p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>
<pre><code>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;background&quot;]];
</code></pre><h5 id="18-减少使用Web特性"><a href="#18-减少使用Web特性" class="headerlink" title="18. 减少使用Web特性"></a>18. 减少使用Web特性</h5><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。<br>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。</p>
<p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。</p>
<p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。<br>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>
<p>更多相关信息可以看下 WWDC 2012 session #601 – Optimizing Web Content in UIWebViews and Websites on iOS</p>
<h5 id="19-设定Shadow-Path"><a href="#19-设定Shadow-Path" class="headerlink" title="19. 设定Shadow Path"></a>19. 设定Shadow Path</h5><p>如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">// Somewhere later ...</div><div class="line">UIView *view = [[UIView alloc] init];</div><div class="line"></div><div class="line">// Setup the shadow ...</div><div class="line">view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);</div><div class="line">view.layer.shadowRadius = 5.0f;</div><div class="line">view.layer.shadowOpacity = 0.6;</div></pre></td></tr></table></figure>
<p>看起来很简单，对吧。<br>可是，坏消息是使用这个方法也有它的问题… Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。<br>使用shadowPath的话就避免了这个问题：</p>
<pre><code>view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];
</code></pre><p>使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.<br>想了解更多可以看看Mark Pospesel的这篇。</p>
<h5 id="20-优化Table-View"><a href="#20-优化Table-View" class="headerlink" title="20. 优化Table View"></a>20. 优化Table View</h5><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。<br>为了保证table view平滑滚动，确保你采取了以下的措施:</p>
<pre><code>正确使用reuseIdentifier来重用cells
尽量使所有的view opaque，包括cell自身
避免渐变，图片缩放，后台选人
缓存行高
如果cell内现实的内容来自web，使用异步加载，缓存请求结果
使用shadowPath来画阴影
减少subviews的数量
尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果
使用正确的数据结构来存储数据
尽量使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate
</code></pre><h5 id="21-选择正确的数据存储选项"><a href="#21-选择正确的数据存储选项" class="headerlink" title="21. 选择正确的数据存储选项"></a>21. 选择正确的数据存储选项</h5><p>当做本地数据存储时你会怎么做？<br>你有很多选择，比如：</p>
<pre><code>使用NSUerDefaults
使用XML, JSON, 或者 plist
使用NSCoding存档
使用类似SQLite的本地SQL数据库
使用 Core Data
</code></pre><ul>
<li><p>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>
</li>
<li><p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>
</li>
<li><p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>
</li>
<li><p>当存储大块数据时,以上的方法都不适用. 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。<br>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>
</li>
</ul>
<h5 id="22-加速启动时间"><a href="#22-加速启动时间" class="headerlink" title="22. 加速启动时间"></a>22. 加速启动时间</h5><p>快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。</p>
<ul>
<li>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</li>
<li>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！<ul>
<li>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</li>
</ul>
</li>
</ul>
<h5 id="23-使用Autorelease-Pool"><a href="#23-使用Autorelease-Pool" class="headerlink" title="23. 使用Autorelease Pool"></a>23. 使用Autorelease Pool</h5><ul>
<li>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</li>
<li>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。<br>好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</div><div class="line">    for(NSURL *url in urls) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">      NSError *error;</div><div class="line">      NSString *fileContents = [NSString stringWithContentsOfURL:url</div><div class="line">                                             encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">            /* Process the string, creating and autoreleasing more objects. */</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码在每次遍历后释放所有autorelease对象</p>
<h5 id="24-选择是否缓存图片"><a href="#24-选择是否缓存图片" class="headerlink" title="24. 选择是否缓存图片"></a>24. 选择是否缓存图片</h5><p>常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。</p>
<p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p>
<p>imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:<br>这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。<br>相反的，imageWithContentsOfFile仅加载图片。<br>下面的代码说明了这两种方法的用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;];// caching</div><div class="line">// or</div><div class="line">UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;];// no caching</div></pre></td></tr></table></figure>
<p>那么我们应该如何选择呢？<br>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。<br>然而，在图片反复重用的情况下imageNamed是一个好得多的选择。</p>
<h5 id="25-避免日期格式转换"><a href="#25-避免日期格式转换" class="headerlink" title="25. 避免日期格式转换"></a>25. 避免日期格式转换</h5><p>如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。<br>然而，如果你需要更多速度，那么直接用C是一个好的方案。Sam Soffes有一个不错的帖子<a href="http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="external">(点进进入)</a>里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。<br>嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！<br>如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   - (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp &#123;</div><div class="line">return[NSDate dateWithTimeIntervalSince1970:timestamp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样会比用C来解析日期字符串还快！<br>需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;http://www.jianshu.com/p/9c450e512020&quot; target=&quot;_bla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>runtime之获得一个类的成员变量</title>
    <link href="http://yoursite.com/2016/11/12/runtime%E4%B9%8B%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2016/11/12/runtime之获得一个类的成员变量/</id>
    <published>2016-11-12T10:49:29.000Z</published>
    <updated>2016-11-12T11:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何获得一个类的成员变量"><a href="#如何获得一个类的成员变量" class="headerlink" title="如何获得一个类的成员变量?"></a>如何获得一个类的成员变量?</h4><p>对于runtime这个Objective-C的黑魔法,其实我在理论中并没有理解得很到位,但是在开发中慢慢变更的需求,我们开始就会按照网上的模板来写代码,写得多了,其实就会有”到位”的感觉.</p>
<p>使用runtime获得成员变量最常用的地方就是在一个对象归档和解档的时候使用了,因为如果每次都要手动写比较累,而且也容易写错,那不如我们直接用这项黑魔法来减轻我们的工作量–</p>
<p>&gt;<br>//必须要导入的头文件</p>
<objc runtime.h="">

<ol>
<li>获得某个类的所有成员变量（outCount 会返回成员变量的总数）<br><code>Ivar *class_copyIvarList(Class cls , unsigned int *outCount)</code><br>第一个参数是:类的类型<br>第二个参数是:unsigned int *outCount放一个接收值的地址，用来存放属性的个数</li>
<li>获得成员变量的名字<br><code>const char *ivar_getName(Ivar v)</code></li>
<li>获得成员变量的类型<br><code>const char *ivar_getTypeEndcoding(Ivar v)</code></li>
</ol>
<h4 id="举一个普通的例子"><a href="#举一个普通的例子" class="headerlink" title="举一个普通的例子"></a>举一个普通的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unsigned int outCount = 0;</div><div class="line">Ivar *ivars = class_copyIvarList([Person class], &amp;outCount);</div><div class="line"></div><div class="line">// 遍历所有成员变量</div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">    // 取出i位置对应的成员变量</div><div class="line">    Ivar ivar = ivars[i];</div><div class="line">    const char *name = ivar_getName(ivar);</div><div class="line">    const char *type = ivar_getTypeEncoding(ivar);</div><div class="line">    NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);</div><div class="line">&#125;</div><div class="line">// 注意释放内存！</div><div class="line">free(ivars);</div></pre></td></tr></table></figure>
<h4 id="利用runtime-获取所有属性来重写归档解档方法"><a href="#利用runtime-获取所有属性来重写归档解档方法" class="headerlink" title="利用runtime 获取所有属性来重写归档解档方法"></a>利用runtime 获取所有属性来重写归档解档方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 设置不需要归解档的属性</div><div class="line">- (NSArray *)ignoredNames &#123;</div><div class="line">    return @[@&quot;_aaa&quot;,@&quot;_bbb&quot;,@&quot;_ccc&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解档方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line">        // 获取所有成员变量</div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            // 将每个成员变量名转换为NSString对象类型</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 忽略不需要解档的属性</div><div class="line">            if ([[self ignoredNames] containsObject:key]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 根据变量名解档取值，无论是什么类型</div><div class="line">            id value = [aDecoder decodeObjectForKey:key];</div><div class="line">            // 取出的值再设置给属性</div><div class="line">            [self setValue:value forKey:key];</div><div class="line">            // 这两步就相当于以前的 self.age = [aDecoder decodeObjectForKey:@&quot;_age&quot;];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 归档调用方法</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">     // 获取所有成员变量</div><div class="line">    unsigned int outCount = 0;</div><div class="line">    Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">    for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        // 将每个成员变量名转换为NSString对象类型</div><div class="line">        NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">        // 忽略不需要归档的属性</div><div class="line">        if ([[self ignoredNames] containsObject:key]) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 通过成员变量名，取出成员变量的值</div><div class="line">        id value = [self valueForKeyPath:key];</div><div class="line">        // 再将值归档</div><div class="line">        [aCoder encodeObject:value forKey:key];</div><div class="line">        // 这两步就相当于 [aCoder encodeObject:@(self.age) forKey:@&quot;_age&quot;];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>依据上面的原理我们就可以给NSObject做一个分类，让我们不需要每次都写这么一长串代码，只要实现一小段代码就可以让一个对象具有归解档的能力。</p>
<p><strong>注意，下面的代码我换了一个方法名（不然会覆盖系统原来的方法！），加了一个忽略属性方法是否被实现的判断，并加上了对父类属性的归解档循环。</strong></p>
<p><code>NSObject+Extension.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSObject (Extension)</div><div class="line"></div><div class="line">- (NSArray *)ignoredNames;</div><div class="line">- (void)encode:(NSCoder *)aCoder;</div><div class="line">- (void)decode:(NSCoder *)aDecoder;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>NSObject+Extension.m</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSObject+Extension.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (Extension)</div><div class="line"></div><div class="line">- (void)decode:(NSCoder *)aDecoder &#123;</div><div class="line">    // 一层层父类往上查找，对父类的属性执行归解档方法</div><div class="line">    Class c = self.class;</div><div class="line">    while (c &amp;&amp;c != [NSObject class]) &#123;</div><div class="line"></div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList(c, &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 如果有实现该方法再去调用</div><div class="line">            if ([self respondsToSelector:@selector(ignoredNames)]) &#123;</div><div class="line">                if ([[self ignoredNames] containsObject:key]) continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            id value = [aDecoder decodeObjectForKey:key];</div><div class="line">            [self setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">        c = [c superclass];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encode:(NSCoder *)aCoder &#123;</div><div class="line">    // 一层层父类往上查找，对父类的属性执行归解档方法</div><div class="line">    Class c = self.class;</div><div class="line">    while (c &amp;&amp;c != [NSObject class]) &#123;</div><div class="line"></div><div class="line">        unsigned int outCount = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">            // 如果有实现该方法再去调用</div><div class="line">            if ([self respondsToSelector:@selector(ignoredNames)]) &#123;</div><div class="line">                if ([[self ignoredNames] containsObject:key]) continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            id value = [self valueForKeyPath:key];</div><div class="line">            [aCoder encodeObject:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">        c = [c superclass];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面分类使用方法：在需要归解档的对象中实现下面方法即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 设置需要忽略的属性</div><div class="line">- (NSArray *)ignoredNames &#123;</div><div class="line">    return @[@&quot;bone&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在系统方法内来调用我们的方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        [self decode:aDecoder];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">    [self encode:aCoder];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看来，我们每次又要写同样的代码，我们可以将归解档两个方法封装为宏，在需要的地方一句宏搞定，如果有不需要归解档的属性就实现ignoredNames 方法，具体可以看我的demo，这个也是MJExtension中那个一句宏就可以解决归解档的实现原理。</p>
</objc>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;如何获得一个类的成员变量&quot;&gt;&lt;a href=&quot;#如何获得一个类的成员变量&quot; class=&quot;headerlink&quot; title=&quot;如何获得一个类的成员变量?&quot;&gt;&lt;/a&gt;如何获得一个类的成员变量?&lt;/h4&gt;&lt;p&gt;对于runtime这个Objective-C的黑魔法,其
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>52个建议中的&#39;class-continuation分类&#39;</title>
    <link href="http://yoursite.com/2016/11/09/52%E4%B8%AA%E5%BB%BA%E8%AE%AE%E4%B8%AD%E7%9A%84-class-continuation%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/11/09/52个建议中的-class-continuation分类/</id>
    <published>2016-11-09T13:24:01.000Z</published>
    <updated>2016-11-09T14:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧"><a href="#一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧" class="headerlink" title="一开始看书的时候是有点懵逼的,但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白,个人认为核心的要点就是在实现文件类再一次做分类,类似于一个内部类一样吧.先上一下代码吧."></a>一开始看书的时候是有点懵逼的,但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白,个人认为核心的要点就是在实现文件类再一次做分类,类似于一个内部类一样吧.先上一下代码吧.</h4><h3 id="Pseron-h"><a href="#Pseron-h" class="headerlink" title="Pseron.h"></a>Pseron.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic ,copy,readonly ) NSString* name;</div><div class="line">@property (nonatomic , assign,readonly ) NSUInteger age;</div><div class="line">-(instancetype)initWithName:(NSString*)name WithAge:(NSUInteger)age;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后在接口.h文件,属性使用了readonly关键字,使得外部只能获取,不能修改这个属性,因为每个人的年龄和姓名不是说修改就修改的,考虑到这个逻辑的话,最好就是在接口文件里面修改成只读类型.</p>
<h3 id="Person-m"><a href="#Person-m" class="headerlink" title="Person.m"></a>Person.m</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@interface Person()</div><div class="line">@property (nonatomic ,copy ,readwrite) NSString* name;</div><div class="line">@property (nonatomic ,assign,readwrite ) NSUInteger age;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">-(instancetype)initWithName:(NSString *)name WithAge:(NSUInteger)age&#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _name = name;</div><div class="line">        _age = age;</div><div class="line">    &#125;</div><div class="line">    return  self;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface Person (Student)</div><div class="line">//在分类中添加的属性,必须由我们自己来配置get和set属性~</div><div class="line">@property (nonatomic ,copy ) NSString * firstName;</div><div class="line">@end</div><div class="line">@implementation Person(Student)</div><div class="line">static char * PersonFirstName = &quot;PersonFirstName&quot;;</div><div class="line"></div><div class="line">-(void)setFirstName:(NSString *)firstName&#123;</div><div class="line">//此处使用runtime来添加这个属性,因为在分类里面是无法直接添加属性的,只有通过运行时才能添加熟悉,该方法是设置属性的方法,其中`static char * PersonFirstName = &quot;PersonFirstName&quot;;`这个是一个定义常量,必须是C语言字符串</div><div class="line">    objc_setAssociatedObject(self, PersonFirstName, firstName, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSString *)firstName&#123;</div><div class="line">    //该方法是货到属性的方法</div><div class="line">    return objc_getAssociatedObject(self, PersonFirstName);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="Runtime的使用就不再这里多说明了-主要表达的是"><a href="#Runtime的使用就不再这里多说明了-主要表达的是" class="headerlink" title="Runtime的使用就不再这里多说明了,主要表达的是:"></a>Runtime的使用就不再这里多说明了,主要表达的是:</h4><ol>
<li>我们可以在实现文件里面再写多一个类的分类,加深了这种类文件和方法加密的方式,更好的隐蔽了我们的类</li>
<li>同时,个人还觉得如果有一些类只使用一次,我们也可以直接封装在某个.m文件下面做一个匿名的类使用.</li>
<li>或者如同52个建议里面所说的,可以在分类中添加实例变量,如果想类所遵循的协议隐藏,也可以使用class-continuation分类</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本上描述得让我没有明白-个人认为核心的要点就是在实现文件类再一次做分类-类似于一个内部类一样吧-先上一下代码吧&quot;&gt;&lt;a href=&quot;#一开始看书的时候是有点懵逼的-但是后来慢慢的理解后才觉得其实是书本
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tableView代理的分离</title>
    <link href="http://yoursite.com/2016/11/07/tableView%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2016/11/07/tableView代理的分离/</id>
    <published>2016-11-07T02:30:43.000Z</published>
    <updated>2016-11-07T08:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-通用性较强-这个类中只添加了cell选中状态的闭包操作-其他可以按需求添加"><a href="#有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-通用性较强-这个类中只添加了cell选中状态的闭包操作-其他可以按需求添加" class="headerlink" title="有没有小伙伴觉得整天重复写tableView的代理很繁琐,在看了iOS中协议的一些内容以后,简单的对tableView的代理作了简单的抽离,方便使用者减少重复代码,其中定义了cellStyleBlock,该闭包的返回值是cell,所以可以在外部操作cell的样式,通用性较强,这个类中只添加了cell选中状态的闭包操作,其他可以按需求添加."></a>有没有小伙伴觉得整天重复写tableView的代理很繁琐,在看了iOS中协议的一些内容以后,简单的对tableView的代理作了简单的抽离,方便使用者减少重复代码,其中定义了cellStyleBlock,该闭包的返回值是cell,所以可以在外部操作cell的样式,通用性较强,这个类中只添加了cell选中状态的闭包操作,其他可以按需求添加.</h5><h3 id="TableViewDelegateObj-h"><a href="#TableViewDelegateObj-h" class="headerlink" title="TableViewDelegateObj.h"></a>TableViewDelegateObj.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@class TableViewDelegateObj;</div><div class="line"></div><div class="line"></div><div class="line">//cell中各个方法通过闭包回调处理</div><div class="line">typedef void(^cellFunctionBlock) (UITableView* tableView,NSIndexPath *indexPath);</div><div class="line">//闭包返回cell的样式</div><div class="line">typedef UITableViewCell* (^cellStyleBlock)(UITableView* tableView,NSIndexPath *indexPath);</div><div class="line"></div><div class="line">@interface TableViewDelegateObj : NSObject&lt;UITableViewDelegate,UITableViewDataSource&gt;</div><div class="line"></div><div class="line"></div><div class="line">//创建cell的样式</div><div class="line">+(instancetype)creatTableViewDelagateWithDataList:(NSArray *)dataList</div><div class="line">                                        cellStyle:(cellStyleBlock) cellStyle;</div><div class="line">/**</div><div class="line"> *  选中cell时回调闭包</div><div class="line"> */</div><div class="line">-(instancetype)selectBlock:(cellFunctionBlock)Block;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="TableViewDelegateObj-m"><a href="#TableViewDelegateObj-m" class="headerlink" title="TableViewDelegateObj.m"></a>TableViewDelegateObj.m</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#import &quot;TableViewDelegateObj.h&quot;</div><div class="line">@interface TableViewDelegateObj()</div><div class="line">@property (nonatomic , strong ) NSArray *dataList;</div><div class="line">@property (nonatomic ,copy ) cellFunctionBlock selectBlock;</div><div class="line">@property (nonatomic ,copy ) cellStyleBlock cellBlock;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation TableViewDelegateObj</div><div class="line"></div><div class="line">+(instancetype)creatTableViewDelagateWithDataList:(NSArray *)dataList cellStyle:(cellStyleBlock)cellStyleBlock&#123;</div><div class="line">    </div><div class="line">    return  [[[self class] alloc] initTabelViewDelegateWithDataList:dataList cellStyle:cellStyleBlock ];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">-(instancetype)initTabelViewDelegateWithDataList:(NSArray*)dataList cellStyle:(cellStyleBlock)cellStyleBlock&#123;</div><div class="line">    </div><div class="line">    self =  [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        self.dataList = dataList;</div><div class="line">        </div><div class="line">        self.cellBlock = cellStyleBlock;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    </div><div class="line">    return self.dataList.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;    </div><div class="line">    </div><div class="line">    return self.cellBlock(tableView,indexPath);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//选中</div><div class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:NO];</div><div class="line">    self.selectBlock(tableView,indexPath);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-(instancetype)selectBlock:(cellFunctionBlock)Block&#123;</div><div class="line">    </div><div class="line">    self.selectBlock = Block;</div><div class="line">    return self;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;TableViewDelegateObj.h&quot;</div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic , strong ) UITableView *tableView;</div><div class="line">@property (nonatomic , strong ) TableViewDelegateObj*tabelViewDealage;</div><div class="line">@property (nonatomic , strong ) NSMutableArray&lt;NSString*&gt; *dataList;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.dataList =  [NSMutableArray array];</div><div class="line">    for (NSInteger i = 0; i &lt;= 10; i++) &#123;</div><div class="line">        NSString* str =  [NSString stringWithFormat:@&quot;我的第%ld行cell&quot;,i];</div><div class="line">        [self.dataList addObject:str];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tableView =  [[UITableView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) style:UITableViewStylePlain];</div><div class="line">    [self.view addSubview:self.tableView];</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tabelViewDealage =  [[TableViewDelegateObj creatTableViewDelagateWithDataList:self.dataList cellStyle:^UITableViewCell *(UITableView *tableView, NSIndexPath *indexPath) &#123;</div><div class="line">        //返回cell的样式</div><div class="line">        static NSString* identifier = @&quot;cell&quot;;</div><div class="line">        </div><div class="line">        UITableViewCell* cell =  [tableView dequeueReusableCellWithIdentifier:identifier];</div><div class="line">        if (!cell) &#123;</div><div class="line">            cell =  [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];</div><div class="line">            cell.textLabel.text = self.dataList[indexPath.row];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return cell;</div><div class="line"></div><div class="line">    &#125;] selectBlock:^(UITableView *tableView, NSIndexPath *indexPath) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    </div><div class="line">    self.tableView.delegate = self.tabelViewDealage;</div><div class="line">    self.tableView.dataSource = self.tabelViewDealage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;有没有小伙伴觉得整天重复写tableView的代理很繁琐-在看了iOS中协议的一些内容以后-简单的对tableView的代理作了简单的抽离-方便使用者减少重复代码-其中定义了cellStyleBlock-该闭包的返回值是cell-所以可以在外部操作cell的样式-
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何在项目已初始化成功以后建立git仓库</title>
    <link href="http://yoursite.com/2016/10/31/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%8A%9F%E4%BB%A5%E5%90%8E%E5%BB%BA%E7%AB%8Bgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2016/10/31/如何在项目已初始化成功以后建立git仓库/</id>
    <published>2016-10-31T11:01:37.000Z</published>
    <updated>2016-10-31T11:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:<code>git@github.com:vshiron/html-css-js-dome.git</code></li>
<li>然后你就需要在本地创建一个文件,把你需要的东西先考进去吧,然后打开终端,cd进入你的目录:<code>cd /Users/vshiron/Desktop/html学习/jsdome</code></li>
<li>在该目录下使用git的初始化命令:<code>git init</code></li>
<li>以后的每一次增加目录里面的内容,都必须要用该命令来添加到本地仓库,用”.”是代表通配符,命令如下:<code>git add .</code>,成功后不会显示任何东西</li>
<li>然后就是提交代码的信息,修改了什么就顺便写上去,第一次初始化就可以写first啦:<code>git commit -m &quot;first commit&quot;</code><br>大概会显示下面内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[master (root-commit) 6ddc496] first commit</div><div class="line">2 files changed, 229 insertions(+)</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/.project&quot;</div><div class="line">create mode 100644 &quot;\350\256\241\347\256\227\345\231\250/index.html&quot;</div></pre></td></tr></table></figure>
<ol>
<li><p>完事了以后,就要添加一个远程本地的仓库:<code>git remote add origin git@github.com:vshiron/html-css-js-dome.git</code>,完事后没有任何代码显示</p>
</li>
<li><p>接下来再输入另外一个代码,就是我们希望把代码推送到服务器上的命令:<code>git push origin master</code><br>这个时候会显示如下信息,他大概的意思是告诉你,推送代码时要养成拉代码合并的习惯~</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line"> ! [rejected]        master -&gt; master (fetch first)</div><div class="line">error: failed to push some refs to &apos;git@github.com:vshiron/html-css-js-dome.git&apos;</div><div class="line">hint: Updates were rejected because the remote contains work that you do</div><div class="line">hint: not have locally. This is usually caused by another repository pushing</div><div class="line">hint: to the same ref. You may want to first integrate the remote changes</div><div class="line">hint: (e.g., &apos;**git pull ...&apos;**) before pushing again.</div><div class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</div></pre></td></tr></table></figure>
<ol>
<li>那么,我们就先拉一下代码吧,运行命令:<code>git pull origin master</code>,拉完代码以后会显示下面信息:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">From github.com:vshiron/html-css-js-dome</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Merge made by the &apos;recursive&apos; strategy.</div><div class="line"> README.md | 2 ++</div><div class="line"> 1 file changed, 2 insertions(+)</div><div class="line"> create mode 100644 README.md</div></pre></td></tr></table></figure>
<ol>
<li>操作完成上面那一步的话,我们可以继续使用该命令:<code>git push origin master</code>,这个时候可能会让你输入相应的账号和密码,输入就是了~<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pushing to git@github.com:vshiron/html-css-js-dome.git</div><div class="line">To git@github.com:vshiron/html-css-js-dome.git</div><div class="line">   73c75b2..1907e5f  master -&gt; master</div><div class="line">updating local tracking ref &apos;refs/remotes/origin/master&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时候就已经完成项目的推送了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首页要在github上创建好仓库,并且把git地址给拷贝一些,我就拿我的要上传的项目做例子吧,ssh的地址是:&lt;code&gt;git@github.com:vshiron/html-css-js-dome.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后你就需要在本地创
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Controller间的自定义过渡效果</title>
    <link href="http://yoursite.com/2016/10/17/Controller%E9%97%B4%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2016/10/17/Controller间的自定义过渡效果/</id>
    <published>2016-10-17T10:58:48.000Z</published>
    <updated>2016-10-27T13:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处<a href="http://liuyanwei.jumppo.com/index.html" target="_blank" rel="external">阅读原文</a>)</strong></p>
<blockquote>
<p>本篇文章主要讲的就是在学习了UIView的基础上,如何在学习UIViewController的自定义效果</p>
</blockquote>
<p>效果图如下:</p>
<ul>
<li>点击模态controller，会弹出一个新的绿色UIViewController，手指下滑可以dismiss这个controller</li>
<li>四个角的按钮可以自定义圆形切换的过渡效果切换的一个红色的UIViewController，点击返回用同样的方式切换回来</li>
</ul>
<p><a href="http://liuyanwei.jumppo.com/assets/uploads/ControllerTransitioning1.gif" target="_blank" rel="external"></a></p>
<h4 id="出场人物介绍"><a href="#出场人物介绍" class="headerlink" title="出场人物介绍"></a>出场人物介绍</h4><blockquote>
<p>介绍一下Controller过渡和交互用到的类</p>
</blockquote>
<h5 id="presention-and-presented"><a href="#presention-and-presented" class="headerlink" title="presention and presented"></a><code>presention and presented</code></h5><pre><code>A中模态显示B,那么A就是presention，b就是presented，后续内容会使用这种叫法称呼Modal下的2个controller
</code></pre><h5 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a><code>UIViewControllerTransitioningDelegate</code></h5><pre><code>Controller modal过渡的presented和dismiss的动画交互协议，你需要实现协议，它会询问你：
</code></pre><ul>
<li>当PresentedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当DismissedController时，你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>当PresentedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>当DismissedController时，你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
</ul>
<h5 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a><code>UIViewControllerAnimatedTransitioning</code></h5><p>过渡动画效果的具体实现的接口，需要实现它的3个方法，即可完成一个controller过渡动画效果</p>
<ul>
<li><code>func animationEnded</code>：过渡动画完成后要执行的代码可以写到这个方法中</li>
<li><code>func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval</code>：给定一个过渡动画的执行时间</li>
<li><code>func animateTransition(transitionContext: UIViewControllerContextTransitioning)</code> ：具体过渡动画都在这个方法里面实现，在这个方法中可以通过transitionContext拿到一切你需要的对象，后面会有讲到</li>
</ul>
<h5 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a><code>UINavigationControllerDelegate</code></h5><pre><code>Controller 非模态状态下的的过渡动画，就不能使用之前说的那个UIViewControllerTransitioningDelegate委托解决了，就需要用UINavigationControllerDelegate，接口方法比较类似，但也不完全一样
</code></pre><ul>
<li>你要使用怎样的动画类（UIViewControllerAnimatedTransitioning）展示过渡效果？</li>
<li>你要使用怎样的过渡交互类（UIViewControllerInteractiveTransitioning）处理过渡交互？</li>
<li>willShowViewController，didShowViewController ： 生命周期事件</li>
<li>navigationControllerSupportedInterfaceOrientations: 屏幕支持的方向</li>
</ul>
<h5 id="UIViewControllerInteractiveTransitioning"><a href="#UIViewControllerInteractiveTransitioning" class="headerlink" title="UIViewControllerInteractiveTransitioning"></a><code>UIViewControllerInteractiveTransitioning</code></h5><pre><code>这个类用于实现在转场过路效果中的交互，比如在demo中，用它实现了一个手指下滑解除modal状态的效果
</code></pre><h5 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a><code>UIViewControllerContextTransitioning</code></h5><p>UIViewControllerAnimatedTransitioning协议的关键方法<code>animateTransition(transitionContext: UIViewControllerContextTransitioning)</code>里面可以得到，使用transitionContext可以获取一些重要的上下文信息，比如前后的controller，转换时的容器等，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //拿到过渡动画执行时间</div><div class="line">        transitionDuration(transitionContext)</div></pre></td></tr></table></figure>
<h4 id="Controller-modal过渡效果"><a href="#Controller-modal过渡效果" class="headerlink" title="Controller modal过渡效果"></a>Controller modal过渡效果</h4><p>我们先来实现一个简单的示例，点击一个按钮，出现一个modal controller，自定义从下往上弹出并且有些回弹效果的过渡动画。从这个例子中我们可以了解</p>
<ul>
<li>如何实现UIViewControllerTransitioningDelegate</li>
<li>如何实现UIViewControllerAnimatedTransitioning</li>
<li>如何组合在一起完成功能</li>
</ul>
<p>示例效果见demo点击后，弹出的绿色界</p>
<h5 id="步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己"><a href="#步骤1：界面画出按钮，点击之后用-modal-显示-To2ViewController，并设置transitioningDelegate指向自己" class="headerlink" title="步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己"></a><code>步骤1：界面画出按钮，点击之后用 modal 显示 To2ViewController，并设置transitioningDelegate指向自己</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//模态视图切换效果</div><div class="line">   @IBAction func Transitioning2(sender: AnyObject) &#123;</div><div class="line">       let toVC = To2ViewController()</div><div class="line">       //设置transitioning委托为自己</div><div class="line">       toVC.transitioningDelegate = self</div><div class="line">       navigationController?.presentViewController(toVC, animated: true, completion: nil)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="步骤2：controller-实现-UIViewControllerTransitioningDelegate"><a href="#步骤2：controller-实现-UIViewControllerTransitioningDelegate" class="headerlink" title="步骤2：controller 实现 UIViewControllerTransitioningDelegate"></a>步骤2：<code>controller 实现 UIViewControllerTransitioningDelegate</code></h5><p>demo中使用了extension的方式继承UIViewControllerTransitioningDelegate，好处是代码逻辑分离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//模态视图切换效果</div><div class="line">extension ControllerTransitioningDemoViewController:UIViewControllerTransitioningDelegate&#123;</div><div class="line"></div><div class="line">    //返回Presented使用的UIViewControllerAnimatedTransitioning类</div><div class="line">    </div><div class="line">    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line">        return PresentedAnimation() // PresentedAnimation 是自定义的过渡动画效果的实现类，继承自UIViewControllerAnimatedTransitioning 步骤3中介绍它</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"><a href="#步骤3-实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类" class="headerlink" title="步骤3: 实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类"></a>步骤3: <code>实现一个过渡效果为自下而上弹出并有些晃动的UIViewControllerAnimatedTransitioning类</code></h5><p>就如之前对UIViewControllerAnimatedTransitioning介绍的那样，需要继承自UIViewControllerAnimatedTransitioning，然后实现它的三个委托方法，具体实现请看代码注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">public class PresentedAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        //转场过渡动画的执行时间</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</div><div class="line">    //在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</div><div class="line">    public func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        //拿到前后的两个controller</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        //弹出的控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        //拿到Presenting的最终Frame</div><div class="line">        let finalFrameForVC = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        //拿到转换的容器view</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //获取屏幕宽高</div><div class="line">        let bounds = UIScreen.mainScreen().bounds</div><div class="line">        //设置弹出控制器的初始位置</div><div class="line">        toVC.view.frame = CGRectOffset(finalFrameForVC, 0, bounds.size.height)</div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //自下而上弹出toVC的动画</div><div class="line">        UIView.animateWithDuration(transitionDuration(transitionContext),</div><div class="line">                                    delay: 0.0,</div><div class="line">                                    usingSpringWithDamping: 0.7,</div><div class="line">                                    initialSpringVelocity: 0.0,</div><div class="line">                                    options: .CurveLinear,</div><div class="line">                                    animations: &#123;</div><div class="line">                                    //执行的动画</div><div class="line">                                    //原来的控制给透明度</div><div class="line">                                    fromVC.view.alpha = 0.5</div><div class="line">                                    //修改弹出控制的frame</div><div class="line">                                    toVC.view.frame = finalFrameForVC</div><div class="line">                                    &#125;, completion: &#123;</div><div class="line">                                        finished in</div><div class="line">                                        	//动画完成后执行</div><div class="line">                                        	transitionContext.completeTransition(true)</div><div class="line">                                        	</div><div class="line">                                        fromVC.view.alpha = 1.0</div><div class="line">                                    &#125;)</div><div class="line">         NSLog(&quot;animateTransition&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   &lt;!-- UIView.animateWithDuration(1.0, animations: &#123; </div><div class="line">            </div><div class="line">            toVC.view.frame = finalFrameForVC;</div><div class="line">            fromVC.view.alpha = 0.5</div><div class="line">            </div><div class="line">            &#125;) &#123; (isCompletion) in</div><div class="line">                transitionContext.completeTransition(true)</div><div class="line">                fromVC.view.alpha = 1.0</div><div class="line">        &#125;--&gt;</div><div class="line"></div><div class="line"></div><div class="line">    //执行完成后的回调</div><div class="line">    public func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">            NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>madal的转场动画分为2类，present和dismiss，刚才我们实现的是animationControllerForPresentedController，这是present类，下节我们实现dissmiss的转场过渡效果</p>
<h4 id="Controller-dismiss过渡效果"><a href="#Controller-dismiss过渡效果" class="headerlink" title="Controller dismiss过渡效果"></a><code>Controller dismiss过渡效果</code></h4><p>present的过渡效果实现和modal过渡效果类似，也是设置委托、实现委托、实现动画，就不详细说明了，大家可以参考demo。这里我们只说说和present过渡的区别</p>
<h5 id="区别1-委托入口不同"><a href="#区别1-委托入口不同" class="headerlink" title="区别1 委托入口不同"></a><code>区别1 委托入口不同</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//Presented使用的委托</div><div class="line">   func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //Dismiss使用的委托</div><div class="line">   func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</div><div class="line">       //返回一个UIViewControllerAnimatedTransitioning类型</div><div class="line">       return DismissAnimation()</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"><a href="#区别2-动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。" class="headerlink" title="区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。"></a>区别2 动画效果区别（这点其实不算真正的区别，因为你也可以设置为相同的效果）：demo中present动画是从下而上，而dismiss的动画是自上而下。</h5><p>DismissAnimation的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class DismissAnimation: NSObject,UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</div><div class="line">        return 0.6</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</div><div class="line">        //当前控制器</div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        print(fromVC.dynamicType)//toViewController</div><div class="line">        //后控制器</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">         print(toVC.dynamicType)//UINavigationController</div><div class="line">        </div><div class="line">        //获得大小</div><div class="line">        let screenBounds = UIScreen.mainScreen().bounds</div><div class="line">        </div><div class="line">        //当前控制器初始化大小</div><div class="line">        let initFrame = transitionContext.initialFrameForViewController(fromVC)</div><div class="line">        </div><div class="line">        //控制器最终的位置</div><div class="line">        let finalFrame = CGRectOffset(initFrame, 0, screenBounds.size.height)</div><div class="line">        //获得视图容器</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        //容器中添加后面控制的view</div><div class="line">        containerView?.addSubview(toVC.view)</div><div class="line">        //????</div><div class="line">        containerView?.sendSubviewToBack(toVC.view)</div><div class="line">        //获得切换时间</div><div class="line">        let duration: NSTimeInterval = self.transitionDuration(transitionContext)</div><div class="line">        </div><div class="line">        </div><div class="line">        UIView.animateWithDuration(duration, animations: &#123;</div><div class="line">            </div><div class="line">            fromVC.view.frame = finalFrame</div><div class="line">            </div><div class="line">            &#125;, completion: &#123;</div><div class="line">                (finished: Bool) in</div><div class="line">                </div><div class="line">                //是否完成</div><div class="line">                transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="Controller-push、pop过渡效果"><a href="#Controller-push、pop过渡效果" class="headerlink" title="Controller push、pop过渡效果"></a><code>Controller push、pop过渡效果</code></h4><p>push、pop和present、dismiss的过渡走的是两个完全不同的委托，委托里面的方法有相似之处，比如都可以分为过渡和交互两类。交互的内容后面再说，先说过渡效果的区别。</p>
<ul>
<li><p><strong>实现的委托不同</strong>: push、pop自定义过渡动画，需要实现UINavigationControllerDelegate，而present、dismiss实现的是UIViewControllerTransitioningDelegate</p>
</li>
<li><p><strong>区分类型方式不同</strong>: UIViewControllerTransitioningDelegate通过2个委托present和dismiss区分开来，而在UINavigationControllerDelegate中，对应转场过渡动画只有一个委托，通过委托中的参数operation: UINavigationControllerOperation 区分pop和push</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"><a href="#UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果" class="headerlink" title="UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果"></a>UIViewControllerAnimatedTransitioning动画类的实现，完成点击后圆形区域放大过渡的动画效果</h4><h4 id="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"><a href="#步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托" class="headerlink" title="步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托"></a><code>步骤1添加一个按钮，点击使用push的方式跳转到页面To1ViewController，并设置委托</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//推出视图切换效果</div><div class="line">    @IBAction func Transitioning1(sender: AnyObject) &#123;</div><div class="line">        let toVC = To1ViewController()</div><div class="line">        //设置委托</div><div class="line">        navigationController?.delegate = self</div><div class="line">        //主要是动画实现圆形扩大效果，需要知道一个初始园的位置，所以把uiview传过去。这种方式传递uiview不是一个很好的方式，这里为了demo能尽量的简单，所以这么做了</div><div class="line">        transitioningSender = sender as! UIView</div><div class="line">        navigationController?.pushViewController(toVC, animated: true)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="步骤2实现UINavigationControllerDelegate"><a href="#步骤2实现UINavigationControllerDelegate" class="headerlink" title="步骤2实现UINavigationControllerDelegate"></a><code>步骤2实现UINavigationControllerDelegate</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//push、pop视图切换</div><div class="line">extension ControllerTransitioningDemoViewController:UINavigationControllerDelegate&#123;</div><div class="line">    func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;</div><div class="line"></div><div class="line">        let transitioningAnimation = ExpandAnimation(type:operation)</div><div class="line">        transitioningAnimation.sender = transitioningSender</div><div class="line">        //返回动画的实现类</div><div class="line">        return transitioningAnimation</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"><a href="#步骤3-完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation" class="headerlink" title="步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation"></a><code>步骤3 完成点击后圆形区域放大过渡的动画效果的实现类ExpandAnimation</code></h4><p>这个动画效果我就简单说说实现步骤，其余的大家看看代码。下面的参考文章中，有一篇对这个效果说的比较详细，大家可以去阅读</p>
<p>实现这样一个效果，基本原理是使用遮罩层，罩住presenting，有一个小圆是初始按钮点击的圆形路径，一个大圆是大于presenting的圆形路径。大圆和小圆作为遮罩的路径。判断过渡类型是presention -》 presenting还是presenting -》 presention，分别做不同的处理</p>
<p>presention -》 presenting ： 小圆作为初始遮罩层路径，罩住presenting，使用baseAnimation动画把遮罩层的路径从小圆路径变为大圆路径，presenting即可显示出来，完成过渡效果。 小圆的位置是通过跳转点击按钮决定的，小圆位置不同会影响到大圆结束的位置，所以分了左上、左下、右上、右下四个位置分别处理。这个步骤由于偷懒在presenting -》 presention这个过程里面被省略了，每次都指定了固定的小圆位置</p>
<p>presenting -》 presention ： 使用大圆遮住presenting，使用baseAnimation动画把遮罩层的路径从大圆路径变为小圆路径，presenting慢慢变小到看不见，presention慢慢即可显示出来，完成过渡效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import UIKit</div><div class="line"></div><div class="line">class ExpandAnimation: NSObject, UIViewControllerAnimatedTransitioning &#123;</div><div class="line"></div><div class="line">    //保存上下文</div><div class="line">    var transitionContext:UIViewControllerContextTransitioning!</div><div class="line">    //Pop or push</div><div class="line">    var type:UINavigationControllerOperation!</div><div class="line">    //初始点击的uiview对象，需要他的frame作为初始位置</div><div class="line">    var sender:UIView?</div><div class="line"></div><div class="line">    convenience init(type:UINavigationControllerOperation) &#123;</div><div class="line">        self.init()</div><div class="line">        self.type = type</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval&#123;</div><div class="line">        return 0.5</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line">        self.transitionContext = transitionContext</div><div class="line">        NSLog(&quot;animateTransition&quot;)</div><div class="line">        if(type == .Push)&#123;</div><div class="line">            PushTransition(transitionContext)</div><div class="line">        &#125;else if(type == .Pop)&#123;</div><div class="line">            PopTransition(transitionContext)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func animationEnded(transitionCompleted: Bool)&#123;</div><div class="line">        NSLog(&quot;animation ended&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //弹出效果 在固定位置进行的动画，可以根据需要改成动态位置触发</div><div class="line">    func PopTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line">        containerView!.addSubview(fromVC.view)</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        fromVC.view.layer.mask = mask</div><div class="line"></div><div class="line">        //画出小圆</div><div class="line">        let s_center = CGPoint(x: 50, y: 50)</div><div class="line">        let s_radius:CGFloat =  sqrt(800)</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: s_center.x, y: s_center.y, width: 1, height: 1), -s_radius, -s_radius))</div><div class="line">        //        mask.path = s_maskPath.CGPath</div><div class="line"></div><div class="line">        //画出大圆</div><div class="line">        let l_center = CGPoint(x: 50, y: 50)</div><div class="line">        let l_radius = sqrt( pow(view.bounds.width - l_center.x, 2) + pow(view.bounds.height - l_center.y, 2) ) + 150</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = l_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = s_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //present 动画，根据触发点的位置开始启动动画</div><div class="line">    func PushTransition(transitionContext: UIViewControllerContextTransitioning)&#123;</div><div class="line"></div><div class="line">        let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let finalFrame = transitionContext.finalFrameForViewController(toVC)</div><div class="line">        let containerView = transitionContext.containerView()</div><div class="line">        let view = toVC.view!</div><div class="line"></div><div class="line">        containerView!.addSubview(toVC.view)</div><div class="line"></div><div class="line">        //小圆路径</div><div class="line">        let s_maskPath = UIBezierPath(ovalInRect:(sender?.frame)!)</div><div class="line"></div><div class="line">        //大圆路径</div><div class="line">        let l_center =  (sender?.center)!</div><div class="line"></div><div class="line">        var l_radius:CGFloat</div><div class="line">        if(sender!.frame.origin.x &gt; (toVC.view.bounds.size.width / 2))&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //右上角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //右下角</div><div class="line">                l_radius = sqrt( pow(0 - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            if (sender!.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">                //左上角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(CGRectGetMaxY(view.frame) - l_center.y, 2) )</div><div class="line">            &#125;else&#123;</div><div class="line">                //左下角</div><div class="line">                l_radius = sqrt( pow(CGRectGetMaxX(view.frame) - l_center.x, 2) + pow(0 - l_center.y, 2) )</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        l_radius += 50 //稍微增加一些位置</div><div class="line">        let l_maskPath = UIBezierPath(ovalInRect:CGRectInset(CGRect(x: l_center.x, y: l_center.y, width: 1, height: 1), -l_radius, -l_radius))</div><div class="line"></div><div class="line">        //遮罩层</div><div class="line">        let mask = CAShapeLayer()</div><div class="line">        mask.path = l_maskPath.CGPath</div><div class="line">        view.layer.mask = mask</div><div class="line"></div><div class="line"></div><div class="line">        ////错误用法，animationWithDuration不能通过操作layer产生动画</div><div class="line">        //UIView.animateWithDuration(5) &#123; () -&gt; Void in</div><div class="line">        //     mask.path = b_maskPath.CGPath</div><div class="line">        //&#125;</div><div class="line"></div><div class="line">        let baseAnimation = CABasicAnimation(keyPath: &quot;path&quot;)</div><div class="line">        baseAnimation.duration = transitionDuration(transitionContext)</div><div class="line"></div><div class="line">        baseAnimation.fromValue = s_maskPath.CGPath</div><div class="line">        baseAnimation.toValue = l_maskPath.CGPath</div><div class="line"></div><div class="line">        baseAnimation.delegate = self</div><div class="line">        baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)</div><div class="line">        mask.addAnimation(baseAnimation, forKey: &quot;path&quot;)</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    override func animationDidStop(anim: CAAnimation, finished flag: Bool) &#123;</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.completeTransition(true)</div><div class="line">        //动画完成后去处遮罩</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)?.view.layer.mask = nil</div><div class="line">        self.transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)?.view.layer.mask = nil</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;(注意:本文为参考刘老师博客中的心得再实践一遍的个人学习笔记,并非原创,建议查看老师写的原文,点击此处&lt;a href=&quot;http://liuyanwei.jumppo.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>新建React-Native报错解决办法</title>
    <link href="http://yoursite.com/2016/10/15/%E6%96%B0%E5%BB%BAReact-Native%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/15/新建React-Native报错解决办法/</id>
    <published>2016-10-15T07:59:44.000Z</published>
    <updated>2016-10-17T11:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新建React-Native报错解决办法"><a href="#新建React-Native报错解决办法" class="headerlink" title="新建React-Native报错解决办法"></a>新建React-Native报错解决办法</h3><p>我在新建了一个项目的时候出现了如下错误,找了很多地方都没有正常解决:看上去是在描述没有使用正确的reactNative的框架导致的,但是按它的说明修改了框架也是无法继续正常运行,错误代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[error][tid:com.facebook.react.JavaScript] Seems you&apos;re trying to access &apos;ReactNative.createClass&apos; from the &apos;react-native&apos; package. Perhaps you meant to access &apos;React.createClass&apos; from the &apos;react&apos; package instead?</div><div class="line"></div><div class="line">For example, instead of:</div><div class="line"></div><div class="line">  import React, &#123; Component, View &#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">You should now do:</div><div class="line"></div><div class="line">  import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">  import &#123; View &#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>提示的内容就是告诉我们需要把Component,React等从包 react 中引入,不能再从 react-native 中引入。</p>
<p>如果要更新引入，基本上要修改所有的文件，还好我们从 更新说明 中可以看到有工具来做这个事情。</p>
<p>提示的内容就是告诉我们需要把Component,React等从包react中引入,不能再从<code>react-native</code>中引入。<br>如果要更新引入，基本上要修改所有的文件，还好我们从更新说明中可以看到有工具来做这个事情。<br><code>codemod-RN24-to-RN25</code>是一个升级项目文件支持<code>React Native 25</code>的工具，更改文件的import，让需要引入react的文件能够正确的import。</p>
<p>使用方法:</p>
<ol>
<li>安装jscodeshift<br><br><br>npm install -g jscodeshift</li>
<li><p>clone项目<br><br>git clone git@github.com:sibeliusseraphini/codemod-RN24-to-RN25.git</p>
</li>
<li><p>copy transform.js<br><br>cd codemod-RN24-to-RN25<br><br>cp transform.js <code>YOUR_PROJECT_PATH</code></p>
</li>
<li><p>运行命令转换文件<br><br>cd <code>YOUR_PROJECT_PATH</code><br><br>jscodeshift transform.js</p>
</li>
</ol>
<p>等待运行完成之后可以看到React以及Component等都能被正确的引用到react包下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;新建React-Native报错解决办法&quot;&gt;&lt;a href=&quot;#新建React-Native报错解决办法&quot; class=&quot;headerlink&quot; title=&quot;新建React-Native报错解决办法&quot;&gt;&lt;/a&gt;新建React-Native报错解决办法&lt;/h3&gt;&lt;
    
    </summary>
    
    
      <category term="react native" scheme="http://yoursite.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>Java中abstract不能共存的关键字</title>
    <link href="http://yoursite.com/2016/10/13/Java%E4%B8%ADabstract%E4%B8%8D%E8%83%BD%E5%85%B1%E5%AD%98%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/10/13/Java中abstract不能共存的关键字/</id>
    <published>2016-10-13T15:34:54.000Z</published>
    <updated>2016-10-13T15:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>##abstract修饰不能和哪些关键字共存?</p>
<ul>
<li><strong>static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.</strong></li>
<li><strong>final 不能和abstract组合,由于final不允许重写方法,abstract需要直接重写方法</strong></li>
<li><strong>private 不能和abstract组合,abstract是为了让子类看到并且重写,而private是不让外界使用和了解</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##abstract修饰不能和哪些关键字共存?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;static不能和abstract组合,由于abstract没有方法体,所以用类去调用会失败.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final 不能和abstract组
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift泛型初探</title>
    <link href="http://yoursite.com/2016/10/08/Swift%E6%B3%9B%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2016/10/08/Swift泛型初探/</id>
    <published>2016-10-08T14:33:34.000Z</published>
    <updated>2016-10-10T14:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming language一书,重新看了一遍里面的内容–其实对于泛型,我最初的理解是来源于Java,在项目中我真的比较少用到泛型.</p>
<h4 id="泛型需求的产生"><a href="#泛型需求的产生" class="headerlink" title="泛型需求的产生"></a>泛型需求的产生</h4><p>下面是书里面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  func swapTwoInt(inout a:Int,inout b:Int)&#123;</div><div class="line">        let tempA = a;</div><div class="line">        a = b;</div><div class="line">        b = tempA</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要是我有这个交换两个内容的要求,但是这紧紧单纯是对Int但种类型的配置,如果我还需要有String和Double的话,我必须要拷贝代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func swapTwoString(inout a:String,inout b:String)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">&#125;</div><div class="line"></div><div class="line">      func swapTwoDouble(inout a:Double,inout b:Double)&#123;</div><div class="line">          let tempA = a;</div><div class="line">          a = b;</div><div class="line">          b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>于是我们产生了泛型,它可以定义一种统一的类型<t>,这个时候你可以在参数里面写入这个参数,它代表了前后一致的类型,如String,Int,Double…</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)&#123;</div><div class="line">       let tempA = a;</div><div class="line">       a = b;</div><div class="line">       b = tempA</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>在我写泛型的时候,遇到的第一个问题是返回值怎么处理?<br>唔哼,这个问题让我们继续把泛型的其他定义看下去的时候再继续思考吧.</p>
<h4 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h4><p>那么,泛型的书写方法就是用一对箭括号把类型名称合并起来:如 <strong><em><t></t></em></strong>,当然,你也可以一两个其他字母表示,<strong><em><u,t></u,t></em></strong></p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p> 其中,书中里面举了一个泛型类型的例子是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct IntStack &#123;</div><div class="line">    var items = [Int]();</div><div class="line">    /*</div><div class="line">     mutating关键字:由于swift功能强大,不仅可以让class遵守,也可以让enum和struct遵守</div><div class="line">     mutating关键字在定义协议的方法的时候可以在前面加上,让其三种类型在遵守协议的时候对有关键字的方法有不同的&quot;提示&quot;:</div><div class="line">    class: 在class中实现带有mutating方法的接口时，不用mutating进行修饰。因为对于class来说，类的成员变量和方法都是透明的，所以不必使用 mutating 来进行修饰</div><div class="line">     enum:</div><div class="line">     struct:如果将struct中的mutating去掉，则会报错不能改变结构体的成员。</div><div class="line">    */</div><div class="line">    //将一个数值入栈</div><div class="line">    mutating func push(item:Int)</div><div class="line">    &#123;</div><div class="line">        items.append(item)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //和内存中的栈一样,先进后出,所以只要移除最后一个元素即可</div><div class="line">    mutating func pop() -&gt; Int&#123;</div><div class="line">        </div><div class="line">        return items.removeLast()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是只针对Int一种类型避免也显得太弱了吧,所以我们可以用泛型对其进行改良:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Stack&lt;T&gt; &#123;</div><div class="line">      var items = [T]()</div><div class="line">      mutating func push(item: T) &#123;</div><div class="line">        items.append(item)</div><div class="line">      &#125;</div><div class="line">      mutating func pop() -&gt; T &#123;</div><div class="line">        return items.removeLast()</div><div class="line">      &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候可以将该类型延伸为相应的类型,如string:</p>
<pre><code>var stringsInStack = Stack&lt;String&gt;()
stringsInStack.push(&quot;1&quot;);//1
stringsInStack.push(&quot;2&quot;);//1,2
stringsInStack.push(&quot;3&quot;);//1,2,3
stringsInStack.push(&quot;4&quot;);//1,2,3,4
stringsInStack.pop()//1,2,3
</code></pre><p>现在,有点明白了Array和Dictionary为什么可以指定类型了吧,其实无形中我们已经用了很多泛型的内容,只是我们缺少了总结和理解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     //定义了一个内容必须为字符串的数组</div><div class="line">  var arr :[String] = []</div><div class="line">     arr[0] = &quot;name&quot;;</div><div class="line">     arr[1] = &quot;age&quot;;</div><div class="line">     arr[3] = &quot;height&quot;;</div><div class="line"></div><div class="line">//定义了一个key为String,value为AnyObject的字典  </div><div class="line">   var parma : [String:AnyObject] = [:]</div><div class="line">      parma[&quot;name&quot;] = &quot;shiron&quot;</div><div class="line">      parma[&quot;age&quot;] = 22</div><div class="line">      parma[&quot;height&quot;] = 1.70</div></pre></td></tr></table></figure>
<p>这里可以延伸出后面的一个话题:类型约束.</p>
<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>输入Dictionary点进去可以看到该类的属性和方法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible&#123;</div><div class="line">各种dict的属性和方法......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现在dict对泛型进行定义的时候,key有一个特殊的限制:</p>
<p><strong><strong><key: hashable,value=""></key:></strong></strong><br>此时,我们可以看到key被强制遵守了一个hashable的协议(注意:Swift 标准库中定义的一个特定协议,所有的 Swift 基本类型(如 String , Int , Double 和 Bool )默认都是可哈希。)</p>
<p>当你对泛型的有较高的输入要求时,可以限制某种类或者协议来进行类型约束,定义方法就是在泛型字母后面添加 T:SomeProtocol或者U:someClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func someFunction&lt;T:someClass,U:someProtocol&gt;(someT:T,someU:U)&#123;</div><div class="line">    //函数主体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩展一个泛型类型"><a href="#扩展一个泛型类型" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h4><p>当然我们泛型的好用之处不仅这么一点点.</p>
<p>书中还对Stack的类型作出了一个扩展:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension Stack &#123;</div><div class="line">    var topItem: T? &#123;</div><div class="line">        return items.isEmpty ? nil : items[items.count - 1]</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> topItem 属性会返回一个 T 类型的可选值。当栈为空的时候, topItem 将会返回 nil ;当栈不为空的时候, topItem 会返回 items 数组中的最后一个元素,然而你注意到了吗?我们在扩展里面并没有使用泛型类型的定义,它是从结构体中直接带过来了,对它进行解包则可以自己使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if let topItem = stackOfStrings.topItem &#123; </div><div class="line">    print(&quot; \(topItem)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实真的觉得即使自己能独立完成项目,还有是太多太多学习的地方可以不断提高,毕竟如果重复写一些代码是没有意义的.虽然说我已经使用了swift写了一个项目并且已经在AppStore里面发布,但是对于swift的认识还是很浅薄的.最近在重新看swift programming l
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中懒加载的then语法</title>
    <link href="http://yoursite.com/2016/09/13/swift%E4%B8%AD%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84then%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/13/swift中懒加载的then语法/</id>
    <published>2016-09-13T15:19:27.000Z</published>
    <updated>2016-10-19T09:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文:<br><a href="http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;mid=2652684686&amp;idx=1&amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;chksm=f00b6f44c77ce6521a20506a99cf446792ac70b537c09d05b7ad4066aa4b8a4cfaba4bedb2af&amp;scene=0#wechat_redirect" target="_blank" rel="external">Swift：让人眼前一亮的初始化方式</a></p>
<h3 id="then语法"><a href="#then语法" class="headerlink" title="then语法"></a>then语法</h3><p>个人非常喜欢这种简介的懒加载模式,唔,不过有时候真的会觉得$0的时候,无法感应该类的属性真蛋疼. 以下是加载方式,供大家参考学习.</p>
<pre><code>  import Foundation

 public protocol Then {}

 extension Then where Self: Any {
         /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: inout Self -&gt; Void) -&gt; Self {
        var copy = self
        block(&amp;copy)
        return copy
    }
     }

 extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///         $0.textAlignment = .Center
    ///         $0.textColor = UIColor.blackColor()
    ///         $0.text = &quot;Hello, World!&quot;
    ///     }
    public func then(@noescape block: Self -&gt; Void) -&gt; Self {
        block(self)
        return self
     }
    }

extension NSObject: Then {}


  //textFiled的常用懒加载模式
    private lazy var textFiled : UITextField={
        let textFiled = UITextField()
        textFiled.placeholder = &quot;请输入文字&quot;
        return textFiled
    }()

  //在尾随闭包中实例化了UILabel时的写法
     lazy var label : UILabel={

        $0.text = &quot;我是占位文字,textFiled改变时我也会改变&quot;
        $0.font = UIFont.systemFontOfSize(16)

        return $0
    }(UILabel())


//文章开始时给出的then代码段,使得初始化更简洁
 let label = UILabel().then {
      $0.textAlignment = .Center
      $0.textColor = .blackColor()
      $0.text = &quot;Hello, World!&quot;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文:&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4NjAzODk0OQ==&amp;amp;mid=2652684686&amp;amp;idx=1&amp;amp;sn=2adeb417aadd356fd615c6349a28e4f4&amp;amp
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习汇总</title>
    <link href="http://yoursite.com/2016/09/10/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/09/10/Java基础学习汇总/</id>
    <published>2016-09-10T15:31:12.000Z</published>
    <updated>2016-10-19T09:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础学习汇总"><a href="#Java基础学习汇总" class="headerlink" title="Java基础学习汇总"></a>Java基础学习汇总</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>了解:所谓多线程,即是在一个进程中,可以同时运行的多任务.如果把现实中的每个人理解为一个进程(QQ),那每个人可以同时处理多项任务,如一边听歌一边写作业可以理解为多线程开启.一个进程占用CUP时间是有限的,通常我们感觉不到有切换是因为CUP切换的速度极快.<h3 id="多线程的实现方法有两种"><a href="#多线程的实现方法有两种" class="headerlink" title="多线程的实现方法有两种"></a>多线程的实现方法有两种</h3></li>
<li><p>1.继承Thread</p>
<ul>
<li>定义类继承Thread</li>
<li>重写run方法</li>
<li>把新线程要做的内容写在run方法中</li>
<li>创建类的对象</li>
<li>执行start方法</li>
<li>注意:匿名内部类和普通类方式非常相似</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	//1.普通定义一个新的类来创建</div><div class="line">	Person p = new Person();</div><div class="line">	p.start();</div><div class="line">	//1.普通定义一个匿名类来创建</div><div class="line">	new Thread()&#123;</div><div class="line">		public void run()&#123;</div><div class="line">			System.out.println(&quot;Thread多线程启动(匿名内	部类)&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;.start();	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Thread方式</div><div class="line">class Person extends Thread &#123;</div><div class="line">	public void run()&#123;</div><div class="line">	System.out.println(&quot;Thread多线程启动,继承方式&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.实现接口Runnable(Thread构造函数中传递了runnable的引用,通过init()方法传递target,用于判断是否执行run()方法)</p>
<ul>
<li>定义类实现Runnable</li>
<li>实现run方法</li>
<li>把操作写在run中</li>
<li>创建Thread对象,传入runnable</li>
<li>调用Runnable的start方法</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">public class Test &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">//1.普通类实现了runnable接口来实现调用里面的run方法</div><div class="line">Student s = new Student();</div><div class="line">Thread t = new Thread(s);</div><div class="line">t.start();</div><div class="line">//2.匿名类来实现runnable接口</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;匿名内部类Runnable多线程启动方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;).start();	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class Student implements Runnable&#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;Runnable多线程启动方法,继承方式&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="两种线程的区别"><a href="#两种线程的区别" class="headerlink" title="两种线程的区别"></a>两种线程的区别</h3><ul>
<li>继承Thread<ul>
<li>好处:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端:如果已经有父类,就不能用这种方式</li>
</ul>
</li>
<li>实现Runnable<ul>
<li>好处:可以有父类,直接只是实现接口</li>
<li>弊端:间接把对象作为构造方法的参数传递进去,较为复杂,但自由度较大</li>
</ul>
</li>
</ul>
<h3 id="线程中其他操作"><a href="#线程中其他操作" class="headerlink" title="线程中其他操作"></a>线程中其他操作</h3><ul>
<li>通过getName()可以获得当前线程的名字</li>
<li>通过setName(String)可以设置线程名字</li>
<li>Thread.currentThread()可以获得当前线程对象,获得对象后可以对其进行操作(改名,获得名字)</li>
<li>Thread.sleep(毫秒),类方法调用,可以使得当前线程休眠</li>
<li>setPriority()设置线程的优先级</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java基础学习汇总&quot;&gt;&lt;a href=&quot;#Java基础学习汇总&quot; class=&quot;headerlink&quot; title=&quot;Java基础学习汇总&quot;&gt;&lt;/a&gt;Java基础学习汇总&lt;/h2&gt;&lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;header
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>swift中的extension(持续更新)</title>
    <link href="http://yoursite.com/2016/08/25/swift%E4%B8%AD%E7%9A%84extension-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/08/25/swift中的extension-持续更新/</id>
    <published>2016-08-25T04:36:39.000Z</published>
    <updated>2016-10-27T13:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用"><a href="#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用" class="headerlink" title="在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~"></a>在工作中会遇到很多关于extension的扩展,我把一些有趣的扩展都存下来,以便以后学习使用~~</h4><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">extension String&#123;</div><div class="line">    </div><div class="line">      /**</div><div class="line">     将时间戳转换成时间</div><div class="line">     </div><div class="line">     - parameter timestamp: 时间戳</div><div class="line">     - parameter formatter: 时间格式</div><div class="line">     */</div><div class="line">    static func stringFromTimestamp(timestamp: String?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let stamp = timestamp, fm = formatter else &#123; return nil &#125;</div><div class="line">        let nsStamp = NSString(string: stamp)</div><div class="line">        let date = NSDate(timeIntervalSince1970: nsStamp.doubleValue)</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(date)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将时间转换成字符串</div><div class="line">     </div><div class="line">     */</div><div class="line">    static func stringFromDate(date: NSDate?, withFormatter formatter: String?) -&gt; String? &#123;</div><div class="line">        guard let timeDate = date, fm = formatter else &#123; return nil &#125;</div><div class="line">        let dateFormatter = NSDateFormatter()</div><div class="line">        dateFormatter.dateFormat = fm</div><div class="line">        return dateFormatter.stringFromDate(timeDate)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    手机号验证</div><div class="line">    </div><div class="line">    - parameter mobile: 手机号</div><div class="line">    </div><div class="line">    - returns: true/fales 符合条件,不符合条件</div><div class="line">    */</div><div class="line">    static func isValidateMobile(mobile: String?) -&gt; Bool &#123;</div><div class="line">        let phoneRegex = &quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;</div><div class="line">        let phoneTest = NSPredicate(format: &quot;SELF MATCHES %@&quot;, phoneRegex)</div><div class="line">        if mobile != nil &#123;</div><div class="line">            return phoneTest.evaluateWithObject(mobile)</div><div class="line">        &#125; else &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    四舍五入</div><div class="line">    </div><div class="line">    - parameter price:    要四舍五入的值</div><div class="line">    - parameter position: 保留多少小数位</div><div class="line">    </div><div class="line">    - returns: 返回四舍五入后的值</div><div class="line">    */</div><div class="line">    static func notRounding(price: Float, afterPoint position: Int16) -&gt; NSString? &#123;</div><div class="line">        let roundingBehavior = NSDecimalNumberHandler(roundingMode: NSRoundingMode.RoundUp, scale: position, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: false)</div><div class="line">        var ouncesDecimal: NSDecimalNumber</div><div class="line">        var roundedOunces: NSDecimalNumber</div><div class="line">        </div><div class="line">        ouncesDecimal = NSDecimalNumber(float: price)</div><div class="line">        roundedOunces = ouncesDecimal.decimalNumberByRoundingAccordingToBehavior(roundingBehavior)</div><div class="line">        </div><div class="line">        return roundedOunces.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    获取当前星期几</div><div class="line">    </div><div class="line">    - parameter date: 传入的时间</div><div class="line">    </div><div class="line">    - returns: 返回当前为星期几元祖</div><div class="line">    */</div><div class="line">    static func getCurrentWeekDay(date: NSDate) -&gt; (String, Int)? &#123;</div><div class="line">        let arrWeek = [&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;]</div><div class="line">        let date = NSDate()</div><div class="line">        let calendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)</div><div class="line">        let timeZone = NSTimeZone(name: &quot;Asia/Shanghai&quot;)</div><div class="line">        calendar!.timeZone = timeZone!</div><div class="line">        var comps = NSDateComponents()</div><div class="line">        comps = calendar!.components(NSCalendarUnit.Weekday, fromDate: date)</div><div class="line">        let week = comps.weekday</div><div class="line">        return (arrWeek[week - 1], week - 1)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     - parameter comment:   注释名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?, comment: String?) -&gt; String &#123;</div><div class="line">        </div><div class="line">        guard let commentStr = comment else &#123;</div><div class="line">            return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: commentStr)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     本地化字符串</div><div class="line">     </div><div class="line">     - parameter tableName: 文件名称</div><div class="line">     </div><div class="line">     - returns: 本地化后的字符串</div><div class="line">     */</div><div class="line">    func localizedWithComment(tableName: String?) -&gt; String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: tableName!, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 对应默认的Localizable.strings</div><div class="line">    var localized: String &#123;</div><div class="line">        return NSLocalizedString(self, tableName: nil, bundle: NSBundle.mainBundle(), value: &quot;&quot;, comment: &quot;&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">    浮点数相乘</div><div class="line">    */</div><div class="line">    static func decimalNumberMutiplyWithString(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByMultiplyingBy(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相加</div><div class="line">     */</div><div class="line">    static func decimalNumberByAdding(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplicandNumber.decimalNumberByAdding(multiplierNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     浮点数相减</div><div class="line">     */</div><div class="line">    static func decimalNumberBySubtracting(multiplierValue: String, andOtherString otherString: String) -&gt; String &#123;</div><div class="line">        let multiplierNumber = NSDecimalNumber(string: multiplierValue)</div><div class="line">        let multiplicandNumber = NSDecimalNumber(string: otherString)</div><div class="line">        let product = multiplierNumber.decimalNumberBySubtracting(multiplicandNumber)</div><div class="line">        return product.stringValue</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     过滤空格</div><div class="line">     */</div><div class="line">    static func trimmingCharactersWhite(str: String) -&gt; String &#123;</div><div class="line">        // 去除两端空格</div><div class="line">        let temp = str.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())</div><div class="line">        // 去除其余空格</div><div class="line">        let text = temp.stringByReplacingOccurrencesOfString(&quot; &quot;, withString: &quot;&quot;)</div><div class="line">        return text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    //截取特定字符串</div><div class="line">    subscript (r: Range&lt;Int&gt;) -&gt; String &#123;</div><div class="line">        get &#123;</div><div class="line">            let startIndex = self.startIndex.advancedBy(r.startIndex)</div><div class="line">            let endIndex = self.startIndex.advancedBy(r.endIndex)</div><div class="line">            </div><div class="line">            return self[Range(start: startIndex, end: endIndex)]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     将当前字符串拼接到cache目录后面</div><div class="line">     */</div><div class="line">    func cacheDir() -&gt; String&#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.cachesDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到doc目录后面</div><div class="line">     */</div><div class="line">    func docDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).last!  as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     将当前字符串拼接到tmp目录后面</div><div class="line">     */</div><div class="line">    func tmpDir() -&gt; String</div><div class="line">    &#123;</div><div class="line">        let path = NSTemporaryDirectory() as NSString</div><div class="line">        return path.appendingPathComponent((self as NSString).lastPathComponent)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot;&gt;&lt;a href=&quot;#在工作中会遇到很多关于extension的扩展-我把一些有趣的扩展都存下来-以便以后学习使用&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 万能跳转界面方法</title>
    <link href="http://yoursite.com/2016/08/15/iOS-%E4%B8%87%E8%83%BD%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/15/iOS-万能跳转界面方法/</id>
    <published>2016-08-15T01:52:07.000Z</published>
    <updated>2016-11-15T01:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="http://www.cocoachina.com/ios/20150824/13104.html" target="_blank" rel="external">cocoaChina的汉斯哈哈哈</a></p>
<p>在开发项目中，会有这样变态的需求：</p>
<ul>
<li><p>推送：根据服务端推送过来的数据规则，跳转到对应的控制器</p>
</li>
<li><p>feeds列表：不同类似的cell，可能跳转不同的控制器（嘘！产品经理是这样要求：我也不确定会跳转哪个界面哦，可能是这个又可能是那个，能给我做灵活吗？根据后台返回规则任意跳转？）</p>
</li>
</ul>
<p>思考：wocao！这变态的需求，要拒绝他吗？</p>
<p>switch判断呗，考虑所有跳转的因素？这不得写死我…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">switch () &#123;</div><div class="line">    case :</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>我是这么个实现的（runtime是个好东西）</strong></p>
<p>利用runtime动态生成对象、属性、方法这特性，我们可以先跟服务端商量好，定义跳转规则，比如要跳转到A控制器，需要传属性id、type，那么服务端返回字典给我，里面有控制器名，两个属性名跟属性值，客户端就可以根据控制器名生成对象，再用kvc给对象赋值，这样就搞定了 —O(∩_∩)O哈哈哈</p>
<p>比如：根据推送规则跳转对应界面HSFeedsViewController</p>
<p>HSFeedsViewController.h：</p>
<ul>
<li>进入该界面需要传的属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">@interface HSFeedsViewController : UIViewController</div><div class="line">// 注：根据下面的两个属性，可以从服务器获取对应的频道列表数据</div><div class="line">/** 频道ID */</div><div class="line">@property (nonatomic, copy) NSString *ID;</div><div class="line">/** 频道type */</div><div class="line">@property (nonatomic, copy) NSString *type;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>AppDelegate.m：</p>
<ul>
<li>推送过来的消息规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 这个规则肯定事先跟服务端沟通好，跳转对应的界面需要对应的参数</div><div class="line">NSDictionary *userInfo = @&#123;</div><div class="line">                           @&quot;class&quot;: @&quot;HSFeedsViewController&quot;,</div><div class="line">                           @&quot;property&quot;: @&#123;</div><div class="line">                                        @&quot;ID&quot;: @&quot;123&quot;,</div><div class="line">                                        @&quot;type&quot;: @&quot;12&quot;</div><div class="line">                                   &#125;</div><div class="line">                           &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>接收推送消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</div><div class="line">&#123;</div><div class="line">    [self push:userInfo];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>跳转界面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">- (void)push:(NSDictionary *)params</div><div class="line">&#123;</div><div class="line">    // 类名</div><div class="line">    NSString *class =[NSString stringWithFormat:@&quot;%@&quot;, params[@&quot;class&quot;]];</div><div class="line">    const char *className = [class cStringUsingEncoding:NSASCIIStringEncoding];</div><div class="line">    // 从一个字串返回一个类</div><div class="line">    Class newClass = objc_getClass(className);</div><div class="line">    if (!newClass)</div><div class="line">    &#123;</div><div class="line">        // 创建一个类</div><div class="line">        Class superClass = [NSObject class];</div><div class="line">        newClass = objc_allocateClassPair(superClass, className, 0);</div><div class="line">        // 注册你创建的这个类</div><div class="line">        objc_registerClassPair(newClass);</div><div class="line">    &#125;</div><div class="line">    // 创建对象</div><div class="line">    id instance = [[newClass alloc] init];</div><div class="line">    // 对该对象赋值属性</div><div class="line">    NSDictionary * propertys = params[@&quot;property&quot;];</div><div class="line">    [propertys enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">        // 检测这个对象是否存在该属性</div><div class="line">        if ([self checkIsExistPropertyWithInstance:instance verifyPropertyName:key]) &#123;</div><div class="line">            // 利用kvc赋值</div><div class="line">            [instance setValue:obj forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    // 获取导航控制器</div><div class="line">    UITabBarController *tabVC = (UITabBarController *)self.window.rootViewController;</div><div class="line">    UINavigationController *pushClassStance = (UINavigationController *)tabVC.viewControllers[tabVC.selectedIndex];</div><div class="line">    // 跳转到对应的控制器</div><div class="line">    [pushClassStance pushViewController:instance animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>检测对象是否存在该属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (BOOL)checkIsExistPropertyWithInstance:(id)instance verifyPropertyName:(NSString *)verifyPropertyName</div><div class="line">&#123;</div><div class="line">    unsigned int outCount, i;</div><div class="line">    // 获取对象里的属性列表</div><div class="line">    objc_property_t * properties = class_copyPropertyList([instance</div><div class="line">                                                           class], &amp;outCount);</div><div class="line">    for (i = 0; i &lt; outCount; i++) &#123;</div><div class="line">        objc_property_t property =properties[i];</div><div class="line">        //  属性名转成字符串</div><div class="line">        NSString *propertyName = [[NSString alloc] initWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">        // 判断该属性是否存在</div><div class="line">        if ([propertyName isEqualToString:verifyPropertyName]) &#123;</div><div class="line">            free(properties);</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;a href=&quot;http://www.cocoachina.com/ios/20150824/13104.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cocoaChina的汉斯哈哈哈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在开发项目中，会有这样变
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cell中的折叠效果如何实现?</title>
    <link href="http://yoursite.com/2016/08/02/cell%E4%B8%AD%E7%9A%84%E6%8A%98%E5%8F%A0%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/08/02/cell中的折叠效果如何实现/</id>
    <published>2016-08-02T06:35:46.000Z</published>
    <updated>2016-11-07T09:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点开后可以查看具体的联系人-那么这种效果是如何实现的呢"><a href="#有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点开后可以查看具体的联系人-那么这种效果是如何实现的呢" class="headerlink" title="有时候我们需要实现一种点击cell的时候,展开和收起cell的内容这种效果,类似QQ的分组,点开后可以查看具体的联系人.那么这种效果是如何实现的呢?"></a>有时候我们需要实现一种点击cell的时候,展开和收起cell的内容这种效果,类似QQ的分组,点开后可以查看具体的联系人.那么这种效果是如何实现的呢?</h4><p><img src="http://ww3.sinaimg.cn/mw690/7616e2bagw1f9dr91e3pyj20kk11uabk.jpg" alt="image"></p>
<p>这里列举一种最简答的实现方法,主要核心代码是要在模型中设置一个是否展开的属性,根据这个属性来判断是否要展开cell,如果NO的时候,只要在<code>tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</code>返回中返回0即可,如果YES的时候,则需要返回一个cell中具体的行数.header只要给定一个点击事件来刷新tableView就可以了(此时要修改是否要展示的属性).</p>
<p>下面分部讲解一下设置的方法:</p>
<h3 id="1-先设置一个模型数组-里面含有一下几个属性"><a href="#1-先设置一个模型数组-里面含有一下几个属性" class="headerlink" title="1. 先设置一个模型数组,里面含有一下几个属性"></a>1. 先设置一个模型数组,里面含有一下几个属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface MyData : NSObject</div><div class="line">//名称 ABCD...</div><div class="line">@property (nonatomic ,copy ) NSString* name;</div><div class="line">//是否展示</div><div class="line">@property (nonatomic , assign ) BOOL isShow;</div><div class="line">//子数组 </div><div class="line">@property (nonatomic , strong ) NSMutableArray* array;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="2-添加视图View和数据源数据"><a href="#2-添加视图View和数据源数据" class="headerlink" title="2. 添加视图View和数据源数据"></a>2. 添加视图View和数据源数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //数据源数组,里面装的是模型数组</div><div class="line">    _dataArray = [NSMutableArray array];</div><div class="line">    </div><div class="line">    //设置数据</div><div class="line">    for (int i = &apos;A&apos;; i&lt;= &apos;Z&apos;; i++) &#123;</div><div class="line">        MyData * mydata =  [[MyData alloc] init];</div><div class="line">        NSLog(@&quot;%c&quot; , i);</div><div class="line">        mydata.name =  [NSString stringWithFormat:@&quot;%c&quot;,i];</div><div class="line">        </div><div class="line">        mydata.array =  [NSMutableArray array];</div><div class="line">        for (int j = 0;  j &lt;= 10; j++) &#123;</div><div class="line">            [mydata.array addObject:[NSString stringWithFormat:@&quot;%c-%d&quot;,i,j]];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        [_dataArray addObject:mydata];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">	//设置tableView,一定要注意,这里的样式是要选组样式</div><div class="line">    _myTableview =  [[UITableView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) style:UITableViewStyleGrouped];</div><div class="line">    _myTableview.dataSource = self;</div><div class="line">    _myTableview.delegate = self;</div><div class="line">    _myTableview.rowHeight = 30;</div><div class="line">    [self.view addSubview:_myTableview];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-设置tableView的代理内容-主要是常用的两个加上在section中要设置判断条件"><a href="#3-设置tableView的代理内容-主要是常用的两个加上在section中要设置判断条件" class="headerlink" title="3. 设置tableView的代理内容,主要是常用的两个加上在section中要设置判断条件"></a>3. 设置tableView的代理内容,主要是常用的两个加上在section中要设置判断条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//显示多少组</div><div class="line">-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123;</div><div class="line">    return self.dataArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//每一组里面显示多少个cell</div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    </div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:section];</div><div class="line">    </div><div class="line">    if (data.isShow)&#123;</div><div class="line">        return data.array.count;</div><div class="line">    &#125;else&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//设置cell的样式</div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    static NSString * cellName = @&quot;cell&quot;;</div><div class="line">    UITableViewCell* cell =  [tableView dequeueReusableCellWithIdentifier:cellName ];</div><div class="line">    </div><div class="line">    if (!cell)&#123;</div><div class="line">        </div><div class="line">        cell =  [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:cellName];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:indexPath.section];</div><div class="line">    cell.textLabel.text = [data.array objectAtIndex:indexPath.row];</div><div class="line">    return  cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-设置headerView-并且设置点击时展开和闭合cell"><a href="#4-设置headerView-并且设置点击时展开和闭合cell" class="headerlink" title="4. 设置headerView,并且设置点击时展开和闭合cell"></a>4. 设置headerView,并且设置点击时展开和闭合cell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123;</div><div class="line">    //获取数组</div><div class="line">    MyData* data =  [self.dataArray objectAtIndex:section];</div><div class="line">    //生成btn的属性,并添加到headerView中</div><div class="line">    UIButton* btn =  [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    btn.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 30);</div><div class="line">    [btn setTitle:data.name forState:UIControlStateNormal];</div><div class="line">    btn.tag = section;</div><div class="line">    [btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    if (section%2)&#123;</div><div class="line">        </div><div class="line">        btn.backgroundColor =  [UIColor darkGrayColor];</div><div class="line">        </div><div class="line">    &#125;else&#123;</div><div class="line">        </div><div class="line">        btn.backgroundColor =  [UIColor grayColor];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return btn;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//设置headerView的高度</div><div class="line">-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;</div><div class="line">    return 30;</div><div class="line">&#125;</div><div class="line">//设置footerView的高度,这家伙如果不设置或者设置为0的是否都好像会显示和headerView一样的高度</div><div class="line">-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123;</div><div class="line">    return 0.1;</div><div class="line">&#125;</div><div class="line">//点击事件,展开和收合cell</div><div class="line">-(void)btnClick:(UIButton*) btn&#123;</div><div class="line">    MyData* data =  [self.dataArray  objectAtIndex:btn.tag];</div><div class="line">    if (data.isShow) &#123;</div><div class="line">        data.isShow = NO;</div><div class="line">    &#125;else&#123;</div><div class="line">        data.isShow = YES;</div><div class="line">    &#125;</div><div class="line">    //刷新动画样式</div><div class="line">    [_myTableview reloadSections:[NSIndexSet indexSetWithIndex:btn.tag] withRowAnimation:UITableViewRowAnimationFade];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点开后可以查看具体的联系人-那么这种效果是如何实现的呢&quot;&gt;&lt;a href=&quot;#有时候我们需要实现一种点击cell的时候-展开和收起cell的内容这种效果-类似QQ的分组-点
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift-访问控制</title>
    <link href="http://yoursite.com/2016/07/18/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2016/07/18/Swift-访问控制/</id>
    <published>2016-07-18T09:22:13.000Z</published>
    <updated>2016-10-18T09:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>和其他高级语言一样Swift中也增加了访问控制，在Swift中提供了private、internal、public三种访问级别，但是不同的是Swift中的访问级别是基于模块（module，或者target）和源文件（.swift文件）的，而不是基于类型、命名空间声明。</p>
<ul>
<li>private:只能访问当前源文件中的实体（注意Swift中的private和其他语言不太一样，它是基于源文件的，作用范围是整个源文件，如果一个源文件中有两个类，那么一个类可以访问另外一个类的私有成员）。</li>
<li>internal:可以访问当前模块中的其他任何实体，但是在模块外无法访问，这是所有实体的默认访问级别（通常在一个单目标Application中不需要自行设置访问级别）。</li>
<li>public:可以访问当前模块及其他模块中的任何实体（通常用于Framework）。</li>
</ul>
<p>下面是关于Swift关于不同成员访问级别的约定规则：</p>
<ol>
<li>如果一个类的访问级别是private那么该类的所有成员都是private（此时成员无法修改访问级别），如果一个类的访问级别是internal或者public那么它的所有成员都是internal（如果类的访问级别是public，成员默认internal，此时可以单独修改成员的访问级别），类成员的访问级别不能高于类的访问级别(注意：嵌套类型的访问级别也符合此条规则)；</li>
<li>常量、变量、属性、下标脚本访问级别低于其所声明的类型级别，并且如果不是默认访问级别（internal）要明确声明访问级别（例如一个常量是一个private类型的类类型，那么此常量必须声明为private）；</li>
<li>在不违反1、2两条规则的情况下，setter的访问级别可以低于getter的访问级别(例如一个属性访问级别是internal，那么可以添加private(set)修饰将setter权限设置为private，在当前模块中只有此源文件可以访问，对外部是只读的);</li>
<li>必要构造方法（required修饰）的访问级别必须和类访问级别相同，结构体的默认逐一构造函数的访问级别不高于其成员的访问级别（例如一个成员是private那么这个构造函数就是private，但是可以通过自定义来声明一个public的构造函数）,其他方法（包括其他构造方法和普通方法）的访问级别遵循规则1；</li>
<li>子类的访问级别不高于父类的访问级别，但是在遵循三种访问级别作用范围的前提下子类可以将父类低访问级别的成员重写成更高的访问级别（例如父类A和子类B在同一个源文件，A的访问级别是public，B的访问级别是internal，其中A有一个private方法，那么A可以覆盖其private方法并重写为internal）；</li>
<li>协议中所有必须实现的成员的访问级别和协议本身的访问级别相同，其子协议的访问级别不高于父协议；</li>
<li>如果一个类继承于另一个类的同时实现了某个协议那么这个类的访问级别为父类和协议的最低访问级别，并且此类中方法访问级别和所实现的协议中的方法相同；</li>
<li>扩展的成员访问级别遵循规则1，但是对于类、结构体、枚举的扩展可以明确声明访问级别并且可以更低（例如对于internal的类，你可以声明一个private的扩展），而协议的访问级别不可以明确声明；</li>
<li>元组的访问级别是元组中各个元素的最低访问级别，注意：元组的访问级别是自动推导的，无法直接使用以上三个关键字修饰其访问级别；<ol>
<li>函数的访问级是函数的参数、返回值的最低级别，并且如果其访问级别和默认访问级别（internal）不符需要明确声明；</li>
<li>枚举成员的访问级别等同于枚举的访问级别（无法单独设置），同时枚举的原始值、关联值的访问级别不能低于枚举的访问级别；</li>
</ol>
</li>
<li>泛型类型或泛型函数的访问级别是泛型类型、泛型函数、泛型类型参数三者中最低的一个；</li>
<li><p>类型别名的访问级别不能高于原类型的访问级别；</p>
<p>上面这些规则看上去比较繁琐，但其实很多内容理解起来也是顺理成章的（如果你是一个语言设计者相信大部分规则也会这么设计），下面通过一个例子对于规则3做一解释，这一点和其他语言有所不同但是却更加实用。在使用ObjC开发时大家通常会有这样的经验：在一个类中希望某个属性对外界是只读的，但是自己又需要在类中对属性进行写操作，此时只能直接访问属性对应的成员变量，而不能直接访问属性进行设置。但是Swift为了让语法尽可能精简，并没有成员变量的概念，此时就可以通过访问控制来实现。</p>
</li>
</ol>
<p>Person.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import Foundation</div><div class="line"> </div><div class="line">public class Person &#123;</div><div class="line">    //设置setter私有，但是getter为public</div><div class="line">    public private(set) var name:String</div><div class="line">     </div><div class="line">    public init(name:String)&#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public func showMessage()&#123;</div><div class="line">        println(&quot;name=\(name)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import Foundation</div><div class="line"> </div><div class="line">var p =  Person(name:&quot;Kenshin&quot;)</div><div class="line">//此时不能设置name属性，但是可读</div><div class="line">//p.name = &quot;Kaoru&quot;</div><div class="line">println(&quot;name=\(p.name)&quot;)</div><div class="line">p.showMessage()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问控制&quot;&gt;&lt;a href=&quot;#访问控制&quot; class=&quot;headerlink&quot; title=&quot;访问控制&quot;&gt;&lt;/a&gt;访问控制&lt;/h2&gt;&lt;p&gt;和其他高级语言一样Swift中也增加了访问控制，在Swift中提供了private、internal、public三种访问级
    
    </summary>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>52个建议中的&#39;别忘了NSTimer会保留其目标对象&#39;</title>
    <link href="http://yoursite.com/2016/06/13/52%E4%B8%AA%E5%BB%BA%E8%AE%AE-%E5%88%AB%E5%BF%98%E4%BA%86NSTimer%E4%BC%9A%E4%BF%9D%E7%95%99%E5%85%B6%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2016/06/13/52个建议-别忘了NSTimer会保留其目标对象/</id>
    <published>2016-06-13T14:28:48.000Z</published>
    <updated>2016-11-13T14:43:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>估计大家在开发中也经常遇到关于NSTimer循环引用的问题,在书中提及了使用块的方法来解决我们使用NSTimer时造成的循环引用.(主要是我们有可能会忘记NSTimer的作用失去时,接触对其的强引用,解除循环引用)</p>
<h5 id="NSTimer-XHUsingBlock-h"><a href="#NSTimer-XHUsingBlock-h" class="headerlink" title="NSTimer+XHUsingBlock.h"></a>NSTimer+XHUsingBlock.h</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSTimer (XHUsingBlock)</div><div class="line"></div><div class="line">+(NSTimer*)xh_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</div><div class="line">                                       block:(void(^)())block</div><div class="line">                                     repeats:(BOOL)repeats;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h5 id="NSTimer-XHUsingBlock-m"><a href="#NSTimer-XHUsingBlock-m" class="headerlink" title="NSTimer+XHUsingBlock.m"></a>NSTimer+XHUsingBlock.m</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSTimer+XHUsingBlock.h&quot;</div><div class="line"></div><div class="line">@implementation NSTimer (XHUsingBlock)</div><div class="line"></div><div class="line">+(NSTimer*)xh_scheduledTimerWithTimeInterval:(NSTimeInterval)ti</div><div class="line">                                       block:(void(^)())block</div><div class="line">                                     repeats:(BOOL)repeats&#123;</div><div class="line">    </div><div class="line">    return  [self scheduledTimerWithTimeInterval:ti target:self selector:@selector(xh_blockInvoke:) userInfo:[block copy] repeats:repeats];</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">+(void)xh_blockInvoke:(NSTimer*)timer&#123;</div><div class="line">    </div><div class="line">    void(^block)() = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个使用,我们在使用这段代码时注意给类换上弱引用效果就可以解决内存泄露的问题了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    _timer =  [NSTimer xh_scheduledTimerWithTimeInterval:0.1 block:^&#123;</div><div class="line">    </div><div class="line">        __strong typeof(self) strongSelf = weakSelf;</div><div class="line">        </div><div class="line">        [strongSelf run];</div><div class="line">        </div><div class="line">    &#125; repeats:YES];</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)run&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;run&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;估计大家在开发中也经常遇到关于NSTimer循环引用的问题,在书中提及了使用块的方法来解决我们使用NSTimer时造成的循环引用.(主要是我们有可能会忘记NSTimer的作用失去时,接触对其的强引用,解除循环引用)&lt;/p&gt;
&lt;h5 id=&quot;NSTimer-XHUsingBl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java异常处理抛出</title>
    <link href="http://yoursite.com/2016/06/13/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8A%9B%E5%87%BA/"/>
    <id>http://yoursite.com/2016/06/13/Java异常处理抛出/</id>
    <published>2016-06-13T06:34:48.000Z</published>
    <updated>2016-10-13T15:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.</p>
<p>###1.所谓的异常就是在Java程序运行过程中出现的错误.</p>
<ul>
<li>Error : 直接的错误信息,网络回调错误,数据库异常等.</li>
<li>Execption : 异常信息,较为核心的是RuntimeException子类<br>######<em>注:以上两个类都是继承了Throwable的类</em></li>
</ul>
<p>###2.try…catch 的格式(方式)</p>
<ul>
<li>A:异常处理的两种方式<ul>
<li>a:try…catch…finally<br><em>注意:1.被finally控制的语句体一定会执行</em><br><em>2.用于释放资源，在IO流操作和数据库操作中会见到</em><ul>
<li>try catch</li>
<li>try catch finally</li>
<li>try finally </li>
</ul>
</li>
<li>b:throws</li>
</ul>
</li>
<li>B:try…catch处理异常的基本格式<ul>
<li>try…catch…finally</li>
</ul>
</li>
</ul>
<p>###3.那么我们如何选择异常处理的方式呢?</p>
<ul>
<li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li>
<li>区别:<ul>
<li>后续程序需要继续运行就try</li>
<li>后续程序不需要继续运行就throws</li>
</ul>
</li>
</ul>
<p>###4.自定义异常的主要原因是为了可以快速定位异常的原因</p>
<ul>
<li>一种是继承自RuntimeException,另外一种是继承Exception.</li>
</ul>
<p><em>其实对于异常的使用,还是不是特别理解,日后回来再填坑.</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实在Java中的异常在Swift中也曾看到过,但是在实际中没有用过,所以也不知道具体的效果,可能在Siwft中的异常处理机制比较温和吧,Java中数组越界,或者其他错误都会导致程序直接停止.所以异常对于Java来说其实也是很重要的一个机制吧.&lt;/p&gt;
&lt;p&gt;###1.所谓
    
    </summary>
    
    
  </entry>
  
</feed>
