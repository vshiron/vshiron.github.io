<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      iOS最全性能优化 | shiron 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="shiron">
    
    

    <meta name="description" content="其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)
原文地址:iOS最全性能优化 - HelloYeah
目录我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：
入门级（这是些你一定会经常用在你app开发中的建议）

123456781. 用ARC管理内存2. 在正确的地方使用reuseIdentifier3">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS最全性能优化 | shiron">
<meta property="og:url" content="http://yoursite.com/2016/11/13/iOS最全性能优化/index.html">
<meta property="og:site_name" content="shiron">
<meta property="og:description" content="其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)
原文地址:iOS最全性能优化 - HelloYeah
目录我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：
入门级（这是些你一定会经常用在你app开发中的建议）

123456781. 用ARC管理内存2. 在正确的地方使用reuseIdentifier3">
<meta property="og:updated_time" content="2016-11-14T04:36:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS最全性能优化 | shiron">
<meta name="twitter:description" content="其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)
原文地址:iOS最全性能优化 - HelloYeah
目录我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：
入门级（这是些你一定会经常用在你app开发中的建议）

123456781. 用ARC管理内存2. 在正确的地方使用reuseIdentifier3">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">shiron</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">iOS最全性能优化</h1>

    

    <div class="post-meta">
      <time datetime="2016-11-13" class="post-meta__date date">2016-11-13</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>其中在快速开发app的时候往往会忽略一些性能的问题,然后我在网上找了一些资料来看看,反正这几篇总结得是比较好的(复用性较为全面)</p>
<p>原文地址:<a href="http://www.jianshu.com/p/9c450e512020" target="_blank" rel="external">iOS最全性能优化 - HelloYeah</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级："><a href="#我要给出的建议将分为三个不同的等级：-入门级、-中级和进阶级：" class="headerlink" title="我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级："></a>我要给出的建议将分为三个不同的等级： 入门级、 中级和进阶级：</h4><ul>
<li>入门级（这是些你一定会经常用在你app开发中的建议）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. 用ARC管理内存</div><div class="line">2. 在正确的地方使用reuseIdentifier</div><div class="line">3. 尽可能使Views透明</div><div class="line">4. 避免庞大的XIB</div><div class="line">5. 不要block主线程</div><div class="line">6. 在Image Views中调整图片大小</div><div class="line">7. 选择正确的Collection</div><div class="line">8. 打开gzip压缩</div></pre></td></tr></table></figure>
<ul>
<li>中级（这些是你可能在一些相对复杂情况下可能用到的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">9. 重用和延迟加载Views</div><div class="line">10. Cache, Cache, 还是Cache！</div><div class="line">11. 权衡渲染方法</div><div class="line">12. 处理内存警告</div><div class="line">13. 重用大开销的对象</div><div class="line">14. 使用Sprite Sheets</div><div class="line">15. 避免反复处理数据</div><div class="line">16. 选择正确的数据格式</div><div class="line">17. 正确地设定Background Images</div><div class="line">18. 减少使用Web特性</div><div class="line">19. 设定Shadow Path</div><div class="line">20. 优化你的Table View</div><div class="line">21. 选择正确的数据存储选项</div></pre></td></tr></table></figure>
<ul>
<li>进阶级（这些建议只应该在你确信他们可以解决问题和得心应手的情况下采用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">22. 加速启动时间</div><div class="line">23. 使用Autorelease Pool</div><div class="line">24. 选择是否缓存图片</div><div class="line">25. 尽量避免日期格式转换</div></pre></td></tr></table></figure>
<p>初学者性能提升<br>这个部分致力于一些能提高性能的基本改变。但所有层次的开发者都有可能会从这个记录了一些被忽视的项目的小小的性能备忘录里获得一些提升。</p>
<h5 id="1-用ARC管理内存"><a href="#1-用ARC管理内存" class="headerlink" title="1.用ARC管理内存"></a>1.用ARC管理内存</h5><ul>
<li><p>ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。<br>  下面是你会经常用来去创建一个View的代码段:</p>
<pre><code>UIView *view = [[UIView alloc] init];
 // ...
[self.view addSubview:view];
 [view release];
</code></pre></li>
<li><p>忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。这都啥年代了，你应该在你的所有项目里使用ARC!</p>
</li>
</ul>
<h5 id="2-在正确的地方使用-reuseIdentifier"><a href="#2-在正确的地方使用-reuseIdentifier" class="headerlink" title="2.在正确的地方使用 reuseIdentifier"></a>2.在正确的地方使用 reuseIdentifier</h5><ul>
<li><p>一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。</p>
</li>
<li><p>为了性能最优化，table view用 tableView:cellForRowAtIndexPath: 为rows分配cells的时候，它的数据应该重用自UITableViewCell。 一个table view维持一个队列的数据可重用的UITableViewCell对象。不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。</p>
</li>
</ul>
<ul>
<li>自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers</li>
</ul>
<h5 id="3-尽量把views设置为完全不透明"><a href="#3-尽量把views设置为完全不透明" class="headerlink" title="3.尽量把views设置为完全不透明"></a>3.尽量把views设置为完全不透明</h5><ul>
<li><p>如果你有透明的Views你应该设置它们的opaque(不透明)属性为YES。例如一个黑色半透明的可以设置为一个灰色不透明的View替代.原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p>
<ul>
<li>Apple的文档对于为图片设置透明属性的描述是：<br>(opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</li>
</ul>
</li>
</ul>
<ul>
<li><p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p>
</li>
<li><p>换种说法，大家可能更好理解：</p>
<p> 只要一个视图的不透明度小于1,就会导致blending.blending操作在iOS的图形处理器（GPU）中完成的,blending主要指的是混合像素颜色的计算。举个例子,我们把两个图层叠加在一起,如果第一个图层的有透明效果,则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。</p>
<ul>
<li><p>为什么Blending会导致性能的损失？</p>
<p>原因是很直观的,如果一个图层是完全不透明的,则系统直接显示该图层的颜色即可。而如果图层是带透明效果的,则会引入更多的计算,因为需要把下面的图层也包括进来,进行混合后颜色的计算。</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-避免过于庞大的XIB"><a href="#4-避免过于庞大的XIB" class="headerlink" title="4. 避免过于庞大的XIB"></a>4. 避免过于庞大的XIB</h5><ul>
<li><p>iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。</p>
</li>
<li><p>如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>
</li>
<li><p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的imageNamed:方法来获取图片资源。</p>
</li>
</ul>
<h5 id="5-不要阻塞主线程"><a href="#5-不要阻塞主线程" class="headerlink" title="5. 不要阻塞主线程"></a>5. 不要阻塞主线程</h5><ul>
<li><p>永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应</p>
</li>
<li><p>大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。或者使用像 AFNetworking这样的框架来异步地做这些操作。</p>
</li>
<li>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.<br>  你可以使用NSURLConnection异步地做网络操作:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler</div></pre></td></tr></table></figure>
<h5 id="6-在Image-Views中调整图片大小"><a href="#6-在Image-Views中调整图片大小" class="headerlink" title="6. 在Image Views中调整图片大小"></a>6. 在Image Views中调整图片大小</h5><ul>
<li>如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</li>
<li>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</li>
</ul>
<h5 id="7-选择正确的Collection"><a href="#7-选择正确的Collection" class="headerlink" title="7. 选择正确的Collection"></a>7. 选择正确的Collection</h5><ul>
<li><p>学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。</p>
</li>
<li><p>Apple有一个 Collections Programming Topics 的文档详尽介绍了可用的classes间的差别和你该在哪些场景中使用它们。这对于任何使用collections的人来说是一个必读的文档。<br>呵呵，我就知道你因为太长没看…这是一些常见collection的总结：</p>
<p>  Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。<br>  Dictionaries: 存储键值对。 用键来查找比较快。<br>  Sets: 无序的一组值。用值来查找很快，插入/删除很快。</p>
</li>
</ul>
<h5 id="8-打开gzip压缩"><a href="#8-打开gzip压缩" class="headerlink" title="8. 打开gzip压缩"></a>8. 打开gzip压缩</h5><ul>
<li>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</li>
<li>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。<ul>
<li>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。</li>
</ul>
</li>
</ul>
<h5 id="9-重用和延迟加载-lazy-load-Views"><a href="#9-重用和延迟加载-lazy-load-Views" class="headerlink" title="9. 重用和延迟加载(lazy load) Views"></a>9. 重用和延迟加载(lazy load) Views</h5><ul>
<li>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</li>
<li>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</li>
<li><p>这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。<br>创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p>
<ol>
<li>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</li>
<li>当需要时才创建并展示。</li>
</ol>
</li>
<li><p>每个方案都有其优缺点。</p>
<ul>
<li>用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</li>
<li>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</li>
</ul>
</li>
</ul>
<h5 id="10-Cache-Cache-还是Cache"><a href="#10-Cache-Cache-还是Cache" class="headerlink" title="10. Cache, Cache, 还是Cache!"></a>10. Cache, Cache, 还是Cache!</h5><ul>
<li><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。<br>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p>
</li>
<li><p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。<br>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url &#123;</div><div class="line"> NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div><div class="line"></div><div class="line"> request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image</div><div class="line"> request.HTTPShouldHandleCookies = NO;</div><div class="line"> request.HTTPShouldUsePipelining = YES;</div><div class="line"> [request addValue:@&quot;image/*&quot;forHTTPHeaderField:@&quot;Accept&quot;];</div><div class="line"></div><div class="line"> returnrequest;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p>
</li>
<li><p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。<br><code>NSCache</code>和<code>NSDictionary</code>类似，不同的是系统回收内存的时候它会自动删掉它的内容。</p>
</li>
</ul>
<h5 id="11-权衡渲染方法"><a href="#11-权衡渲染方法" class="headerlink" title="11. 权衡渲染方法"></a>11. 权衡渲染方法</h5><ul>
<li><p>在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，或者可以用CALayer， CoreGraphics甚至OpenGL来画它们。<br>当然每个不同的解决方法都有不同的复杂程度和相应的性能。有一篇Apple UIKit team中的一员Andy Matuschak推荐过的很棒的关于graphic性能的帖子很值得一读。</p>
</li>
<li><p>简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积 – 这就是使用可变大小的图片更好的地方了: 你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。</p>
</li>
<li>然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。</li>
<li>总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。</li>
</ul>
<h5 id="12-处理内存警告"><a href="#12-处理内存警告" class="headerlink" title="12. 处理内存警告"></a>12. 处理内存警告</h5><ul>
<li>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:<br>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.<br>幸运的是，UIKit提供了几种收集低内存警告的方法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 在app delegate中使用applicationDidReceiveMemoryWarning: 的方法</div><div class="line">* 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning</div><div class="line">* 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</div></pre></td></tr></table></figure>
<ul>
<li><p>一旦收到这类通知，你就需要释放任何不必要的内存使用。<br>例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>
</li>
<li><p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。<br>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>
</li>
</ul>
<h5 id="13-重用大开销对象"><a href="#13-重用大开销对象" class="headerlink" title="13. 重用大开销对象"></a>13. 重用大开销对象</h5><ul>
<li><p>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。<br>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p>
</li>
<li><p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。<br>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// in your .h or inside a class extension</div><div class="line">@property (nonatomic, strong) NSDateFormatter *formatter;</div><div class="line"></div><div class="line">// inside the implementation (.m)</div><div class="line">// When you need, just use self.formatter</div><div class="line">- (NSDateFormatter *)formatter &#123;</div><div class="line">    if(! _formatter) &#123;</div><div class="line">        _formatter = [[NSDateFormatter alloc] init];</div><div class="line">        _formatter.dateFormat = @&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;;// twitter date format</div><div class="line">    &#125;</div><div class="line">    return_formatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</li>
</ul>
<h5 id="14-使用Sprite-Sheets"><a href="#14-使用Sprite-Sheets" class="headerlink" title="14. 使用Sprite Sheets"></a>14. 使用Sprite Sheets</h5><ul>
<li>你是一个游戏开发者吗，那么Sprite sheets一定是一个你的最好的朋友了。Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。<br>我们有两个很好的关于Sprite的教程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How To Use Animations and Sprite Sheets in Cocos2D</div><div class="line">How to Create and Optimize Sprite Sheets in Cocos2D with Texture Packer and Pixel Formats</div></pre></td></tr></table></figure>
<ul>
<li>第二个教程涵盖了可能在很大程度上影响你游戏性能的pixel格式的细节。<br>如果你对于spirte sheet还不是很熟悉，可以看下这两个(youtube)视频SpriteSheets – The Movie, Part 1 和Part 2。视频的作者是创建Sprite sheet很流行的工具之一Texture Packer的作者Andreas Löw。<br>除了使用Sprite sheets，其它写在这里的建议当然也可以用于游戏开发中。比如你需要很多的Sprite sheets，像敌人，导弹之类的动作类必备元素，你可以重用这些sprites而不用每次都要重新创建。</li>
</ul>
<h5 id="15-避免反复处理数据"><a href="#15-避免反复处理数据" class="headerlink" title="15. 避免反复处理数据"></a>15. 避免反复处理数据</h5><ul>
<li>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。<br>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</li>
<li>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</li>
</ul>
<h5 id="16-选择正确的数据格式"><a href="#16-选择正确的数据格式" class="headerlink" title="16. 选择正确的数据格式"></a>16. 选择正确的数据格式</h5><p>从app和网络服务间传输数据有很多方案，最常见的就是JSON和XML。你需要选择对你的app来说最合适的一个。</p>
<ul>
<li>解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。</li>
<li>但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</li>
</ul>
<h5 id="17-正确设定背景图片"><a href="#17-正确设定背景图片" class="headerlink" title="17. 正确设定背景图片"></a>17. 正确设定背景图片</h5><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p>
<pre><code>使用UIColor的 colorWithPatternImage来设置背景色；
在view中添加一个UIImageView作为一个子View。
</code></pre><p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>
<pre><code>// You could also achieve the same result in Interface Builder
UIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;background&quot;]];
[self.view addSubview:backgroundView];
</code></pre><p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>
<pre><code>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;background&quot;]];
</code></pre><h5 id="18-减少使用Web特性"><a href="#18-减少使用Web特性" class="headerlink" title="18. 减少使用Web特性"></a>18. 减少使用Web特性</h5><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。<br>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。</p>
<p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。</p>
<p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。<br>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>
<p>更多相关信息可以看下 WWDC 2012 session #601 – Optimizing Web Content in UIWebViews and Websites on iOS</p>
<h5 id="19-设定Shadow-Path"><a href="#19-设定Shadow-Path" class="headerlink" title="19. 设定Shadow Path"></a>19. 设定Shadow Path</h5><p>如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">// Somewhere later ...</div><div class="line">UIView *view = [[UIView alloc] init];</div><div class="line"></div><div class="line">// Setup the shadow ...</div><div class="line">view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);</div><div class="line">view.layer.shadowRadius = 5.0f;</div><div class="line">view.layer.shadowOpacity = 0.6;</div></pre></td></tr></table></figure>
<p>看起来很简单，对吧。<br>可是，坏消息是使用这个方法也有它的问题… Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。<br>使用shadowPath的话就避免了这个问题：</p>
<pre><code>view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];
</code></pre><p>使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.<br>想了解更多可以看看Mark Pospesel的这篇。</p>
<h5 id="20-优化Table-View"><a href="#20-优化Table-View" class="headerlink" title="20. 优化Table View"></a>20. 优化Table View</h5><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。<br>为了保证table view平滑滚动，确保你采取了以下的措施:</p>
<pre><code>正确使用reuseIdentifier来重用cells
尽量使所有的view opaque，包括cell自身
避免渐变，图片缩放，后台选人
缓存行高
如果cell内现实的内容来自web，使用异步加载，缓存请求结果
使用shadowPath来画阴影
减少subviews的数量
尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果
使用正确的数据结构来存储数据
尽量使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate
</code></pre><h5 id="21-选择正确的数据存储选项"><a href="#21-选择正确的数据存储选项" class="headerlink" title="21. 选择正确的数据存储选项"></a>21. 选择正确的数据存储选项</h5><p>当做本地数据存储时你会怎么做？<br>你有很多选择，比如：</p>
<pre><code>使用NSUerDefaults
使用XML, JSON, 或者 plist
使用NSCoding存档
使用类似SQLite的本地SQL数据库
使用 Core Data
</code></pre><ul>
<li><p>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>
</li>
<li><p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>
</li>
<li><p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>
</li>
<li><p>当存储大块数据时,以上的方法都不适用. 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。<br>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>
</li>
</ul>
<h5 id="22-加速启动时间"><a href="#22-加速启动时间" class="headerlink" title="22. 加速启动时间"></a>22. 加速启动时间</h5><p>快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。</p>
<ul>
<li>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</li>
<li>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！<ul>
<li>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</li>
</ul>
</li>
</ul>
<h5 id="23-使用Autorelease-Pool"><a href="#23-使用Autorelease-Pool" class="headerlink" title="23. 使用Autorelease Pool"></a>23. 使用Autorelease Pool</h5><ul>
<li>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</li>
<li>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。<br>好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</div><div class="line">    for(NSURL *url in urls) &#123;</div><div class="line">        @autoreleasepool &#123;</div><div class="line">      NSError *error;</div><div class="line">      NSString *fileContents = [NSString stringWithContentsOfURL:url</div><div class="line">                                             encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">            /* Process the string, creating and autoreleasing more objects. */</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码在每次遍历后释放所有autorelease对象</p>
<h5 id="24-选择是否缓存图片"><a href="#24-选择是否缓存图片" class="headerlink" title="24. 选择是否缓存图片"></a>24. 选择是否缓存图片</h5><p>常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。</p>
<p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p>
<p>imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:<br>这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。<br>相反的，imageWithContentsOfFile仅加载图片。<br>下面的代码说明了这两种方法的用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;];// caching</div><div class="line">// or</div><div class="line">UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;];// no caching</div></pre></td></tr></table></figure>
<p>那么我们应该如何选择呢？<br>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。<br>然而，在图片反复重用的情况下imageNamed是一个好得多的选择。</p>
<h5 id="25-避免日期格式转换"><a href="#25-避免日期格式转换" class="headerlink" title="25. 避免日期格式转换"></a>25. 避免日期格式转换</h5><p>如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。<br>然而，如果你需要更多速度，那么直接用C是一个好的方案。Sam Soffes有一个不错的帖子<a href="http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="external">(点进进入)</a>里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。<br>嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！<br>如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   - (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp &#123;</div><div class="line">return[NSDate dateWithTimeIntervalSince1970:timestamp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样会比用C来解析日期字符串还快！<br>需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。</p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
